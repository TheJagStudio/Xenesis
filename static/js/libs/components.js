/*! For license information please see components.js.LICENSE.txt */
(() => {
    "use strict";
    var t = {
            8369: (t, e, i) => {
                var a;

                function s(t, e) {
                    var i = Object.keys(t);
                    if (Object.getOwnPropertySymbols) {
                        var a = Object.getOwnPropertySymbols(t);
                        e && (a = a.filter((function(e) {
                            return Object.getOwnPropertyDescriptor(t, e).enumerable
                        }))), i.push.apply(i, a)
                    }
                    return i
                }

                function n(t) {
                    for (var e = 1; e < arguments.length; e++) {
                        var i = null != arguments[e] ? arguments[e] : {};
                        e % 2 ? s(Object(i), !0).forEach((function(e) {
                            h(t, e, i[e])
                        })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : s(Object(i)).forEach((function(e) {
                            Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                        }))
                    }
                    return t
                }

                function r(t) {
                    return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                        return typeof t
                    } : function(t) {
                        return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
                    })(t)
                }

                function o(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function l(t, e) {
                    for (var i = 0; i < e.length; i++) {
                        var a = e[i];
                        a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
                    }
                }

                function c(t, e, i) {
                    return e && l(t.prototype, e), i && l(t, i), t
                }

                function h(t, e, i) {
                    return e in t ? Object.defineProperty(t, e, {
                        value: i,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : t[e] = i, t
                }

                function d(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && p(t, e)
                }

                function u(t) {
                    return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
                        return t.__proto__ || Object.getPrototypeOf(t)
                    })(t)
                }

                function p(t, e) {
                    return (p = Object.setPrototypeOf || function(t, e) {
                        return t.__proto__ = e, t
                    })(t, e)
                }

                function g(t, e) {
                    if (e && ("object" == typeof e || "function" == typeof e)) return e;
                    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
                    return function(t) {
                        if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return t
                    }(t)
                }

                function f(t) {
                    var e = function() {
                        if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                        if (Reflect.construct.sham) return !1;
                        if ("function" == typeof Proxy) return !0;
                        try {
                            return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {}))), !0
                        } catch (t) {
                            return !1
                        }
                    }();
                    return function() {
                        var i, a = u(t);
                        if (e) {
                            var s = u(this).constructor;
                            i = Reflect.construct(a, arguments, s)
                        } else i = a.apply(this, arguments);
                        return g(this, i)
                    }
                }

                function m(t) {
                    return function(t) {
                        if (Array.isArray(t)) return v(t)
                    }(t) || function(t) {
                        if ("undefined" != typeof Symbol && null != t[Symbol.iterator] || null != t["@@iterator"]) return Array.from(t)
                    }(t) || x(t) || function() {
                        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                    }()
                }

                function x(t, e) {
                    if (t) {
                        if ("string" == typeof t) return v(t, e);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? v(t, e) : void 0
                    }
                }

                function v(t, e) {
                    (null == e || e > t.length) && (e = t.length);
                    for (var i = 0, a = new Array(e); i < e; i++) a[i] = t[i];
                    return a
                }
                var b = function() {
                        function t() {
                            o(this, t)
                        }
                        return c(t, [{
                            key: "shadeRGBColor",
                            value: function(t, e) {
                                var i = e.split(","),
                                    a = t < 0 ? 0 : 255,
                                    s = t < 0 ? -1 * t : t,
                                    n = parseInt(i[0].slice(4), 10),
                                    r = parseInt(i[1], 10),
                                    o = parseInt(i[2], 10);
                                return "rgb(" + (Math.round((a - n) * s) + n) + "," + (Math.round((a - r) * s) + r) + "," + (Math.round((a - o) * s) + o) + ")"
                            }
                        }, {
                            key: "shadeHexColor",
                            value: function(t, e) {
                                var i = parseInt(e.slice(1), 16),
                                    a = t < 0 ? 0 : 255,
                                    s = t < 0 ? -1 * t : t,
                                    n = i >> 16,
                                    r = i >> 8 & 255,
                                    o = 255 & i;
                                return "#" + (16777216 + 65536 * (Math.round((a - n) * s) + n) + 256 * (Math.round((a - r) * s) + r) + (Math.round((a - o) * s) + o)).toString(16).slice(1)
                            }
                        }, {
                            key: "shadeColor",
                            value: function(e, i) {
                                return t.isColorHex(i) ? this.shadeHexColor(e, i) : this.shadeRGBColor(e, i)
                            }
                        }], [{
                            key: "bind",
                            value: function(t, e) {
                                return function() {
                                    return t.apply(e, arguments)
                                }
                            }
                        }, {
                            key: "isObject",
                            value: function(t) {
                                return t && "object" === r(t) && !Array.isArray(t) && null != t
                            }
                        }, {
                            key: "is",
                            value: function(t, e) {
                                return Object.prototype.toString.call(e) === "[object " + t + "]"
                            }
                        }, {
                            key: "listToArray",
                            value: function(t) {
                                var e, i = [];
                                for (e = 0; e < t.length; e++) i[e] = t[e];
                                return i
                            }
                        }, {
                            key: "extend",
                            value: function(t, e) {
                                var i = this;
                                "function" != typeof Object.assign && (Object.assign = function(t) {
                                    if (null == t) throw new TypeError("Cannot convert undefined or null to object");
                                    for (var e = Object(t), i = 1; i < arguments.length; i++) {
                                        var a = arguments[i];
                                        if (null != a)
                                            for (var s in a) a.hasOwnProperty(s) && (e[s] = a[s])
                                    }
                                    return e
                                });
                                var a = Object.assign({}, t);
                                return this.isObject(t) && this.isObject(e) && Object.keys(e).forEach((function(s) {
                                    i.isObject(e[s]) && s in t ? a[s] = i.extend(t[s], e[s]) : Object.assign(a, h({}, s, e[s]))
                                })), a
                            }
                        }, {
                            key: "extendArray",
                            value: function(e, i) {
                                var a = [];
                                return e.map((function(e) {
                                    a.push(t.extend(i, e))
                                })), a
                            }
                        }, {
                            key: "monthMod",
                            value: function(t) {
                                return t % 12
                            }
                        }, {
                            key: "clone",
                            value: function(e) {
                                if (t.is("Array", e)) {
                                    for (var i = [], a = 0; a < e.length; a++) i[a] = this.clone(e[a]);
                                    return i
                                }
                                if (t.is("Null", e)) return null;
                                if (t.is("Date", e)) return e;
                                if ("object" === r(e)) {
                                    var s = {};
                                    for (var n in e) e.hasOwnProperty(n) && (s[n] = this.clone(e[n]));
                                    return s
                                }
                                return e
                            }
                        }, {
                            key: "log10",
                            value: function(t) {
                                return Math.log(t) / Math.LN10
                            }
                        }, {
                            key: "roundToBase10",
                            value: function(t) {
                                return Math.pow(10, Math.floor(Math.log10(t)))
                            }
                        }, {
                            key: "roundToBase",
                            value: function(t, e) {
                                return Math.pow(e, Math.floor(Math.log(t) / Math.log(e)))
                            }
                        }, {
                            key: "parseNumber",
                            value: function(t) {
                                return null === t ? t : parseFloat(t)
                            }
                        }, {
                            key: "randomId",
                            value: function() {
                                return (Math.random() + 1).toString(36).substring(4)
                            }
                        }, {
                            key: "noExponents",
                            value: function(t) {
                                var e = String(t).split(/[eE]/);
                                if (1 === e.length) return e[0];
                                var i = "",
                                    a = t < 0 ? "-" : "",
                                    s = e[0].replace(".", ""),
                                    n = Number(e[1]) + 1;
                                if (n < 0) {
                                    for (i = a + "0."; n++;) i += "0";
                                    return i + s.replace(/^-/, "")
                                }
                                for (n -= s.length; n--;) i += "0";
                                return s + i
                            }
                        }, {
                            key: "getDimensions",
                            value: function(t) {
                                var e = getComputedStyle(t, null),
                                    i = t.clientHeight,
                                    a = t.clientWidth;
                                return i -= parseFloat(e.paddingTop) + parseFloat(e.paddingBottom), [a -= parseFloat(e.paddingLeft) + parseFloat(e.paddingRight), i]
                            }
                        }, {
                            key: "getBoundingClientRect",
                            value: function(t) {
                                var e = t.getBoundingClientRect();
                                return {
                                    top: e.top,
                                    right: e.right,
                                    bottom: e.bottom,
                                    left: e.left,
                                    width: t.clientWidth,
                                    height: t.clientHeight,
                                    x: e.left,
                                    y: e.top
                                }
                            }
                        }, {
                            key: "getLargestStringFromArr",
                            value: function(t) {
                                return t.reduce((function(t, e) {
                                    return Array.isArray(e) && (e = e.reduce((function(t, e) {
                                        return t.length > e.length ? t : e
                                    }))), t.length > e.length ? t : e
                                }), 0)
                            }
                        }, {
                            key: "hexToRgba",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "#999999",
                                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : .6;
                                "#" !== t.substring(0, 1) && (t = "#999999");
                                var i = t.replace("#", "");
                                i = i.match(new RegExp("(.{" + i.length / 3 + "})", "g"));
                                for (var a = 0; a < i.length; a++) i[a] = parseInt(1 === i[a].length ? i[a] + i[a] : i[a], 16);
                                return void 0 !== e && i.push(e), "rgba(" + i.join(",") + ")"
                            }
                        }, {
                            key: "getOpacityFromRGBA",
                            value: function(t) {
                                return parseFloat(t.replace(/^.*,(.+)\)/, "$1"))
                            }
                        }, {
                            key: "rgb2hex",
                            value: function(t) {
                                return (t = t.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : ""
                            }
                        }, {
                            key: "isColorHex",
                            value: function(t) {
                                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)|(^#[0-9A-F]{8}$)/i.test(t)
                            }
                        }, {
                            key: "getPolygonPos",
                            value: function(t, e) {
                                for (var i = [], a = 2 * Math.PI / e, s = 0; s < e; s++) {
                                    var n = {};
                                    n.x = t * Math.sin(s * a), n.y = -t * Math.cos(s * a), i.push(n)
                                }
                                return i
                            }
                        }, {
                            key: "polarToCartesian",
                            value: function(t, e, i, a) {
                                var s = (a - 90) * Math.PI / 180;
                                return {
                                    x: t + i * Math.cos(s),
                                    y: e + i * Math.sin(s)
                                }
                            }
                        }, {
                            key: "escapeString",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "x",
                                    i = t.toString().slice();
                                return i.replace(/[` ~!@#$%^&*()|+\=?;:'",.<>{}[\]\\/]/gi, e)
                            }
                        }, {
                            key: "negToZero",
                            value: function(t) {
                                return t < 0 ? 0 : t
                            }
                        }, {
                            key: "moveIndexInArray",
                            value: function(t, e, i) {
                                if (i >= t.length)
                                    for (var a = i - t.length + 1; a--;) t.push(void 0);
                                return t.splice(i, 0, t.splice(e, 1)[0]), t
                            }
                        }, {
                            key: "extractNumber",
                            value: function(t) {
                                return parseFloat(t.replace(/[^\d.]*/g, ""))
                            }
                        }, {
                            key: "findAncestor",
                            value: function(t, e) {
                                for (;
                                    (t = t.parentElement) && !t.classList.contains(e););
                                return t
                            }
                        }, {
                            key: "setELstyles",
                            value: function(t, e) {
                                for (var i in e) e.hasOwnProperty(i) && (t.style.key = e[i])
                            }
                        }, {
                            key: "isNumber",
                            value: function(t) {
                                return !isNaN(t) && parseFloat(Number(t)) === t && !isNaN(parseInt(t, 10))
                            }
                        }, {
                            key: "isFloat",
                            value: function(t) {
                                return Number(t) === t && t % 1 != 0
                            }
                        }, {
                            key: "isSafari",
                            value: function() {
                                return /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
                            }
                        }, {
                            key: "isFirefox",
                            value: function() {
                                return navigator.userAgent.toLowerCase().indexOf("firefox") > -1
                            }
                        }, {
                            key: "isIE11",
                            value: function() {
                                if (-1 !== window.navigator.userAgent.indexOf("MSIE") || window.navigator.appVersion.indexOf("Trident/") > -1) return !0
                            }
                        }, {
                            key: "isIE",
                            value: function() {
                                var t = window.navigator.userAgent,
                                    e = t.indexOf("MSIE ");
                                if (e > 0) return parseInt(t.substring(e + 5, t.indexOf(".", e)), 10);
                                if (t.indexOf("Trident/") > 0) {
                                    var i = t.indexOf("rv:");
                                    return parseInt(t.substring(i + 3, t.indexOf(".", i)), 10)
                                }
                                var a = t.indexOf("Edge/");
                                return a > 0 && parseInt(t.substring(a + 5, t.indexOf(".", a)), 10)
                            }
                        }]), t
                    }(),
                    y = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.setEasingFunctions()
                        }
                        return c(t, [{
                            key: "setEasingFunctions",
                            value: function() {
                                var t;
                                if (!this.w.globals.easing) {
                                    switch (this.w.config.chart.animations.easing) {
                                        case "linear":
                                            t = "-";
                                            break;
                                        case "easein":
                                            t = "<";
                                            break;
                                        case "easeout":
                                            t = ">";
                                            break;
                                        case "easeinout":
                                        default:
                                            t = "<>";
                                            break;
                                        case "swing":
                                            t = function(t) {
                                                var e = 1.70158;
                                                return (t -= 1) * t * ((e + 1) * t + e) + 1
                                            };
                                            break;
                                        case "bounce":
                                            t = function(t) {
                                                return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                                            };
                                            break;
                                        case "elastic":
                                            t = function(t) {
                                                return t === !!t ? t : Math.pow(2, -10 * t) * Math.sin((t - .075) * (2 * Math.PI) / .3) + 1
                                            }
                                    }
                                    this.w.globals.easing = t
                                }
                            }
                        }, {
                            key: "animateLine",
                            value: function(t, e, i, a) {
                                t.attr(e).animate(a).attr(i)
                            }
                        }, {
                            key: "animateMarker",
                            value: function(t, e, i, a, s, n) {
                                e || (e = 0), t.attr({
                                    r: e,
                                    width: e,
                                    height: e
                                }).animate(a, s).attr({
                                    r: i,
                                    width: i.width,
                                    height: i.height
                                }).afterAll((function() {
                                    n()
                                }))
                            }
                        }, {
                            key: "animateCircle",
                            value: function(t, e, i, a, s) {
                                t.attr({
                                    r: e.r,
                                    cx: e.cx,
                                    cy: e.cy
                                }).animate(a, s).attr({
                                    r: i.r,
                                    cx: i.cx,
                                    cy: i.cy
                                })
                            }
                        }, {
                            key: "animateRect",
                            value: function(t, e, i, a, s) {
                                t.attr(e).animate(a).attr(i).afterAll((function() {
                                    return s()
                                }))
                            }
                        }, {
                            key: "animatePathsGradually",
                            value: function(t) {
                                var e = t.el,
                                    i = t.realIndex,
                                    a = t.j,
                                    s = t.fill,
                                    n = t.pathFrom,
                                    r = t.pathTo,
                                    o = t.speed,
                                    l = t.delay,
                                    c = this.w,
                                    h = 0;
                                c.config.chart.animations.animateGradually.enabled && (h = c.config.chart.animations.animateGradually.delay), c.config.chart.animations.dynamicAnimation.enabled && c.globals.dataChanged && "bar" !== c.config.chart.type && (h = 0), this.morphSVG(e, i, a, "line" !== c.config.chart.type || c.globals.comboCharts ? s : "stroke", n, r, o, l * h)
                            }
                        }, {
                            key: "showDelayedElements",
                            value: function() {
                                this.w.globals.delayedElements.forEach((function(t) {
                                    t.el.classList.remove("apexcharts-element-hidden")
                                }))
                            }
                        }, {
                            key: "animationCompleted",
                            value: function(t) {
                                var e = this.w;
                                e.globals.animationEnded || (e.globals.animationEnded = !0, this.showDelayedElements(), "function" == typeof e.config.chart.events.animationEnd && e.config.chart.events.animationEnd(this.ctx, {
                                    el: t,
                                    w: e
                                }))
                            }
                        }, {
                            key: "morphSVG",
                            value: function(t, e, i, a, s, n, r, o) {
                                var l = this,
                                    c = this.w;
                                s || (s = t.attr("pathFrom")), n || (n = t.attr("pathTo"));
                                var h = function(t) {
                                    return "radar" === c.config.chart.type && (r = 1), "M 0 ".concat(c.globals.gridHeight)
                                };
                                (!s || s.indexOf("undefined") > -1 || s.indexOf("NaN") > -1) && (s = h()), (!n || n.indexOf("undefined") > -1 || n.indexOf("NaN") > -1) && (n = h()), c.globals.shouldAnimate || (r = 1), t.plot(s).animate(1, c.globals.easing, o).plot(s).animate(r, c.globals.easing, o).plot(n).afterAll((function() {
                                    b.isNumber(i) ? i === c.globals.series[c.globals.maxValsInArrayIndex].length - 2 && c.globals.shouldAnimate && l.animationCompleted(t) : "none" !== a && c.globals.shouldAnimate && (!c.globals.comboCharts && e === c.globals.series.length - 1 || c.globals.comboCharts) && l.animationCompleted(t), l.showDelayedElements()
                                }))
                            }
                        }]), t
                    }(),
                    w = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "getDefaultFilter",
                            value: function(t, e) {
                                var i = this.w;
                                t.unfilter(!0), (new window.SVG.Filter).size("120%", "180%", "-5%", "-40%"), "none" !== i.config.states.normal.filter ? this.applyFilter(t, e, i.config.states.normal.filter.type, i.config.states.normal.filter.value) : i.config.chart.dropShadow.enabled && this.dropShadow(t, i.config.chart.dropShadow, e)
                            }
                        }, {
                            key: "addNormalFilter",
                            value: function(t, e) {
                                var i = this.w;
                                i.config.chart.dropShadow.enabled && !t.node.classList.contains("apexcharts-marker") && this.dropShadow(t, i.config.chart.dropShadow, e)
                            }
                        }, {
                            key: "addLightenFilter",
                            value: function(t, e, i) {
                                var a = this,
                                    s = this.w,
                                    n = i.intensity;
                                t.unfilter(!0), new window.SVG.Filter, t.filter((function(t) {
                                    var i = s.config.chart.dropShadow;
                                    (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({
                                        rgb: {
                                            type: "linear",
                                            slope: 1.5,
                                            intercept: n
                                        }
                                    })
                                })), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
                            }
                        }, {
                            key: "addDarkenFilter",
                            value: function(t, e, i) {
                                var a = this,
                                    s = this.w,
                                    n = i.intensity;
                                t.unfilter(!0), new window.SVG.Filter, t.filter((function(t) {
                                    var i = s.config.chart.dropShadow;
                                    (i.enabled ? a.addShadow(t, e, i) : t).componentTransfer({
                                        rgb: {
                                            type: "linear",
                                            slope: n
                                        }
                                    })
                                })), t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)
                            }
                        }, {
                            key: "applyFilter",
                            value: function(t, e, i) {
                                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .5;
                                switch (i) {
                                    case "none":
                                        this.addNormalFilter(t, e);
                                        break;
                                    case "lighten":
                                        this.addLightenFilter(t, e, {
                                            intensity: a
                                        });
                                        break;
                                    case "darken":
                                        this.addDarkenFilter(t, e, {
                                            intensity: a
                                        })
                                }
                            }
                        }, {
                            key: "addShadow",
                            value: function(t, e, i) {
                                var a = i.blur,
                                    s = i.top,
                                    n = i.left,
                                    r = i.color,
                                    o = i.opacity,
                                    l = t.flood(Array.isArray(r) ? r[e] : r, o).composite(t.sourceAlpha, "in").offset(n, s).gaussianBlur(a).merge(t.source);
                                return t.blend(t.source, l)
                            }
                        }, {
                            key: "dropShadow",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                    a = e.top,
                                    s = e.left,
                                    n = e.blur,
                                    r = e.color,
                                    o = e.opacity,
                                    l = e.noUserSpaceOnUse,
                                    c = this.w;
                                return t.unfilter(!0), b.isIE() && "radialBar" === c.config.chart.type || (r = Array.isArray(r) ? r[i] : r, t.filter((function(t) {
                                    var e;
                                    e = b.isSafari() || b.isFirefox() || b.isIE() ? t.flood(r, o).composite(t.sourceAlpha, "in").offset(s, a).gaussianBlur(n) : t.flood(r, o).composite(t.sourceAlpha, "in").offset(s, a).gaussianBlur(n).merge(t.source), t.blend(t.source, e)
                                })), l || t.filterer.node.setAttribute("filterUnits", "userSpaceOnUse"), this._scaleFilterSize(t.filterer.node)), t
                            }
                        }, {
                            key: "setSelectionFilter",
                            value: function(t, e, i) {
                                var a = this.w;
                                if (void 0 !== a.globals.selectedDataPoints[e] && a.globals.selectedDataPoints[e].indexOf(i) > -1) {
                                    t.node.setAttribute("selected", !0);
                                    var s = a.config.states.active.filter;
                                    "none" !== s && this.applyFilter(t, e, s.type, s.value)
                                }
                            }
                        }, {
                            key: "_scaleFilterSize",
                            value: function(t) {
                                ! function(e) {
                                    for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i])
                                }({
                                    width: "200%",
                                    height: "200%",
                                    x: "-50%",
                                    y: "-50%"
                                })
                            }
                        }]), t
                    }(),
                    S = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "drawLine",
                            value: function(t, e, i, a) {
                                var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : "#a8a8a8",
                                    n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : 0,
                                    r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                                    o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : "butt",
                                    l = this.w,
                                    c = l.globals.dom.Paper.line().attr({
                                        x1: t,
                                        y1: e,
                                        x2: i,
                                        y2: a,
                                        stroke: s,
                                        "stroke-dasharray": n,
                                        "stroke-width": r,
                                        "stroke-linecap": o
                                    });
                                return c
                            }
                        }, {
                            key: "drawRect",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0,
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0,
                                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                    s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                                    n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "#fefefe",
                                    r = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : 1,
                                    o = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                                    l = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : null,
                                    c = arguments.length > 9 && void 0 !== arguments[9] ? arguments[9] : 0,
                                    h = this.w,
                                    d = h.globals.dom.Paper.rect();
                                return d.attr({
                                    x: t,
                                    y: e,
                                    width: i > 0 ? i : 0,
                                    height: a > 0 ? a : 0,
                                    rx: s,
                                    ry: s,
                                    opacity: r,
                                    "stroke-width": null !== o ? o : 0,
                                    stroke: null !== l ? l : "none",
                                    "stroke-dasharray": c
                                }), d.node.setAttribute("fill", n), d
                            }
                        }, {
                            key: "drawPolygon",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "#e1e1e1",
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1,
                                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "none",
                                    s = this.w,
                                    n = s.globals.dom.Paper.polygon(t).attr({
                                        fill: a,
                                        stroke: e,
                                        "stroke-width": i
                                    });
                                return n
                            }
                        }, {
                            key: "drawCircle",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                    i = this.w;
                                t < 0 && (t = 0);
                                var a = i.globals.dom.Paper.circle(2 * t);
                                return null !== e && a.attr(e), a
                            }
                        }, {
                            key: "drawPath",
                            value: function(t) {
                                var e = t.d,
                                    i = void 0 === e ? "" : e,
                                    a = t.stroke,
                                    s = void 0 === a ? "#a8a8a8" : a,
                                    n = t.strokeWidth,
                                    r = void 0 === n ? 1 : n,
                                    o = t.fill,
                                    l = t.fillOpacity,
                                    c = void 0 === l ? 1 : l,
                                    h = t.strokeOpacity,
                                    d = void 0 === h ? 1 : h,
                                    u = t.classes,
                                    p = t.strokeLinecap,
                                    g = void 0 === p ? null : p,
                                    f = t.strokeDashArray,
                                    m = void 0 === f ? 0 : f,
                                    x = this.w;
                                return null === g && (g = x.config.stroke.lineCap), (i.indexOf("undefined") > -1 || i.indexOf("NaN") > -1) && (i = "M 0 ".concat(x.globals.gridHeight)), x.globals.dom.Paper.path(i).attr({
                                    fill: o,
                                    "fill-opacity": c,
                                    stroke: s,
                                    "stroke-opacity": d,
                                    "stroke-linecap": g,
                                    "stroke-width": r,
                                    "stroke-dasharray": m,
                                    class: u
                                })
                            }
                        }, {
                            key: "group",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                    e = this.w,
                                    i = e.globals.dom.Paper.group();
                                return null !== t && i.attr(t), i
                            }
                        }, {
                            key: "move",
                            value: function(t, e) {
                                return ["M", t, e].join(" ")
                            }
                        }, {
                            key: "line",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                    a = null;
                                return null === i ? a = ["L", t, e].join(" ") : "H" === i ? a = ["H", t].join(" ") : "V" === i && (a = ["V", e].join(" ")), a
                            }
                        }, {
                            key: "curve",
                            value: function(t, e, i, a, s, n) {
                                return ["C", t, e, i, a, s, n].join(" ")
                            }
                        }, {
                            key: "quadraticCurve",
                            value: function(t, e, i, a) {
                                return ["Q", t, e, i, a].join(" ")
                            }
                        }, {
                            key: "arc",
                            value: function(t, e, i, a, s, n, r) {
                                var o = arguments.length > 7 && void 0 !== arguments[7] && arguments[7],
                                    l = "A";
                                o && (l = "a");
                                var c = [l, t, e, i, a, s, n, r].join(" ");
                                return c
                            }
                        }, {
                            key: "renderPaths",
                            value: function(t) {
                                var e, i = t.j,
                                    a = t.realIndex,
                                    s = t.pathFrom,
                                    r = t.pathTo,
                                    o = t.stroke,
                                    l = t.strokeWidth,
                                    c = t.strokeLinecap,
                                    h = t.fill,
                                    d = t.animationDelay,
                                    u = t.initialSpeed,
                                    p = t.dataChangeSpeed,
                                    g = t.className,
                                    f = t.shouldClipToGrid,
                                    m = void 0 === f || f,
                                    x = t.bindEventsOnPaths,
                                    v = void 0 === x || x,
                                    b = t.drawShadow,
                                    S = void 0 === b || b,
                                    C = this.w,
                                    k = new w(this.ctx),
                                    A = new y(this.ctx),
                                    E = this.w.config.chart.animations.enabled,
                                    T = E && this.w.config.chart.animations.dynamicAnimation.enabled,
                                    P = !!(E && !C.globals.resized || T && C.globals.dataChanged && C.globals.shouldAnimate);
                                P ? e = s : (e = r, C.globals.animationEnded = !0);
                                var M, L = C.config.stroke.dashArray;
                                M = Array.isArray(L) ? L[a] : C.config.stroke.dashArray;
                                var I = this.drawPath({
                                    d: e,
                                    stroke: o,
                                    strokeWidth: l,
                                    fill: h,
                                    fillOpacity: 1,
                                    classes: g,
                                    strokeLinecap: c,
                                    strokeDashArray: M
                                });
                                if (I.attr("index", a), m && I.attr({
                                        "clip-path": "url(#gridRectMask".concat(C.globals.cuid, ")")
                                    }), "none" !== C.config.states.normal.filter.type) k.getDefaultFilter(I, a);
                                else if (C.config.chart.dropShadow.enabled && S && (!C.config.chart.dropShadow.enabledOnSeries || C.config.chart.dropShadow.enabledOnSeries && -1 !== C.config.chart.dropShadow.enabledOnSeries.indexOf(a))) {
                                    var _ = C.config.chart.dropShadow;
                                    k.dropShadow(I, _, a)
                                }
                                v && (I.node.addEventListener("mouseenter", this.pathMouseEnter.bind(this, I)), I.node.addEventListener("mouseleave", this.pathMouseLeave.bind(this, I)), I.node.addEventListener("mousedown", this.pathMouseDown.bind(this, I))), I.attr({
                                    pathTo: r,
                                    pathFrom: s
                                });
                                var z = {
                                    el: I,
                                    j: i,
                                    realIndex: a,
                                    pathFrom: s,
                                    pathTo: r,
                                    fill: h,
                                    strokeWidth: l,
                                    delay: d
                                };
                                return !E || C.globals.resized || C.globals.dataChanged ? !C.globals.resized && C.globals.dataChanged || A.showDelayedElements() : A.animatePathsGradually(n(n({}, z), {}, {
                                    speed: u
                                })), C.globals.dataChanged && T && P && A.animatePathsGradually(n(n({}, z), {}, {
                                    speed: p
                                })), I
                            }
                        }, {
                            key: "drawPattern",
                            value: function(t, e, i) {
                                var a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : "#a8a8a8",
                                    s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 0,
                                    n = this.w,
                                    r = n.globals.dom.Paper.pattern(e, i, (function(n) {
                                        "horizontalLines" === t ? n.line(0, 0, i, 0).stroke({
                                            color: a,
                                            width: s + 1
                                        }) : "verticalLines" === t ? n.line(0, 0, 0, e).stroke({
                                            color: a,
                                            width: s + 1
                                        }) : "slantedLines" === t ? n.line(0, 0, e, i).stroke({
                                            color: a,
                                            width: s
                                        }) : "squares" === t ? n.rect(e, i).fill("none").stroke({
                                            color: a,
                                            width: s
                                        }) : "circles" === t && n.circle(e).fill("none").stroke({
                                            color: a,
                                            width: s
                                        })
                                    }));
                                return r
                            }
                        }, {
                            key: "drawGradient",
                            value: function(t, e, i, a, s) {
                                var n, r = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                    o = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : null,
                                    l = arguments.length > 7 && void 0 !== arguments[7] ? arguments[7] : null,
                                    c = arguments.length > 8 && void 0 !== arguments[8] ? arguments[8] : 0,
                                    h = this.w;
                                e.length < 9 && 0 === e.indexOf("#") && (e = b.hexToRgba(e, a)), i.length < 9 && 0 === i.indexOf("#") && (i = b.hexToRgba(i, s));
                                var d = 0,
                                    u = 1,
                                    p = 1,
                                    g = null;
                                null !== o && (d = void 0 !== o[0] ? o[0] / 100 : 0, u = void 0 !== o[1] ? o[1] / 100 : 1, p = void 0 !== o[2] ? o[2] / 100 : 1, g = void 0 !== o[3] ? o[3] / 100 : null);
                                var f = !("donut" !== h.config.chart.type && "pie" !== h.config.chart.type && "polarArea" !== h.config.chart.type && "bubble" !== h.config.chart.type);
                                if (n = null === l || 0 === l.length ? h.globals.dom.Paper.gradient(f ? "radial" : "linear", (function(t) {
                                        t.at(d, e, a), t.at(u, i, s), t.at(p, i, s), null !== g && t.at(g, e, a)
                                    })) : h.globals.dom.Paper.gradient(f ? "radial" : "linear", (function(t) {
                                        (Array.isArray(l[c]) ? l[c] : l).forEach((function(e) {
                                            t.at(e.offset / 100, e.color, e.opacity)
                                        }))
                                    })), f) {
                                    var m = h.globals.gridWidth / 2,
                                        x = h.globals.gridHeight / 2;
                                    "bubble" !== h.config.chart.type ? n.attr({
                                        gradientUnits: "userSpaceOnUse",
                                        cx: m,
                                        cy: x,
                                        r
                                    }) : n.attr({
                                        cx: .5,
                                        cy: .5,
                                        r: .8,
                                        fx: .2,
                                        fy: .2
                                    })
                                } else "vertical" === t ? n.from(0, 0).to(0, 1) : "diagonal" === t ? n.from(0, 0).to(1, 1) : "horizontal" === t ? n.from(0, 1).to(1, 1) : "diagonal2" === t && n.from(1, 0).to(0, 1);
                                return n
                            }
                        }, {
                            key: "getTextBasedOnMaxWidth",
                            value: function(t) {
                                var e = t.text,
                                    i = t.maxWidth,
                                    a = t.fontSize,
                                    s = t.fontFamily,
                                    n = this.getTextRects(e, a, s),
                                    r = n.width / e.length,
                                    o = Math.floor(i / r);
                                return i < n.width ? e.slice(0, o - 3) + "..." : e
                            }
                        }, {
                            key: "drawText",
                            value: function(t) {
                                var e = this,
                                    i = t.x,
                                    a = t.y,
                                    s = t.text,
                                    r = t.textAnchor,
                                    o = t.fontSize,
                                    l = t.fontFamily,
                                    c = t.fontWeight,
                                    h = t.foreColor,
                                    d = t.opacity,
                                    u = t.maxWidth,
                                    p = t.cssClass,
                                    g = void 0 === p ? "" : p,
                                    f = t.isPlainText,
                                    m = void 0 === f || f,
                                    x = this.w;
                                void 0 === s && (s = "");
                                var v = s;
                                r || (r = "start"), h && h.length || (h = x.config.chart.foreColor), l = l || x.config.chart.fontFamily, c = c || "regular";
                                var b, y = {
                                    maxWidth: u,
                                    fontSize: o = o || "11px",
                                    fontFamily: l
                                };
                                return Array.isArray(s) ? b = x.globals.dom.Paper.text((function(t) {
                                    for (var i = 0; i < s.length; i++) v = s[i], u && (v = e.getTextBasedOnMaxWidth(n({
                                        text: s[i]
                                    }, y))), 0 === i ? t.tspan(v) : t.tspan(v).newLine()
                                })) : (u && (v = this.getTextBasedOnMaxWidth(n({
                                    text: s
                                }, y))), b = m ? x.globals.dom.Paper.plain(s) : x.globals.dom.Paper.text((function(t) {
                                    return t.tspan(v)
                                }))), b.attr({
                                    x: i,
                                    y: a,
                                    "text-anchor": r,
                                    "dominant-baseline": "auto",
                                    "font-size": o,
                                    "font-family": l,
                                    "font-weight": c,
                                    fill: h,
                                    class: "apexcharts-text " + g
                                }), b.node.style.fontFamily = l, b.node.style.opacity = d, b
                            }
                        }, {
                            key: "drawMarker",
                            value: function(t, e, i) {
                                t = t || 0;
                                var a = i.pSize || 0,
                                    s = null;
                                if ("square" === i.shape || "rect" === i.shape) {
                                    var n = void 0 === i.pRadius ? a / 2 : i.pRadius;
                                    null !== e && a || (a = 0, n = 0);
                                    var r = 1.2 * a + n,
                                        o = this.drawRect(r, r, r, r, n);
                                    o.attr({
                                        x: t - r / 2,
                                        y: e - r / 2,
                                        cx: t,
                                        cy: e,
                                        class: i.class ? i.class : "",
                                        fill: i.pointFillColor,
                                        "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                                        stroke: i.pointStrokeColor,
                                        "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                                        "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                                    }), s = o
                                } else "circle" !== i.shape && i.shape || (b.isNumber(e) || (a = 0, e = 0), s = this.drawCircle(a, {
                                    cx: t,
                                    cy: e,
                                    class: i.class ? i.class : "",
                                    stroke: i.pointStrokeColor,
                                    fill: i.pointFillColor,
                                    "fill-opacity": i.pointFillOpacity ? i.pointFillOpacity : 1,
                                    "stroke-width": i.pointStrokeWidth ? i.pointStrokeWidth : 0,
                                    "stroke-opacity": i.pointStrokeOpacity ? i.pointStrokeOpacity : 1
                                }));
                                return s
                            }
                        }, {
                            key: "pathMouseEnter",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new w(this.ctx),
                                    s = parseInt(t.node.getAttribute("index"), 10),
                                    n = parseInt(t.node.getAttribute("j"), 10);
                                if ("function" == typeof i.config.chart.events.dataPointMouseEnter && i.config.chart.events.dataPointMouseEnter(e, this.ctx, {
                                        seriesIndex: s,
                                        dataPointIndex: n,
                                        w: i
                                    }), this.ctx.events.fireEvent("dataPointMouseEnter", [e, this.ctx, {
                                        seriesIndex: s,
                                        dataPointIndex: n,
                                        w: i
                                    }]), ("none" === i.config.states.active.filter.type || "true" !== t.node.getAttribute("selected")) && "none" !== i.config.states.hover.filter.type && !i.globals.isTouchDevice) {
                                    var r = i.config.states.hover.filter;
                                    a.applyFilter(t, s, r.type, r.value)
                                }
                            }
                        }, {
                            key: "pathMouseLeave",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new w(this.ctx),
                                    s = parseInt(t.node.getAttribute("index"), 10),
                                    n = parseInt(t.node.getAttribute("j"), 10);
                                "function" == typeof i.config.chart.events.dataPointMouseLeave && i.config.chart.events.dataPointMouseLeave(e, this.ctx, {
                                    seriesIndex: s,
                                    dataPointIndex: n,
                                    w: i
                                }), this.ctx.events.fireEvent("dataPointMouseLeave", [e, this.ctx, {
                                    seriesIndex: s,
                                    dataPointIndex: n,
                                    w: i
                                }]), "none" !== i.config.states.active.filter.type && "true" === t.node.getAttribute("selected") || "none" !== i.config.states.hover.filter.type && a.getDefaultFilter(t, s)
                            }
                        }, {
                            key: "pathMouseDown",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new w(this.ctx),
                                    s = parseInt(t.node.getAttribute("index"), 10),
                                    n = parseInt(t.node.getAttribute("j"), 10),
                                    r = "false";
                                if ("true" === t.node.getAttribute("selected")) {
                                    if (t.node.setAttribute("selected", "false"), i.globals.selectedDataPoints[s].indexOf(n) > -1) {
                                        var o = i.globals.selectedDataPoints[s].indexOf(n);
                                        i.globals.selectedDataPoints[s].splice(o, 1)
                                    }
                                } else {
                                    if (!i.config.states.active.allowMultipleDataPointsSelection && i.globals.selectedDataPoints.length > 0) {
                                        i.globals.selectedDataPoints = [];
                                        var l = i.globals.dom.Paper.select(".apexcharts-series path").members,
                                            c = i.globals.dom.Paper.select(".apexcharts-series circle, .apexcharts-series rect").members,
                                            h = function(t) {
                                                Array.prototype.forEach.call(t, (function(t) {
                                                    t.node.setAttribute("selected", "false"), a.getDefaultFilter(t, s)
                                                }))
                                            };
                                        h(l), h(c)
                                    }
                                    t.node.setAttribute("selected", "true"), r = "true", void 0 === i.globals.selectedDataPoints[s] && (i.globals.selectedDataPoints[s] = []), i.globals.selectedDataPoints[s].push(n)
                                }
                                if ("true" === r) {
                                    var d = i.config.states.active.filter;
                                    if ("none" !== d) a.applyFilter(t, s, d.type, d.value);
                                    else if ("none" !== i.config.states.hover.filter && !i.globals.isTouchDevice) {
                                        var u = i.config.states.hover.filter;
                                        a.applyFilter(t, s, u.type, u.value)
                                    }
                                } else "none" !== i.config.states.active.filter.type && ("none" === i.config.states.hover.filter.type || i.globals.isTouchDevice ? a.getDefaultFilter(t, s) : (u = i.config.states.hover.filter, a.applyFilter(t, s, u.type, u.value)));
                                "function" == typeof i.config.chart.events.dataPointSelection && i.config.chart.events.dataPointSelection(e, this.ctx, {
                                    selectedDataPoints: i.globals.selectedDataPoints,
                                    seriesIndex: s,
                                    dataPointIndex: n,
                                    w: i
                                }), e && this.ctx.events.fireEvent("dataPointSelection", [e, this.ctx, {
                                    selectedDataPoints: i.globals.selectedDataPoints,
                                    seriesIndex: s,
                                    dataPointIndex: n,
                                    w: i
                                }])
                            }
                        }, {
                            key: "rotateAroundCenter",
                            value: function(t) {
                                var e = {};
                                return t && "function" == typeof t.getBBox && (e = t.getBBox()), {
                                    x: e.x + e.width / 2,
                                    y: e.y + e.height / 2
                                }
                            }
                        }, {
                            key: "getTextRects",
                            value: function(t, e, i, a) {
                                var s = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                    n = this.w,
                                    r = this.drawText({
                                        x: -200,
                                        y: -200,
                                        text: t,
                                        textAnchor: "start",
                                        fontSize: e,
                                        fontFamily: i,
                                        foreColor: "#fff",
                                        opacity: 0
                                    });
                                a && r.attr("transform", a), n.globals.dom.Paper.add(r);
                                var o = r.bbox();
                                return s || (o = r.node.getBoundingClientRect()), r.remove(), {
                                    width: o.width,
                                    height: o.height
                                }
                            }
                        }, {
                            key: "placeTextWithEllipsis",
                            value: function(t, e, i) {
                                if ("function" == typeof t.getComputedTextLength && (t.textContent = e, e.length > 0 && t.getComputedTextLength() >= i / 1.1)) {
                                    for (var a = e.length - 3; a > 0; a -= 3)
                                        if (t.getSubStringLength(0, a) <= i / 1.1) return void(t.textContent = e.substring(0, a) + "...");
                                    t.textContent = "."
                                }
                            }
                        }], [{
                            key: "setAttrs",
                            value: function(t, e) {
                                for (var i in e) e.hasOwnProperty(i) && t.setAttribute(i, e[i])
                            }
                        }]), t
                    }(),
                    C = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "getStackedSeriesTotals",
                            value: function() {
                                var t = this.w,
                                    e = [];
                                if (0 === t.globals.series.length) return e;
                                for (var i = 0; i < t.globals.series[t.globals.maxValsInArrayIndex].length; i++) {
                                    for (var a = 0, s = 0; s < t.globals.series.length; s++) void 0 !== t.globals.series[s][i] && (a += t.globals.series[s][i]);
                                    e.push(a)
                                }
                                return t.globals.stackedSeriesTotals = e, e
                            }
                        }, {
                            key: "getSeriesTotalByIndex",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                                return null === t ? this.w.config.series.reduce((function(t, e) {
                                    return t + e
                                }), 0) : this.w.globals.series[t].reduce((function(t, e) {
                                    return t + e
                                }), 0)
                            }
                        }, {
                            key: "isSeriesNull",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
                                return 0 === (null === t ? this.w.config.series.filter((function(t) {
                                    return null !== t
                                })) : this.w.config.series[t].data.filter((function(t) {
                                    return null !== t
                                }))).length
                            }
                        }, {
                            key: "seriesHaveSameValues",
                            value: function(t) {
                                return this.w.globals.series[t].every((function(t, e, i) {
                                    return t === i[0]
                                }))
                            }
                        }, {
                            key: "getCategoryLabels",
                            value: function(t) {
                                var e = this.w,
                                    i = t.slice();
                                return e.config.xaxis.convertedCatToNumeric && (i = t.map((function(t, i) {
                                    return e.config.xaxis.labels.formatter(t - e.globals.minX + 1)
                                }))), i
                            }
                        }, {
                            key: "getLargestSeries",
                            value: function() {
                                var t = this.w;
                                t.globals.maxValsInArrayIndex = t.globals.series.map((function(t) {
                                    return t.length
                                })).indexOf(Math.max.apply(Math, t.globals.series.map((function(t) {
                                    return t.length
                                }))))
                            }
                        }, {
                            key: "getLargestMarkerSize",
                            value: function() {
                                var t = this.w,
                                    e = 0;
                                return t.globals.markers.size.forEach((function(t) {
                                    e = Math.max(e, t)
                                })), t.config.markers.discrete && t.config.markers.discrete.length && t.config.markers.discrete.forEach((function(t) {
                                    e = Math.max(e, t.size)
                                })), e > 0 && (e += t.config.markers.hover.sizeOffset + 1), t.globals.markers.largestSize = e, e
                            }
                        }, {
                            key: "getSeriesTotals",
                            value: function() {
                                var t = this.w;
                                t.globals.seriesTotals = t.globals.series.map((function(t, e) {
                                    var i = 0;
                                    if (Array.isArray(t))
                                        for (var a = 0; a < t.length; a++) i += t[a];
                                    else i += t;
                                    return i
                                }))
                            }
                        }, {
                            key: "getSeriesTotalsXRange",
                            value: function(t, e) {
                                var i = this.w;
                                return i.globals.series.map((function(a, s) {
                                    for (var n = 0, r = 0; r < a.length; r++) i.globals.seriesX[s][r] > t && i.globals.seriesX[s][r] < e && (n += a[r]);
                                    return n
                                }))
                            }
                        }, {
                            key: "getPercentSeries",
                            value: function() {
                                var t = this.w;
                                t.globals.seriesPercent = t.globals.series.map((function(e, i) {
                                    var a = [];
                                    if (Array.isArray(e))
                                        for (var s = 0; s < e.length; s++) {
                                            var n = t.globals.stackedSeriesTotals[s],
                                                r = 0;
                                            n && (r = 100 * e[s] / n), a.push(r)
                                        } else {
                                            var o = 100 * e / t.globals.seriesTotals.reduce((function(t, e) {
                                                return t + e
                                            }), 0);
                                            a.push(o)
                                        }
                                    return a
                                }))
                            }
                        }, {
                            key: "getCalculatedRatios",
                            value: function() {
                                var t, e, i, a, s = this.w.globals,
                                    n = [],
                                    r = 0,
                                    o = [],
                                    l = .1,
                                    c = 0;
                                if (s.yRange = [], s.isMultipleYAxis)
                                    for (var h = 0; h < s.minYArr.length; h++) s.yRange.push(Math.abs(s.minYArr[h] - s.maxYArr[h])), o.push(0);
                                else s.yRange.push(Math.abs(s.minY - s.maxY));
                                s.xRange = Math.abs(s.maxX - s.minX), s.zRange = Math.abs(s.maxZ - s.minZ);
                                for (var d = 0; d < s.yRange.length; d++) n.push(s.yRange[d] / s.gridHeight);
                                if (e = s.xRange / s.gridWidth, i = Math.abs(s.initialMaxX - s.initialMinX) / s.gridWidth, t = s.yRange / s.gridWidth, a = s.xRange / s.gridHeight, (r = s.zRange / s.gridHeight * 16) || (r = 1), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (s.hasNegs = !0), s.isMultipleYAxis) {
                                    o = [];
                                    for (var u = 0; u < n.length; u++) o.push(-s.minYArr[u] / n[u])
                                } else o.push(-s.minY / n[0]), s.minY !== Number.MIN_VALUE && 0 !== Math.abs(s.minY) && (l = -s.minY / t, c = s.minX / e);
                                return {
                                    yRatio: n,
                                    invertedYRatio: t,
                                    zRatio: r,
                                    xRatio: e,
                                    initialXRatio: i,
                                    invertedXRatio: a,
                                    baseLineInvertedY: l,
                                    baseLineY: o,
                                    baseLineX: c
                                }
                            }
                        }, {
                            key: "getLogSeries",
                            value: function(t) {
                                var e = this,
                                    i = this.w;
                                return i.globals.seriesLog = t.map((function(t, a) {
                                    return i.config.yaxis[a] && i.config.yaxis[a].logarithmic ? t.map((function(t) {
                                        return null === t ? null : e.getLogVal(i.config.yaxis[a].logBase, t, a)
                                    })) : t
                                })), i.globals.invalidLogScale ? t : i.globals.seriesLog
                            }
                        }, {
                            key: "getBaseLog",
                            value: function(t, e) {
                                return Math.log(e) / Math.log(t)
                            }
                        }, {
                            key: "getLogVal",
                            value: function(t, e, i) {
                                if (0 === e) return 0;
                                var a = this.w,
                                    s = 0 === a.globals.minYArr[i] ? -1 : this.getBaseLog(t, a.globals.minYArr[i]),
                                    n = (0 === a.globals.maxYArr[i] ? 0 : this.getBaseLog(t, a.globals.maxYArr[i])) - s;
                                return e < 1 ? e / n : (this.getBaseLog(t, e) - s) / n
                            }
                        }, {
                            key: "getLogYRatios",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = this.w.globals;
                                return a.yLogRatio = t.slice(), a.logYRange = a.yRange.map((function(t, s) {
                                    if (i.config.yaxis[s] && e.w.config.yaxis[s].logarithmic) {
                                        var n, r = -Number.MAX_VALUE,
                                            o = Number.MIN_VALUE;
                                        return a.seriesLog.forEach((function(t, e) {
                                            t.forEach((function(t) {
                                                i.config.yaxis[e] && i.config.yaxis[e].logarithmic && (r = Math.max(t, r), o = Math.min(t, o))
                                            }))
                                        })), n = Math.pow(a.yRange[s], Math.abs(o - r) / a.yRange[s]), a.yLogRatio[s] = n / a.gridHeight, n
                                    }
                                })), a.invalidLogScale ? t.slice() : a.yLogRatio
                            }
                        }], [{
                            key: "checkComboSeries",
                            value: function(t) {
                                var e = !1,
                                    i = 0,
                                    a = 0;
                                return t.length && void 0 !== t[0].type && t.forEach((function(t) {
                                    "bar" !== t.type && "column" !== t.type && "candlestick" !== t.type && "boxPlot" !== t.type || i++, void 0 !== t.type && a++
                                })), a > 0 && (e = !0), {
                                    comboBarCount: i,
                                    comboCharts: e
                                }
                            }
                        }, {
                            key: "extendArrayProps",
                            value: function(t, e, i) {
                                return e.yaxis && (e = t.extendYAxis(e, i)), e.annotations && (e.annotations.yaxis && (e = t.extendYAxisAnnotations(e)), e.annotations.xaxis && (e = t.extendXAxisAnnotations(e)), e.annotations.points && (e = t.extendPointAnnotations(e))), e
                            }
                        }]), t
                    }(),
                    k = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.annoCtx = e
                        }
                        return c(t, [{
                            key: "setOrientations",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                    i = this.w;
                                if ("vertical" === t.label.orientation) {
                                    var a = null !== e ? e : 0,
                                        s = i.globals.dom.baseEl.querySelector(".apexcharts-xaxis-annotations .apexcharts-xaxis-annotation-label[rel='".concat(a, "']"));
                                    if (null !== s) {
                                        var n = s.getBoundingClientRect();
                                        s.setAttribute("x", parseFloat(s.getAttribute("x")) - n.height + 4), "top" === t.label.position ? s.setAttribute("y", parseFloat(s.getAttribute("y")) + n.width) : s.setAttribute("y", parseFloat(s.getAttribute("y")) - n.width);
                                        var r = this.annoCtx.graphics.rotateAroundCenter(s),
                                            o = r.x,
                                            l = r.y;
                                        s.setAttribute("transform", "rotate(-90 ".concat(o, " ").concat(l, ")"))
                                    }
                                }
                            }
                        }, {
                            key: "addBackgroundToAnno",
                            value: function(t, e) {
                                var i = this.w;
                                if (!t || void 0 === e.label.text || void 0 !== e.label.text && !String(e.label.text).trim()) return null;
                                var a = i.globals.dom.baseEl.querySelector(".apexcharts-grid").getBoundingClientRect(),
                                    s = t.getBoundingClientRect(),
                                    n = e.label.style.padding.left,
                                    r = e.label.style.padding.right,
                                    o = e.label.style.padding.top,
                                    l = e.label.style.padding.bottom;
                                "vertical" === e.label.orientation && (o = e.label.style.padding.left, l = e.label.style.padding.right, n = e.label.style.padding.top, r = e.label.style.padding.bottom);
                                var c = s.left - a.left - n,
                                    h = s.top - a.top - o,
                                    d = this.annoCtx.graphics.drawRect(c - i.globals.barPadForNumericAxis, h, s.width + n + r, s.height + o + l, e.label.borderRadius, e.label.style.background, 1, e.label.borderWidth, e.label.borderColor, 0);
                                return e.id && d.node.classList.add(e.id), d
                            }
                        }, {
                            key: "annotationsBackground",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = function(i, a, s) {
                                        var n = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(a, "']"));
                                        if (n) {
                                            var r = n.parentNode,
                                                o = t.addBackgroundToAnno(n, i);
                                            o && (r.insertBefore(o.node, n), i.label.mouseEnter && o.node.addEventListener("mouseenter", i.label.mouseEnter.bind(t, i)), i.label.mouseLeave && o.node.addEventListener("mouseleave", i.label.mouseLeave.bind(t, i)), i.label.click && o.node.addEventListener("click", i.label.click.bind(t, i)))
                                        }
                                    };
                                e.config.annotations.xaxis.map((function(t, e) {
                                    i(t, e, "xaxis")
                                })), e.config.annotations.yaxis.map((function(t, e) {
                                    i(t, e, "yaxis")
                                })), e.config.annotations.points.map((function(t, e) {
                                    i(t, e, "point")
                                }))
                            }
                        }, {
                            key: "getY1Y2",
                            value: function(t, e) {
                                var i, a = "y1" === t ? e.y : e.y2,
                                    s = this.w;
                                if (this.annoCtx.invertAxis) {
                                    var n = s.globals.labels.indexOf(a);
                                    s.config.xaxis.convertedCatToNumeric && (n = s.globals.categoryLabels.indexOf(a));
                                    var r = s.globals.dom.baseEl.querySelector(".apexcharts-yaxis-texts-g text:nth-child(" + (n + 1) + ")");
                                    r && (i = parseFloat(r.getAttribute("y")))
                                } else {
                                    var o;
                                    o = s.config.yaxis[e.yAxisIndex].logarithmic ? (a = new C(this.annoCtx.ctx).getLogVal(a, e.yAxisIndex)) / s.globals.yLogRatio[e.yAxisIndex] : (a - s.globals.minYArr[e.yAxisIndex]) / (s.globals.yRange[e.yAxisIndex] / s.globals.gridHeight), i = s.globals.gridHeight - o, !e.marker || void 0 !== e.y && null !== e.y || (i = 0), s.config.yaxis[e.yAxisIndex] && s.config.yaxis[e.yAxisIndex].reversed && (i = o)
                                }
                                return i
                            }
                        }, {
                            key: "getX1X2",
                            value: function(t, e) {
                                var i = this.w,
                                    a = this.annoCtx.invertAxis ? i.globals.minY : i.globals.minX,
                                    s = this.annoCtx.invertAxis ? i.globals.maxY : i.globals.maxX,
                                    n = this.annoCtx.invertAxis ? i.globals.yRange[0] : i.globals.xRange,
                                    r = (e.x - a) / (n / i.globals.gridWidth);
                                this.annoCtx.inversedReversedAxis && (r = (s - e.x) / (n / i.globals.gridWidth)), "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (r = this.getStringX(e.x));
                                var o = (e.x2 - a) / (n / i.globals.gridWidth);
                                return this.annoCtx.inversedReversedAxis && (o = (s - e.x2) / (n / i.globals.gridWidth)), "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric || this.annoCtx.invertAxis || i.globals.dataFormatXNumeric || (o = this.getStringX(e.x2)), void 0 !== e.x && null !== e.x || !e.marker || (r = i.globals.gridWidth), "x1" === t ? r : o
                            }
                        }, {
                            key: "getStringX",
                            value: function(t) {
                                var e = this.w,
                                    i = t;
                                e.config.xaxis.convertedCatToNumeric && e.globals.categoryLabels.length && (t = e.globals.categoryLabels.indexOf(t) + 1);
                                var a = e.globals.labels.indexOf(t),
                                    s = e.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g text:nth-child(" + (a + 1) + ")");
                                return s && (i = parseFloat(s.getAttribute("x"))), i
                            }
                        }]), t
                    }(),
                    A = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.annoCtx = e, this.invertAxis = this.annoCtx.invertAxis, this.helpers = new k(this.annoCtx)
                        }
                        return c(t, [{
                            key: "addXaxisAnnotation",
                            value: function(t, e, i) {
                                var a, s = this.w,
                                    n = this.helpers.getX1X2("x1", t),
                                    r = t.label.text,
                                    o = t.strokeDashArray;
                                if (b.isNumber(n)) {
                                    if (null === t.x2 || void 0 === t.x2) {
                                        var l = this.annoCtx.graphics.drawLine(n + t.offsetX, 0 + t.offsetY, n + t.offsetX, s.globals.gridHeight + t.offsetY, t.borderColor, o, t.borderWidth);
                                        e.appendChild(l.node), t.id && l.node.classList.add(t.id)
                                    } else {
                                        if ((a = this.helpers.getX1X2("x2", t)) < n) {
                                            var c = n;
                                            n = a, a = c
                                        }
                                        var h = this.annoCtx.graphics.drawRect(n + t.offsetX, 0 + t.offsetY, a - n, s.globals.gridHeight + t.offsetY, 0, t.fillColor, t.opacity, 1, t.borderColor, o);
                                        h.node.classList.add("apexcharts-annotation-rect"), h.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")), e.appendChild(h.node), t.id && h.node.classList.add(t.id)
                                    }
                                    var d = "top" === t.label.position ? 4 : s.globals.gridHeight,
                                        u = this.annoCtx.graphics.getTextRects(r, parseFloat(t.label.style.fontSize)),
                                        p = this.annoCtx.graphics.drawText({
                                            x: n + t.label.offsetX,
                                            y: d + t.label.offsetY - ("vertical" === t.label.orientation ? "top" === t.label.position ? u.width / 2 - 12 : -u.width / 2 : 0),
                                            text: r,
                                            textAnchor: t.label.textAnchor,
                                            fontSize: t.label.style.fontSize,
                                            fontFamily: t.label.style.fontFamily,
                                            fontWeight: t.label.style.fontWeight,
                                            foreColor: t.label.style.color,
                                            cssClass: "apexcharts-xaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                        });
                                    p.attr({
                                        rel: i
                                    }), e.appendChild(p.node), this.annoCtx.helpers.setOrientations(t, i)
                                }
                            }
                        }, {
                            key: "drawXAxisAnnotations",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = this.annoCtx.graphics.group({
                                        class: "apexcharts-xaxis-annotations"
                                    });
                                return e.config.annotations.xaxis.map((function(e, a) {
                                    t.addXaxisAnnotation(e, i.node, a)
                                })), i
                            }
                        }]), t
                    }(),
                    E = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.annoCtx = e, this.helpers = new k(this.annoCtx)
                        }
                        return c(t, [{
                            key: "addYaxisAnnotation",
                            value: function(t, e, i) {
                                var a, s = this.w,
                                    n = t.strokeDashArray,
                                    r = this.helpers.getY1Y2("y1", t),
                                    o = t.label.text;
                                if (null === t.y2 || void 0 === t.y2) {
                                    var l = this.annoCtx.graphics.drawLine(0 + t.offsetX, r + t.offsetY, this._getYAxisAnnotationWidth(t), r + t.offsetY, t.borderColor, n, t.borderWidth);
                                    e.appendChild(l.node), t.id && l.node.classList.add(t.id)
                                } else {
                                    if ((a = this.helpers.getY1Y2("y2", t)) > r) {
                                        var c = r;
                                        r = a, a = c
                                    }
                                    var h = this.annoCtx.graphics.drawRect(0 + t.offsetX, a + t.offsetY, this._getYAxisAnnotationWidth(t), r - a, 0, t.fillColor, t.opacity, 1, t.borderColor, n);
                                    h.node.classList.add("apexcharts-annotation-rect"), h.attr("clip-path", "url(#gridRectMask".concat(s.globals.cuid, ")")), e.appendChild(h.node), t.id && h.node.classList.add(t.id)
                                }
                                var d = "right" === t.label.position ? s.globals.gridWidth : 0,
                                    u = this.annoCtx.graphics.drawText({
                                        x: d + t.label.offsetX,
                                        y: (null != a ? a : r) + t.label.offsetY - 3,
                                        text: o,
                                        textAnchor: t.label.textAnchor,
                                        fontSize: t.label.style.fontSize,
                                        fontFamily: t.label.style.fontFamily,
                                        fontWeight: t.label.style.fontWeight,
                                        foreColor: t.label.style.color,
                                        cssClass: "apexcharts-yaxis-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                    });
                                u.attr({
                                    rel: i
                                }), e.appendChild(u.node)
                            }
                        }, {
                            key: "_getYAxisAnnotationWidth",
                            value: function(t) {
                                var e = this.w;
                                return e.globals.gridWidth, (t.width.indexOf("%") > -1 ? e.globals.gridWidth * parseInt(t.width, 10) / 100 : parseInt(t.width, 10)) + t.offsetX
                            }
                        }, {
                            key: "drawYAxisAnnotations",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = this.annoCtx.graphics.group({
                                        class: "apexcharts-yaxis-annotations"
                                    });
                                return e.config.annotations.yaxis.map((function(e, a) {
                                    t.addYaxisAnnotation(e, i.node, a)
                                })), i
                            }
                        }]), t
                    }(),
                    T = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.annoCtx = e, this.helpers = new k(this.annoCtx)
                        }
                        return c(t, [{
                            key: "addPointAnnotation",
                            value: function(t, e, i) {
                                this.w;
                                var a = this.helpers.getX1X2("x1", t),
                                    s = this.helpers.getY1Y2("y1", t);
                                if (b.isNumber(a)) {
                                    var n = {
                                            pSize: t.marker.size,
                                            pointStrokeWidth: t.marker.strokeWidth,
                                            pointFillColor: t.marker.fillColor,
                                            pointStrokeColor: t.marker.strokeColor,
                                            shape: t.marker.shape,
                                            pRadius: t.marker.radius,
                                            class: "apexcharts-point-annotation-marker ".concat(t.marker.cssClass, " ").concat(t.id ? t.id : "")
                                        },
                                        r = this.annoCtx.graphics.drawMarker(a + t.marker.offsetX, s + t.marker.offsetY, n);
                                    e.appendChild(r.node);
                                    var o = t.label.text ? t.label.text : "",
                                        l = this.annoCtx.graphics.drawText({
                                            x: a + t.label.offsetX,
                                            y: s + t.label.offsetY - t.marker.size - parseFloat(t.label.style.fontSize) / 1.6,
                                            text: o,
                                            textAnchor: t.label.textAnchor,
                                            fontSize: t.label.style.fontSize,
                                            fontFamily: t.label.style.fontFamily,
                                            fontWeight: t.label.style.fontWeight,
                                            foreColor: t.label.style.color,
                                            cssClass: "apexcharts-point-annotation-label ".concat(t.label.style.cssClass, " ").concat(t.id ? t.id : "")
                                        });
                                    if (l.attr({
                                            rel: i
                                        }), e.appendChild(l.node), t.customSVG.SVG) {
                                        var c = this.annoCtx.graphics.group({
                                            class: "apexcharts-point-annotations-custom-svg " + t.customSVG.cssClass
                                        });
                                        c.attr({
                                            transform: "translate(".concat(a + t.customSVG.offsetX, ", ").concat(s + t.customSVG.offsetY, ")")
                                        }), c.node.innerHTML = t.customSVG.SVG, e.appendChild(c.node)
                                    }
                                    if (t.image.path) {
                                        var h = t.image.width ? t.image.width : 20,
                                            d = t.image.height ? t.image.height : 20;
                                        r = this.annoCtx.addImage({
                                            x: a + t.image.offsetX - h / 2,
                                            y: s + t.image.offsetY - d / 2,
                                            width: h,
                                            height: d,
                                            path: t.image.path,
                                            appendTo: ".apexcharts-point-annotations"
                                        })
                                    }
                                    t.mouseEnter && r.node.addEventListener("mouseenter", t.mouseEnter.bind(this, t)), t.mouseLeave && r.node.addEventListener("mouseleave", t.mouseLeave.bind(this, t)), t.click && r.node.addEventListener("click", t.click.bind(this, t))
                                }
                            }
                        }, {
                            key: "drawPointAnnotations",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = this.annoCtx.graphics.group({
                                        class: "apexcharts-point-annotations"
                                    });
                                return e.config.annotations.points.map((function(e, a) {
                                    t.addPointAnnotation(e, i.node, a)
                                })), i
                            }
                        }]), t
                    }(),
                    P = {
                        name: "en",
                        options: {
                            months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                            shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                            days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                            shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                            toolbar: {
                                exportToSVG: "Download SVG",
                                exportToPNG: "Download PNG",
                                exportToCSV: "Download CSV",
                                menu: "Menu",
                                selection: "Selection",
                                selectionZoom: "Selection Zoom",
                                zoomIn: "Zoom In",
                                zoomOut: "Zoom Out",
                                pan: "Panning",
                                reset: "Reset Zoom"
                            }
                        }
                    },
                    M = function() {
                        function t() {
                            o(this, t), this.yAxis = {
                                show: !0,
                                showAlways: !1,
                                showForNullSeries: !0,
                                seriesName: void 0,
                                opposite: !1,
                                reversed: !1,
                                logarithmic: !1,
                                logBase: 10,
                                tickAmount: void 0,
                                forceNiceScale: !1,
                                max: void 0,
                                min: void 0,
                                floating: !1,
                                decimalsInFloat: void 0,
                                labels: {
                                    show: !0,
                                    minWidth: 0,
                                    maxWidth: 160,
                                    offsetX: 0,
                                    offsetY: 0,
                                    align: void 0,
                                    rotate: 0,
                                    padding: 20,
                                    style: {
                                        colors: [],
                                        fontSize: "11px",
                                        fontWeight: 400,
                                        fontFamily: void 0,
                                        cssClass: ""
                                    },
                                    formatter: void 0
                                },
                                axisBorder: {
                                    show: !1,
                                    color: "#e0e0e0",
                                    width: 1,
                                    offsetX: 0,
                                    offsetY: 0
                                },
                                axisTicks: {
                                    show: !1,
                                    color: "#e0e0e0",
                                    width: 6,
                                    offsetX: 0,
                                    offsetY: 0
                                },
                                title: {
                                    text: void 0,
                                    rotate: -90,
                                    offsetY: 0,
                                    offsetX: 0,
                                    style: {
                                        color: void 0,
                                        fontSize: "11px",
                                        fontWeight: 900,
                                        fontFamily: void 0,
                                        cssClass: ""
                                    }
                                },
                                tooltip: {
                                    enabled: !1,
                                    offsetX: 0
                                },
                                crosshairs: {
                                    show: !0,
                                    position: "front",
                                    stroke: {
                                        color: "#b6b6b6",
                                        width: 1,
                                        dashArray: 0
                                    }
                                }
                            }, this.pointAnnotation = {
                                id: void 0,
                                x: 0,
                                y: null,
                                yAxisIndex: 0,
                                seriesIndex: 0,
                                mouseEnter: void 0,
                                mouseLeave: void 0,
                                click: void 0,
                                marker: {
                                    size: 4,
                                    fillColor: "#fff",
                                    strokeWidth: 2,
                                    strokeColor: "#333",
                                    shape: "circle",
                                    offsetX: 0,
                                    offsetY: 0,
                                    radius: 2,
                                    cssClass: ""
                                },
                                label: {
                                    borderColor: "#c2c2c2",
                                    borderWidth: 1,
                                    borderRadius: 2,
                                    text: void 0,
                                    textAnchor: "middle",
                                    offsetX: 0,
                                    offsetY: 0,
                                    mouseEnter: void 0,
                                    mouseLeave: void 0,
                                    click: void 0,
                                    style: {
                                        background: "#fff",
                                        color: void 0,
                                        fontSize: "11px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        cssClass: "",
                                        padding: {
                                            left: 5,
                                            right: 5,
                                            top: 2,
                                            bottom: 2
                                        }
                                    }
                                },
                                customSVG: {
                                    SVG: void 0,
                                    cssClass: void 0,
                                    offsetX: 0,
                                    offsetY: 0
                                },
                                image: {
                                    path: void 0,
                                    width: 20,
                                    height: 20,
                                    offsetX: 0,
                                    offsetY: 0
                                }
                            }, this.yAxisAnnotation = {
                                id: void 0,
                                y: 0,
                                y2: null,
                                strokeDashArray: 1,
                                fillColor: "#c2c2c2",
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                opacity: .3,
                                offsetX: 0,
                                offsetY: 0,
                                width: "100%",
                                yAxisIndex: 0,
                                label: {
                                    borderColor: "#c2c2c2",
                                    borderWidth: 1,
                                    borderRadius: 2,
                                    text: void 0,
                                    textAnchor: "end",
                                    position: "right",
                                    offsetX: 0,
                                    offsetY: -3,
                                    mouseEnter: void 0,
                                    mouseLeave: void 0,
                                    click: void 0,
                                    style: {
                                        background: "#fff",
                                        color: void 0,
                                        fontSize: "11px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        cssClass: "",
                                        padding: {
                                            left: 5,
                                            right: 5,
                                            top: 2,
                                            bottom: 2
                                        }
                                    }
                                }
                            }, this.xAxisAnnotation = {
                                id: void 0,
                                x: 0,
                                x2: null,
                                strokeDashArray: 1,
                                fillColor: "#c2c2c2",
                                borderColor: "#c2c2c2",
                                borderWidth: 1,
                                opacity: .3,
                                offsetX: 0,
                                offsetY: 0,
                                label: {
                                    borderColor: "#c2c2c2",
                                    borderWidth: 1,
                                    borderRadius: 2,
                                    text: void 0,
                                    textAnchor: "middle",
                                    orientation: "vertical",
                                    position: "top",
                                    offsetX: 0,
                                    offsetY: 0,
                                    mouseEnter: void 0,
                                    mouseLeave: void 0,
                                    click: void 0,
                                    style: {
                                        background: "#fff",
                                        color: void 0,
                                        fontSize: "11px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        cssClass: "",
                                        padding: {
                                            left: 5,
                                            right: 5,
                                            top: 2,
                                            bottom: 2
                                        }
                                    }
                                }
                            }, this.text = {
                                x: 0,
                                y: 0,
                                text: "",
                                textAnchor: "start",
                                foreColor: void 0,
                                fontSize: "13px",
                                fontFamily: void 0,
                                fontWeight: 400,
                                appendTo: ".apexcharts-annotations",
                                backgroundColor: "transparent",
                                borderColor: "#c2c2c2",
                                borderRadius: 0,
                                borderWidth: 0,
                                paddingLeft: 4,
                                paddingRight: 4,
                                paddingTop: 2,
                                paddingBottom: 2
                            }
                        }
                        return c(t, [{
                            key: "init",
                            value: function() {
                                return {
                                    annotations: {
                                        position: "front",
                                        yaxis: [this.yAxisAnnotation],
                                        xaxis: [this.xAxisAnnotation],
                                        points: [this.pointAnnotation],
                                        texts: [],
                                        images: [],
                                        shapes: []
                                    },
                                    chart: {
                                        animations: {
                                            enabled: !0,
                                            easing: "easeinout",
                                            speed: 800,
                                            animateGradually: {
                                                delay: 150,
                                                enabled: !0
                                            },
                                            dynamicAnimation: {
                                                enabled: !0,
                                                speed: 350
                                            }
                                        },
                                        background: "transparent",
                                        locales: [P],
                                        defaultLocale: "en",
                                        dropShadow: {
                                            enabled: !1,
                                            enabledOnSeries: void 0,
                                            top: 2,
                                            left: 2,
                                            blur: 4,
                                            color: "#000",
                                            opacity: .35
                                        },
                                        events: {
                                            animationEnd: void 0,
                                            beforeMount: void 0,
                                            mounted: void 0,
                                            updated: void 0,
                                            click: void 0,
                                            mouseMove: void 0,
                                            mouseLeave: void 0,
                                            legendClick: void 0,
                                            markerClick: void 0,
                                            selection: void 0,
                                            dataPointSelection: void 0,
                                            dataPointMouseEnter: void 0,
                                            dataPointMouseLeave: void 0,
                                            beforeZoom: void 0,
                                            beforeResetZoom: void 0,
                                            zoomed: void 0,
                                            scrolled: void 0,
                                            brushScrolled: void 0
                                        },
                                        foreColor: "#373d3f",
                                        fontFamily: "Helvetica, Arial, sans-serif",
                                        height: "auto",
                                        parentHeightOffset: 15,
                                        redrawOnParentResize: !0,
                                        redrawOnWindowResize: !0,
                                        id: void 0,
                                        group: void 0,
                                        offsetX: 0,
                                        offsetY: 0,
                                        selection: {
                                            enabled: !1,
                                            type: "x",
                                            fill: {
                                                color: "#24292e",
                                                opacity: .1
                                            },
                                            stroke: {
                                                width: 1,
                                                color: "#24292e",
                                                opacity: .4,
                                                dashArray: 3
                                            },
                                            xaxis: {
                                                min: void 0,
                                                max: void 0
                                            },
                                            yaxis: {
                                                min: void 0,
                                                max: void 0
                                            }
                                        },
                                        sparkline: {
                                            enabled: !1
                                        },
                                        brush: {
                                            enabled: !1,
                                            autoScaleYaxis: !0,
                                            target: void 0
                                        },
                                        stacked: !1,
                                        stackType: "normal",
                                        toolbar: {
                                            show: !0,
                                            offsetX: 0,
                                            offsetY: 0,
                                            tools: {
                                                download: !0,
                                                selection: !0,
                                                zoom: !0,
                                                zoomin: !0,
                                                zoomout: !0,
                                                pan: !0,
                                                reset: !0,
                                                customIcons: []
                                            },
                                            export: {
                                                csv: {
                                                    filename: void 0,
                                                    columnDelimiter: ",",
                                                    headerCategory: "category",
                                                    headerValue: "value",
                                                    dateFormatter: function(t) {
                                                        return new Date(t).toDateString()
                                                    }
                                                },
                                                png: {
                                                    filename: void 0
                                                },
                                                svg: {
                                                    filename: void 0
                                                }
                                            },
                                            autoSelected: "zoom"
                                        },
                                        type: "line",
                                        width: "100%",
                                        zoom: {
                                            enabled: !0,
                                            type: "x",
                                            autoScaleYaxis: !1,
                                            zoomedArea: {
                                                fill: {
                                                    color: "#90CAF9",
                                                    opacity: .4
                                                },
                                                stroke: {
                                                    color: "#0D47A1",
                                                    opacity: .4,
                                                    width: 1
                                                }
                                            }
                                        }
                                    },
                                    plotOptions: {
                                        area: {
                                            fillTo: "origin"
                                        },
                                        bar: {
                                            horizontal: !1,
                                            columnWidth: "70%",
                                            barHeight: "70%",
                                            distributed: !1,
                                            borderRadius: 0,
                                            rangeBarOverlap: !0,
                                            rangeBarGroupRows: !1,
                                            colors: {
                                                ranges: [],
                                                backgroundBarColors: [],
                                                backgroundBarOpacity: 1,
                                                backgroundBarRadius: 0
                                            },
                                            dataLabels: {
                                                position: "top",
                                                maxItems: 100,
                                                hideOverflowingLabels: !0,
                                                orientation: "horizontal"
                                            }
                                        },
                                        bubble: {
                                            minBubbleRadius: void 0,
                                            maxBubbleRadius: void 0
                                        },
                                        candlestick: {
                                            colors: {
                                                upward: "#00B746",
                                                downward: "#EF403C"
                                            },
                                            wick: {
                                                useFillColor: !0
                                            }
                                        },
                                        boxPlot: {
                                            colors: {
                                                upper: "#00E396",
                                                lower: "#008FFB"
                                            }
                                        },
                                        heatmap: {
                                            radius: 2,
                                            enableShades: !0,
                                            shadeIntensity: .5,
                                            reverseNegativeShade: !1,
                                            distributed: !1,
                                            useFillColorAsStroke: !1,
                                            colorScale: {
                                                inverse: !1,
                                                ranges: [],
                                                min: void 0,
                                                max: void 0
                                            }
                                        },
                                        treemap: {
                                            enableShades: !0,
                                            shadeIntensity: .5,
                                            distributed: !1,
                                            reverseNegativeShade: !1,
                                            useFillColorAsStroke: !1,
                                            colorScale: {
                                                inverse: !1,
                                                ranges: [],
                                                min: void 0,
                                                max: void 0
                                            }
                                        },
                                        radialBar: {
                                            inverseOrder: !1,
                                            startAngle: 0,
                                            endAngle: 360,
                                            offsetX: 0,
                                            offsetY: 0,
                                            hollow: {
                                                margin: 5,
                                                size: "50%",
                                                background: "transparent",
                                                image: void 0,
                                                imageWidth: 150,
                                                imageHeight: 150,
                                                imageOffsetX: 0,
                                                imageOffsetY: 0,
                                                imageClipped: !0,
                                                position: "front",
                                                dropShadow: {
                                                    enabled: !1,
                                                    top: 0,
                                                    left: 0,
                                                    blur: 3,
                                                    color: "#000",
                                                    opacity: .5
                                                }
                                            },
                                            track: {
                                                show: !0,
                                                startAngle: void 0,
                                                endAngle: void 0,
                                                background: "#f2f2f2",
                                                strokeWidth: "97%",
                                                opacity: 1,
                                                margin: 5,
                                                dropShadow: {
                                                    enabled: !1,
                                                    top: 0,
                                                    left: 0,
                                                    blur: 3,
                                                    color: "#000",
                                                    opacity: .5
                                                }
                                            },
                                            dataLabels: {
                                                show: !0,
                                                name: {
                                                    show: !0,
                                                    fontSize: "16px",
                                                    fontFamily: void 0,
                                                    fontWeight: 600,
                                                    color: void 0,
                                                    offsetY: 0,
                                                    formatter: function(t) {
                                                        return t
                                                    }
                                                },
                                                value: {
                                                    show: !0,
                                                    fontSize: "14px",
                                                    fontFamily: void 0,
                                                    fontWeight: 400,
                                                    color: void 0,
                                                    offsetY: 16,
                                                    formatter: function(t) {
                                                        return t + "%"
                                                    }
                                                },
                                                total: {
                                                    show: !1,
                                                    label: "Total",
                                                    fontSize: "16px",
                                                    fontWeight: 600,
                                                    fontFamily: void 0,
                                                    color: void 0,
                                                    formatter: function(t) {
                                                        return t.globals.seriesTotals.reduce((function(t, e) {
                                                            return t + e
                                                        }), 0) / t.globals.series.length + "%"
                                                    }
                                                }
                                            }
                                        },
                                        pie: {
                                            customScale: 1,
                                            offsetX: 0,
                                            offsetY: 0,
                                            startAngle: 0,
                                            endAngle: 360,
                                            expandOnClick: !0,
                                            dataLabels: {
                                                offset: 0,
                                                minAngleToShowLabel: 10
                                            },
                                            donut: {
                                                size: "65%",
                                                background: "transparent",
                                                labels: {
                                                    show: !1,
                                                    name: {
                                                        show: !0,
                                                        fontSize: "16px",
                                                        fontFamily: void 0,
                                                        fontWeight: 600,
                                                        color: void 0,
                                                        offsetY: -10,
                                                        formatter: function(t) {
                                                            return t
                                                        }
                                                    },
                                                    value: {
                                                        show: !0,
                                                        fontSize: "20px",
                                                        fontFamily: void 0,
                                                        fontWeight: 400,
                                                        color: void 0,
                                                        offsetY: 10,
                                                        formatter: function(t) {
                                                            return t
                                                        }
                                                    },
                                                    total: {
                                                        show: !1,
                                                        showAlways: !1,
                                                        label: "Total",
                                                        fontSize: "16px",
                                                        fontWeight: 400,
                                                        fontFamily: void 0,
                                                        color: void 0,
                                                        formatter: function(t) {
                                                            return t.globals.seriesTotals.reduce((function(t, e) {
                                                                return t + e
                                                            }), 0)
                                                        }
                                                    }
                                                }
                                            }
                                        },
                                        polarArea: {
                                            rings: {
                                                strokeWidth: 1,
                                                strokeColor: "#e8e8e8"
                                            },
                                            spokes: {
                                                strokeWidth: 1,
                                                connectorColors: "#e8e8e8"
                                            }
                                        },
                                        radar: {
                                            size: void 0,
                                            offsetX: 0,
                                            offsetY: 0,
                                            polygons: {
                                                strokeWidth: 1,
                                                strokeColors: "#e8e8e8",
                                                connectorColors: "#e8e8e8",
                                                fill: {
                                                    colors: void 0
                                                }
                                            }
                                        }
                                    },
                                    colors: void 0,
                                    dataLabels: {
                                        enabled: !0,
                                        enabledOnSeries: void 0,
                                        formatter: function(t) {
                                            return null !== t ? t : ""
                                        },
                                        textAnchor: "middle",
                                        distributed: !1,
                                        offsetX: 0,
                                        offsetY: 0,
                                        style: {
                                            fontSize: "12px",
                                            fontFamily: void 0,
                                            fontWeight: 600,
                                            colors: void 0
                                        },
                                        background: {
                                            enabled: !0,
                                            foreColor: "#fff",
                                            borderRadius: 2,
                                            padding: 4,
                                            opacity: .9,
                                            borderWidth: 1,
                                            borderColor: "#fff",
                                            dropShadow: {
                                                enabled: !1,
                                                top: 1,
                                                left: 1,
                                                blur: 1,
                                                color: "#000",
                                                opacity: .45
                                            }
                                        },
                                        dropShadow: {
                                            enabled: !1,
                                            top: 1,
                                            left: 1,
                                            blur: 1,
                                            color: "#000",
                                            opacity: .45
                                        }
                                    },
                                    fill: {
                                        type: "solid",
                                        colors: void 0,
                                        opacity: .85,
                                        gradient: {
                                            shade: "dark",
                                            type: "horizontal",
                                            shadeIntensity: .5,
                                            gradientToColors: void 0,
                                            inverseColors: !0,
                                            opacityFrom: 1,
                                            opacityTo: 1,
                                            stops: [0, 50, 100],
                                            colorStops: []
                                        },
                                        image: {
                                            src: [],
                                            width: void 0,
                                            height: void 0
                                        },
                                        pattern: {
                                            style: "squares",
                                            width: 6,
                                            height: 6,
                                            strokeWidth: 2
                                        }
                                    },
                                    forecastDataPoints: {
                                        count: 0,
                                        fillOpacity: .5,
                                        strokeWidth: void 0,
                                        dashArray: 4
                                    },
                                    grid: {
                                        show: !0,
                                        borderColor: "#e0e0e0",
                                        strokeDashArray: 0,
                                        position: "back",
                                        xaxis: {
                                            lines: {
                                                show: !1
                                            }
                                        },
                                        yaxis: {
                                            lines: {
                                                show: !0
                                            }
                                        },
                                        row: {
                                            colors: void 0,
                                            opacity: .5
                                        },
                                        column: {
                                            colors: void 0,
                                            opacity: .5
                                        },
                                        padding: {
                                            top: 0,
                                            right: 10,
                                            bottom: 0,
                                            left: 12
                                        }
                                    },
                                    labels: [],
                                    legend: {
                                        show: !0,
                                        showForSingleSeries: !1,
                                        showForNullSeries: !0,
                                        showForZeroSeries: !0,
                                        floating: !1,
                                        position: "bottom",
                                        horizontalAlign: "center",
                                        inverseOrder: !1,
                                        fontSize: "12px",
                                        fontFamily: void 0,
                                        fontWeight: 400,
                                        width: void 0,
                                        height: void 0,
                                        formatter: void 0,
                                        tooltipHoverFormatter: void 0,
                                        offsetX: -20,
                                        offsetY: 4,
                                        customLegendItems: [],
                                        labels: {
                                            colors: void 0,
                                            useSeriesColors: !1
                                        },
                                        markers: {
                                            width: 12,
                                            height: 12,
                                            strokeWidth: 0,
                                            fillColors: void 0,
                                            strokeColor: "#fff",
                                            radius: 12,
                                            customHTML: void 0,
                                            offsetX: 0,
                                            offsetY: 0,
                                            onClick: void 0
                                        },
                                        itemMargin: {
                                            horizontal: 5,
                                            vertical: 2
                                        },
                                        onItemClick: {
                                            toggleDataSeries: !0
                                        },
                                        onItemHover: {
                                            highlightDataSeries: !0
                                        }
                                    },
                                    markers: {
                                        discrete: [],
                                        size: 0,
                                        colors: void 0,
                                        strokeColors: "#fff",
                                        strokeWidth: 2,
                                        strokeOpacity: .9,
                                        strokeDashArray: 0,
                                        fillOpacity: 1,
                                        shape: "circle",
                                        width: 8,
                                        height: 8,
                                        radius: 2,
                                        offsetX: 0,
                                        offsetY: 0,
                                        onClick: void 0,
                                        onDblClick: void 0,
                                        showNullDataPoints: !0,
                                        hover: {
                                            size: void 0,
                                            sizeOffset: 3
                                        }
                                    },
                                    noData: {
                                        text: void 0,
                                        align: "center",
                                        verticalAlign: "middle",
                                        offsetX: 0,
                                        offsetY: 0,
                                        style: {
                                            color: void 0,
                                            fontSize: "14px",
                                            fontFamily: void 0
                                        }
                                    },
                                    responsive: [],
                                    series: void 0,
                                    states: {
                                        normal: {
                                            filter: {
                                                type: "none",
                                                value: 0
                                            }
                                        },
                                        hover: {
                                            filter: {
                                                type: "lighten",
                                                value: .1
                                            }
                                        },
                                        active: {
                                            allowMultipleDataPointsSelection: !1,
                                            filter: {
                                                type: "darken",
                                                value: .5
                                            }
                                        }
                                    },
                                    title: {
                                        text: void 0,
                                        align: "left",
                                        margin: 5,
                                        offsetX: 0,
                                        offsetY: 0,
                                        floating: !1,
                                        style: {
                                            fontSize: "14px",
                                            fontWeight: 900,
                                            fontFamily: void 0,
                                            color: void 0
                                        }
                                    },
                                    subtitle: {
                                        text: void 0,
                                        align: "left",
                                        margin: 5,
                                        offsetX: 0,
                                        offsetY: 30,
                                        floating: !1,
                                        style: {
                                            fontSize: "12px",
                                            fontWeight: 400,
                                            fontFamily: void 0,
                                            color: void 0
                                        }
                                    },
                                    stroke: {
                                        show: !0,
                                        curve: "smooth",
                                        lineCap: "butt",
                                        width: 2,
                                        colors: void 0,
                                        dashArray: 0,
                                        fill: {
                                            type: "solid",
                                            colors: void 0,
                                            opacity: .85,
                                            gradient: {
                                                shade: "dark",
                                                type: "horizontal",
                                                shadeIntensity: .5,
                                                gradientToColors: void 0,
                                                inverseColors: !0,
                                                opacityFrom: 1,
                                                opacityTo: 1,
                                                stops: [0, 50, 100],
                                                colorStops: []
                                            }
                                        }
                                    },
                                    tooltip: {
                                        enabled: !0,
                                        enabledOnSeries: void 0,
                                        shared: !0,
                                        followCursor: !1,
                                        intersect: !1,
                                        inverseOrder: !1,
                                        custom: void 0,
                                        fillSeriesColor: !1,
                                        theme: "light",
                                        cssClass: "",
                                        style: {
                                            fontSize: "12px",
                                            fontFamily: void 0
                                        },
                                        onDatasetHover: {
                                            highlightDataSeries: !1
                                        },
                                        x: {
                                            show: !0,
                                            format: "dd MMM",
                                            formatter: void 0
                                        },
                                        y: {
                                            formatter: void 0,
                                            title: {
                                                formatter: function(t) {
                                                    return t ? t + ": " : ""
                                                }
                                            }
                                        },
                                        z: {
                                            formatter: void 0,
                                            title: "Size: "
                                        },
                                        marker: {
                                            show: !0,
                                            fillColors: void 0
                                        },
                                        items: {
                                            display: "flex"
                                        },
                                        fixed: {
                                            enabled: !1,
                                            position: "topRight",
                                            offsetX: 0,
                                            offsetY: 0
                                        }
                                    },
                                    xaxis: {
                                        type: "category",
                                        categories: [],
                                        convertedCatToNumeric: !1,
                                        offsetX: 0,
                                        offsetY: 0,
                                        overwriteCategories: void 0,
                                        labels: {
                                            show: !0,
                                            rotate: -45,
                                            rotateAlways: !1,
                                            hideOverlappingLabels: !0,
                                            trim: !1,
                                            minHeight: void 0,
                                            maxHeight: 120,
                                            showDuplicates: !0,
                                            style: {
                                                colors: [],
                                                fontSize: "12px",
                                                fontWeight: 400,
                                                fontFamily: void 0,
                                                cssClass: ""
                                            },
                                            offsetX: 0,
                                            offsetY: 0,
                                            format: void 0,
                                            formatter: void 0,
                                            datetimeUTC: !0,
                                            datetimeFormatter: {
                                                year: "yyyy",
                                                month: "MMM 'yy",
                                                day: "dd MMM",
                                                hour: "HH:mm",
                                                minute: "HH:mm:ss",
                                                second: "HH:mm:ss"
                                            }
                                        },
                                        group: {
                                            groups: [],
                                            style: {
                                                colors: [],
                                                fontSize: "12px",
                                                fontWeight: 400,
                                                fontFamily: void 0,
                                                cssClass: ""
                                            }
                                        },
                                        axisBorder: {
                                            show: !0,
                                            color: "#e0e0e0",
                                            width: "100%",
                                            height: 1,
                                            offsetX: 0,
                                            offsetY: 0
                                        },
                                        axisTicks: {
                                            show: !0,
                                            color: "#e0e0e0",
                                            height: 6,
                                            offsetX: 0,
                                            offsetY: 0
                                        },
                                        tickAmount: void 0,
                                        tickPlacement: "on",
                                        min: void 0,
                                        max: void 0,
                                        range: void 0,
                                        floating: !1,
                                        decimalsInFloat: void 0,
                                        position: "bottom",
                                        title: {
                                            text: void 0,
                                            offsetX: 0,
                                            offsetY: 0,
                                            style: {
                                                color: void 0,
                                                fontSize: "12px",
                                                fontWeight: 900,
                                                fontFamily: void 0,
                                                cssClass: ""
                                            }
                                        },
                                        crosshairs: {
                                            show: !0,
                                            width: 1,
                                            position: "back",
                                            opacity: .9,
                                            stroke: {
                                                color: "#b6b6b6",
                                                width: 1,
                                                dashArray: 3
                                            },
                                            fill: {
                                                type: "solid",
                                                color: "#B1B9C4",
                                                gradient: {
                                                    colorFrom: "#D8E3F0",
                                                    colorTo: "#BED1E6",
                                                    stops: [0, 100],
                                                    opacityFrom: .4,
                                                    opacityTo: .5
                                                }
                                            },
                                            dropShadow: {
                                                enabled: !1,
                                                left: 0,
                                                top: 0,
                                                blur: 1,
                                                opacity: .4
                                            }
                                        },
                                        tooltip: {
                                            enabled: !0,
                                            offsetY: 0,
                                            formatter: void 0,
                                            style: {
                                                fontSize: "12px",
                                                fontFamily: void 0
                                            }
                                        }
                                    },
                                    yaxis: this.yAxis,
                                    theme: {
                                        mode: "light",
                                        palette: "palette1",
                                        monochrome: {
                                            enabled: !1,
                                            color: "#008FFB",
                                            shadeTo: "light",
                                            shadeIntensity: .65
                                        }
                                    }
                                }
                            }
                        }]), t
                    }(),
                    L = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.graphics = new S(this.ctx), this.w.globals.isBarHorizontal && (this.invertAxis = !0), this.helpers = new k(this), this.xAxisAnnotations = new A(this), this.yAxisAnnotations = new E(this), this.pointsAnnotations = new T(this), this.w.globals.isBarHorizontal && this.w.config.yaxis[0].reversed && (this.inversedReversedAxis = !0), this.xDivision = this.w.globals.gridWidth / this.w.globals.dataPoints
                        }
                        return c(t, [{
                            key: "drawAxesAnnotations",
                            value: function() {
                                var t = this.w;
                                if (t.globals.axisCharts) {
                                    for (var e = this.yAxisAnnotations.drawYAxisAnnotations(), i = this.xAxisAnnotations.drawXAxisAnnotations(), a = this.pointsAnnotations.drawPointAnnotations(), s = t.config.chart.animations.enabled, n = [e, i, a], r = [i.node, e.node, a.node], o = 0; o < 3; o++) t.globals.dom.elGraphical.add(n[o]), !s || t.globals.resized || t.globals.dataChanged || "scatter" !== t.config.chart.type && "bubble" !== t.config.chart.type && t.globals.dataPoints > 1 && r[o].classList.add("apexcharts-element-hidden"), t.globals.delayedElements.push({
                                        el: r[o],
                                        index: 0
                                    });
                                    this.helpers.annotationsBackground()
                                }
                            }
                        }, {
                            key: "drawImageAnnos",
                            value: function() {
                                var t = this;
                                this.w.config.annotations.images.map((function(e, i) {
                                    t.addImage(e, i)
                                }))
                            }
                        }, {
                            key: "drawTextAnnos",
                            value: function() {
                                var t = this;
                                this.w.config.annotations.texts.map((function(e, i) {
                                    t.addText(e, i)
                                }))
                            }
                        }, {
                            key: "addXaxisAnnotation",
                            value: function(t, e, i) {
                                this.xAxisAnnotations.addXaxisAnnotation(t, e, i)
                            }
                        }, {
                            key: "addYaxisAnnotation",
                            value: function(t, e, i) {
                                this.yAxisAnnotations.addYaxisAnnotation(t, e, i)
                            }
                        }, {
                            key: "addPointAnnotation",
                            value: function(t, e, i) {
                                this.pointsAnnotations.addPointAnnotation(t, e, i)
                            }
                        }, {
                            key: "addText",
                            value: function(t, e) {
                                var i = t.x,
                                    a = t.y,
                                    s = t.text,
                                    n = t.textAnchor,
                                    r = t.foreColor,
                                    o = t.fontSize,
                                    l = t.fontFamily,
                                    c = t.fontWeight,
                                    h = t.cssClass,
                                    d = t.backgroundColor,
                                    u = t.borderWidth,
                                    p = t.strokeDashArray,
                                    g = t.borderRadius,
                                    f = t.borderColor,
                                    m = t.appendTo,
                                    x = void 0 === m ? ".apexcharts-annotations" : m,
                                    v = t.paddingLeft,
                                    b = void 0 === v ? 4 : v,
                                    y = t.paddingRight,
                                    w = void 0 === y ? 4 : y,
                                    S = t.paddingBottom,
                                    C = void 0 === S ? 2 : S,
                                    k = t.paddingTop,
                                    A = void 0 === k ? 2 : k,
                                    E = this.w,
                                    T = this.graphics.drawText({
                                        x: i,
                                        y: a,
                                        text: s,
                                        textAnchor: n || "start",
                                        fontSize: o || "12px",
                                        fontWeight: c || "regular",
                                        fontFamily: l || E.config.chart.fontFamily,
                                        foreColor: r || E.config.chart.foreColor,
                                        cssClass: h
                                    }),
                                    P = E.globals.dom.baseEl.querySelector(x);
                                P && P.appendChild(T.node);
                                var M = T.bbox();
                                if (s) {
                                    var L = this.graphics.drawRect(M.x - b, M.y - A, M.width + b + w, M.height + C + A, g, d || "transparent", 1, u, f, p);
                                    P.insertBefore(L.node, T.node)
                                }
                            }
                        }, {
                            key: "addImage",
                            value: function(t, e) {
                                var i = this.w,
                                    a = t.path,
                                    s = t.x,
                                    n = void 0 === s ? 0 : s,
                                    r = t.y,
                                    o = void 0 === r ? 0 : r,
                                    l = t.width,
                                    c = void 0 === l ? 20 : l,
                                    h = t.height,
                                    d = void 0 === h ? 20 : h,
                                    u = t.appendTo,
                                    p = void 0 === u ? ".apexcharts-annotations" : u,
                                    g = i.globals.dom.Paper.image(a);
                                g.size(c, d).move(n, o);
                                var f = i.globals.dom.baseEl.querySelector(p);
                                return f && f.appendChild(g.node), g
                            }
                        }, {
                            key: "addXaxisAnnotationExternal",
                            value: function(t, e, i) {
                                return this.addAnnotationExternal({
                                    params: t,
                                    pushToMemory: e,
                                    context: i,
                                    type: "xaxis",
                                    contextMethod: i.addXaxisAnnotation
                                }), i
                            }
                        }, {
                            key: "addYaxisAnnotationExternal",
                            value: function(t, e, i) {
                                return this.addAnnotationExternal({
                                    params: t,
                                    pushToMemory: e,
                                    context: i,
                                    type: "yaxis",
                                    contextMethod: i.addYaxisAnnotation
                                }), i
                            }
                        }, {
                            key: "addPointAnnotationExternal",
                            value: function(t, e, i) {
                                return void 0 === this.invertAxis && (this.invertAxis = i.w.globals.isBarHorizontal), this.addAnnotationExternal({
                                    params: t,
                                    pushToMemory: e,
                                    context: i,
                                    type: "point",
                                    contextMethod: i.addPointAnnotation
                                }), i
                            }
                        }, {
                            key: "addAnnotationExternal",
                            value: function(t) {
                                var e = t.params,
                                    i = t.pushToMemory,
                                    a = t.context,
                                    s = t.type,
                                    n = t.contextMethod,
                                    r = a,
                                    o = r.w,
                                    l = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations")),
                                    c = l.childNodes.length + 1,
                                    h = new M,
                                    d = Object.assign({}, "xaxis" === s ? h.xAxisAnnotation : "yaxis" === s ? h.yAxisAnnotation : h.pointAnnotation),
                                    u = b.extend(d, e);
                                switch (s) {
                                    case "xaxis":
                                        this.addXaxisAnnotation(u, l, c);
                                        break;
                                    case "yaxis":
                                        this.addYaxisAnnotation(u, l, c);
                                        break;
                                    case "point":
                                        this.addPointAnnotation(u, l, c)
                                }
                                var p = o.globals.dom.baseEl.querySelector(".apexcharts-".concat(s, "-annotations .apexcharts-").concat(s, "-annotation-label[rel='").concat(c, "']")),
                                    g = this.helpers.addBackgroundToAnno(p, u);
                                return g && l.insertBefore(g.node, p), i && o.globals.memory.methodsToExec.push({
                                    context: r,
                                    id: u.id ? u.id : b.randomId(),
                                    method: n,
                                    label: "addAnnotation",
                                    params: e
                                }), a
                            }
                        }, {
                            key: "clearAnnotations",
                            value: function(t) {
                                var e = t.w,
                                    i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-annotations, .apexcharts-xaxis-annotations, .apexcharts-point-annotations");
                                e.globals.memory.methodsToExec.map((function(t, i) {
                                    "addText" !== t.label && "addAnnotation" !== t.label || e.globals.memory.methodsToExec.splice(i, 1)
                                })), i = b.listToArray(i), Array.prototype.forEach.call(i, (function(t) {
                                    for (; t.firstChild;) t.removeChild(t.firstChild)
                                }))
                            }
                        }, {
                            key: "removeAnnotation",
                            value: function(t, e) {
                                var i = t.w,
                                    a = i.globals.dom.baseEl.querySelectorAll(".".concat(e));
                                a && (i.globals.memory.methodsToExec.map((function(t, a) {
                                    t.id === e && i.globals.memory.methodsToExec.splice(a, 1)
                                })), Array.prototype.forEach.call(a, (function(t) {
                                    t.parentElement.removeChild(t)
                                })))
                            }
                        }]), t
                    }(),
                    I = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.opts = null, this.seriesIndex = 0
                        }
                        return c(t, [{
                            key: "clippedImgArea",
                            value: function(t) {
                                var e = this.w,
                                    i = e.config,
                                    a = parseInt(e.globals.gridWidth, 10),
                                    s = parseInt(e.globals.gridHeight, 10),
                                    n = a > s ? a : s,
                                    r = t.image,
                                    o = 0,
                                    l = 0;
                                void 0 === t.width && void 0 === t.height ? void 0 !== i.fill.image.width && void 0 !== i.fill.image.height ? (o = i.fill.image.width + 1, l = i.fill.image.height) : (o = n + 1, l = n) : (o = t.width, l = t.height);
                                var c = document.createElementNS(e.globals.SVGNS, "pattern");
                                S.setAttrs(c, {
                                    id: t.patternID,
                                    patternUnits: t.patternUnits ? t.patternUnits : "userSpaceOnUse",
                                    width: o + "px",
                                    height: l + "px"
                                });
                                var h = document.createElementNS(e.globals.SVGNS, "image");
                                c.appendChild(h), h.setAttributeNS(window.SVG.xlink, "href", r), S.setAttrs(h, {
                                    x: 0,
                                    y: 0,
                                    preserveAspectRatio: "none",
                                    width: o + "px",
                                    height: l + "px"
                                }), h.style.opacity = t.opacity, e.globals.dom.elDefs.node.appendChild(c)
                            }
                        }, {
                            key: "getSeriesIndex",
                            value: function(t) {
                                var e = this.w;
                                return ("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || "heatmap" === e.config.chart.type || "treemap" === e.config.chart.type ? this.seriesIndex = t.seriesNumber : this.seriesIndex = t.seriesNumber % e.globals.series.length, this.seriesIndex
                            }
                        }, {
                            key: "fillPath",
                            value: function(t) {
                                var e = this.w;
                                this.opts = t;
                                var i, a, s, n = this.w.config;
                                this.seriesIndex = this.getSeriesIndex(t);
                                var r = this.getFillColors()[this.seriesIndex];
                                void 0 !== e.globals.seriesColors[this.seriesIndex] && (r = e.globals.seriesColors[this.seriesIndex]), "function" == typeof r && (r = r({
                                    seriesIndex: this.seriesIndex,
                                    dataPointIndex: t.dataPointIndex,
                                    value: t.value,
                                    w: e
                                }));
                                var o = this.getFillType(this.seriesIndex),
                                    l = Array.isArray(n.fill.opacity) ? n.fill.opacity[this.seriesIndex] : n.fill.opacity;
                                t.color && (r = t.color);
                                var c = r;
                                if (-1 === r.indexOf("rgb") ? r.length < 9 && (c = b.hexToRgba(r, l)) : r.indexOf("rgba") > -1 && (l = b.getOpacityFromRGBA(r)), t.opacity && (l = t.opacity), "pattern" === o && (a = this.handlePatternFill(a, r, l, c)), "gradient" === o && (s = this.handleGradientFill(r, l, this.seriesIndex)), "image" === o) {
                                    var h = n.fill.image.src,
                                        d = t.patternID ? t.patternID : "";
                                    this.clippedImgArea({
                                        opacity: l,
                                        image: Array.isArray(h) ? t.seriesNumber < h.length ? h[t.seriesNumber] : h[0] : h,
                                        width: t.width ? t.width : void 0,
                                        height: t.height ? t.height : void 0,
                                        patternUnits: t.patternUnits,
                                        patternID: "pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d)
                                    }), i = "url(#pattern".concat(e.globals.cuid).concat(t.seriesNumber + 1).concat(d, ")")
                                } else i = "gradient" === o ? s : "pattern" === o ? a : c;
                                return t.solid && (i = c), i
                            }
                        }, {
                            key: "getFillType",
                            value: function(t) {
                                var e = this.w;
                                return Array.isArray(e.config.fill.type) ? e.config.fill.type[t] : e.config.fill.type
                            }
                        }, {
                            key: "getFillColors",
                            value: function() {
                                var t = this.w,
                                    e = t.config,
                                    i = this.opts,
                                    a = [];
                                return t.globals.comboCharts ? "line" === t.config.series[this.seriesIndex].type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors) : "line" === e.chart.type ? Array.isArray(t.globals.stroke.colors) ? a = t.globals.stroke.colors : a.push(t.globals.stroke.colors) : Array.isArray(t.globals.fill.colors) ? a = t.globals.fill.colors : a.push(t.globals.fill.colors), void 0 !== i.fillColors && (a = [], Array.isArray(i.fillColors) ? a = i.fillColors.slice() : a.push(i.fillColors)), a
                            }
                        }, {
                            key: "handlePatternFill",
                            value: function(t, e, i, a) {
                                var s = this.w.config,
                                    n = this.opts,
                                    r = new S(this.ctx),
                                    o = void 0 === s.fill.pattern.strokeWidth ? Array.isArray(s.stroke.width) ? s.stroke.width[this.seriesIndex] : s.stroke.width : Array.isArray(s.fill.pattern.strokeWidth) ? s.fill.pattern.strokeWidth[this.seriesIndex] : s.fill.pattern.strokeWidth,
                                    l = e;
                                return Array.isArray(s.fill.pattern.style) ? void 0 !== s.fill.pattern.style[n.seriesNumber] ? r.drawPattern(s.fill.pattern.style[n.seriesNumber], s.fill.pattern.width, s.fill.pattern.height, l, o, i) : a : r.drawPattern(s.fill.pattern.style, s.fill.pattern.width, s.fill.pattern.height, l, o, i)
                            }
                        }, {
                            key: "handleGradientFill",
                            value: function(t, e, i) {
                                var a, s = this.w.config,
                                    n = this.opts,
                                    r = new S(this.ctx),
                                    o = new b,
                                    l = s.fill.gradient.type,
                                    c = t,
                                    h = void 0 === s.fill.gradient.opacityFrom ? e : Array.isArray(s.fill.gradient.opacityFrom) ? s.fill.gradient.opacityFrom[i] : s.fill.gradient.opacityFrom;
                                c.indexOf("rgba") > -1 && (h = b.getOpacityFromRGBA(c));
                                var d = void 0 === s.fill.gradient.opacityTo ? e : Array.isArray(s.fill.gradient.opacityTo) ? s.fill.gradient.opacityTo[i] : s.fill.gradient.opacityTo;
                                if (void 0 === s.fill.gradient.gradientToColors || 0 === s.fill.gradient.gradientToColors.length) a = "dark" === s.fill.gradient.shade ? o.shadeColor(-1 * parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? b.rgb2hex(t) : t) : o.shadeColor(parseFloat(s.fill.gradient.shadeIntensity), t.indexOf("rgb") > -1 ? b.rgb2hex(t) : t);
                                else if (s.fill.gradient.gradientToColors[n.seriesNumber]) {
                                    var u = s.fill.gradient.gradientToColors[n.seriesNumber];
                                    a = u, u.indexOf("rgba") > -1 && (d = b.getOpacityFromRGBA(u))
                                } else a = t;
                                if (s.fill.gradient.inverseColors) {
                                    var p = c;
                                    c = a, a = p
                                }
                                return c.indexOf("rgb") > -1 && (c = b.rgb2hex(c)), a.indexOf("rgb") > -1 && (a = b.rgb2hex(a)), r.drawGradient(l, c, a, h, d, n.size, s.fill.gradient.stops, s.fill.gradient.colorStops, i)
                            }
                        }]), t
                    }(),
                    _ = function() {
                        function t(e, i) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "setGlobalMarkerSize",
                            value: function() {
                                var t = this.w;
                                if (t.globals.markers.size = Array.isArray(t.config.markers.size) ? t.config.markers.size : [t.config.markers.size], t.globals.markers.size.length > 0) {
                                    if (t.globals.markers.size.length < t.globals.series.length + 1)
                                        for (var e = 0; e <= t.globals.series.length; e++) void 0 === t.globals.markers.size[e] && t.globals.markers.size.push(t.globals.markers.size[0])
                                } else t.globals.markers.size = t.config.series.map((function(e) {
                                    return t.config.markers.size
                                }))
                            }
                        }, {
                            key: "plotChartMarkers",
                            value: function(t, e, i, a) {
                                var s, n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
                                    r = this.w,
                                    o = e,
                                    l = t,
                                    c = null,
                                    h = new S(this.ctx),
                                    d = r.config.markers.discrete && r.config.markers.discrete.length;
                                if ((r.globals.markers.size[e] > 0 || n || d) && (c = h.group({
                                        class: n || d ? "" : "apexcharts-series-markers"
                                    })).attr("clip-path", "url(#gridRectMarkerMask".concat(r.globals.cuid, ")")), Array.isArray(l.x))
                                    for (var u = 0; u < l.x.length; u++) {
                                        var p = i;
                                        1 === i && 0 === u && (p = 0), 1 === i && 1 === u && (p = 1);
                                        var g = "apexcharts-marker";
                                        "line" !== r.config.chart.type && "area" !== r.config.chart.type || r.globals.comboCharts || r.config.tooltip.intersect || (g += " no-pointer-events");
                                        var f = Array.isArray(r.config.markers.size) ? r.globals.markers.size[e] > 0 : r.config.markers.size > 0;
                                        if (f || n || d) {
                                            b.isNumber(l.y[u]) ? g += " w".concat(b.randomId()) : g = "apexcharts-nullpoint";
                                            var m = this.getMarkerConfig({
                                                cssClass: g,
                                                seriesIndex: e,
                                                dataPointIndex: p
                                            });
                                            r.config.series[o].data[p] && (r.config.series[o].data[p].fillColor && (m.pointFillColor = r.config.series[o].data[p].fillColor), r.config.series[o].data[p].strokeColor && (m.pointStrokeColor = r.config.series[o].data[p].strokeColor)), a && (m.pSize = a), (s = h.drawMarker(l.x[u], l.y[u], m)).attr("rel", p), s.attr("j", p), s.attr("index", e), s.node.setAttribute("default-marker-size", m.pSize);
                                            var x = new w(this.ctx);
                                            x.setSelectionFilter(s, e, p), this.addEvents(s), c && c.add(s)
                                        } else void 0 === r.globals.pointsArray[e] && (r.globals.pointsArray[e] = []), r.globals.pointsArray[e].push([l.x[u], l.y[u]])
                                    }
                                return c
                            }
                        }, {
                            key: "getMarkerConfig",
                            value: function(t) {
                                var e = t.cssClass,
                                    i = t.seriesIndex,
                                    a = t.dataPointIndex,
                                    s = void 0 === a ? null : a,
                                    n = t.finishRadius,
                                    r = void 0 === n ? null : n,
                                    o = this.w,
                                    l = this.getMarkerStyle(i),
                                    c = o.globals.markers.size[i],
                                    h = o.config.markers;
                                return null !== s && h.discrete.length && h.discrete.map((function(t) {
                                    t.seriesIndex === i && t.dataPointIndex === s && (l.pointStrokeColor = t.strokeColor, l.pointFillColor = t.fillColor, c = t.size, l.pointShape = t.shape)
                                })), {
                                    pSize: null === r ? c : r,
                                    pRadius: h.radius,
                                    width: Array.isArray(h.width) ? h.width[i] : h.width,
                                    height: Array.isArray(h.height) ? h.height[i] : h.height,
                                    pointStrokeWidth: Array.isArray(h.strokeWidth) ? h.strokeWidth[i] : h.strokeWidth,
                                    pointStrokeColor: l.pointStrokeColor,
                                    pointFillColor: l.pointFillColor,
                                    shape: l.pointShape || (Array.isArray(h.shape) ? h.shape[i] : h.shape),
                                    class: e,
                                    pointStrokeOpacity: Array.isArray(h.strokeOpacity) ? h.strokeOpacity[i] : h.strokeOpacity,
                                    pointStrokeDashArray: Array.isArray(h.strokeDashArray) ? h.strokeDashArray[i] : h.strokeDashArray,
                                    pointFillOpacity: Array.isArray(h.fillOpacity) ? h.fillOpacity[i] : h.fillOpacity,
                                    seriesIndex: i
                                }
                            }
                        }, {
                            key: "addEvents",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx);
                                t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this.ctx, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this.ctx, t)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this.ctx, t)), t.node.addEventListener("click", e.config.markers.onClick), t.node.addEventListener("dblclick", e.config.markers.onDblClick), t.node.addEventListener("touchstart", i.pathMouseDown.bind(this.ctx, t), {
                                    passive: !0
                                })
                            }
                        }, {
                            key: "getMarkerStyle",
                            value: function(t) {
                                var e = this.w,
                                    i = e.globals.markers.colors,
                                    a = e.config.markers.strokeColor || e.config.markers.strokeColors;
                                return {
                                    pointStrokeColor: Array.isArray(a) ? a[t] : a,
                                    pointFillColor: Array.isArray(i) ? i[t] : i
                                }
                            }
                        }]), t
                    }(),
                    z = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = new S(this.ctx),
                                    n = i.realIndex,
                                    r = i.pointsPos,
                                    o = i.zRatio,
                                    l = i.elParent,
                                    c = s.group({
                                        class: "apexcharts-series-markers apexcharts-series-".concat(a.config.chart.type)
                                    });
                                if (c.attr("clip-path", "url(#gridRectMarkerMask".concat(a.globals.cuid, ")")), Array.isArray(r.x))
                                    for (var h = 0; h < r.x.length; h++) {
                                        var d = e + 1,
                                            u = !0;
                                        0 === e && 0 === h && (d = 0), 0 === e && 1 === h && (d = 1);
                                        var p = 0,
                                            g = a.globals.markers.size[n];
                                        if (o !== 1 / 0) {
                                            g = a.globals.seriesZ[n][d] / o;
                                            var f = a.config.plotOptions.bubble;
                                            f.minBubbleRadius && g < f.minBubbleRadius && (g = f.minBubbleRadius), f.maxBubbleRadius && g > f.maxBubbleRadius && (g = f.maxBubbleRadius)
                                        }
                                        a.config.chart.animations.enabled || (p = g);
                                        var m = r.x[h],
                                            x = r.y[h];
                                        if (p = p || 0, null !== x && void 0 !== a.globals.series[n][d] || (u = !1), u) {
                                            var v = this.drawPoint(m, x, p, g, n, d, e);
                                            c.add(v)
                                        }
                                        l.add(c)
                                    }
                            }
                        }, {
                            key: "drawPoint",
                            value: function(t, e, i, a, s, n, r) {
                                var o = this.w,
                                    l = s,
                                    c = new y(this.ctx),
                                    h = new w(this.ctx),
                                    d = new I(this.ctx),
                                    u = new _(this.ctx),
                                    p = new S(this.ctx),
                                    g = u.getMarkerConfig({
                                        cssClass: "apexcharts-marker",
                                        seriesIndex: l,
                                        dataPointIndex: n,
                                        finishRadius: "bubble" === o.config.chart.type || o.globals.comboCharts && o.config.series[s] && "bubble" === o.config.series[s].type ? a : null
                                    });
                                a = g.pSize;
                                var f, m = d.fillPath({
                                    seriesNumber: s,
                                    dataPointIndex: n,
                                    color: g.pointFillColor,
                                    patternUnits: "objectBoundingBox",
                                    value: o.globals.series[s][r]
                                });
                                if ("circle" === g.shape ? f = p.drawCircle(i) : "square" !== g.shape && "rect" !== g.shape || (f = p.drawRect(0, 0, g.width - g.pointStrokeWidth / 2, g.height - g.pointStrokeWidth / 2, g.pRadius)), o.config.series[l].data[n] && o.config.series[l].data[n].fillColor && (m = o.config.series[l].data[n].fillColor), f.attr({
                                        x: t - g.width / 2 - g.pointStrokeWidth / 2,
                                        y: e - g.height / 2 - g.pointStrokeWidth / 2,
                                        cx: t,
                                        cy: e,
                                        fill: m,
                                        "fill-opacity": g.pointFillOpacity,
                                        stroke: g.pointStrokeColor,
                                        r: a,
                                        "stroke-width": g.pointStrokeWidth,
                                        "stroke-dasharray": g.pointStrokeDashArray,
                                        "stroke-opacity": g.pointStrokeOpacity
                                    }), o.config.chart.dropShadow.enabled) {
                                    var x = o.config.chart.dropShadow;
                                    h.dropShadow(f, x, s)
                                }
                                if (!this.initialAnim || o.globals.dataChanged || o.globals.resized) o.globals.animationEnded = !0;
                                else {
                                    var v = o.config.chart.animations.speed;
                                    c.animateMarker(f, 0, "circle" === g.shape ? a : {
                                        width: g.width,
                                        height: g.height
                                    }, v, o.globals.easing, (function() {
                                        window.setTimeout((function() {
                                            c.animationCompleted(f)
                                        }), 100)
                                    }))
                                }
                                if (o.globals.dataChanged && "circle" === g.shape)
                                    if (this.dynamicAnim) {
                                        var b, C, k, A, E = o.config.chart.animations.dynamicAnimation.speed;
                                        null != (A = o.globals.previousPaths[s] && o.globals.previousPaths[s][r]) && (b = A.x, C = A.y, k = void 0 !== A.r ? A.r : a);
                                        for (var T = 0; T < o.globals.collapsedSeries.length; T++) o.globals.collapsedSeries[T].index === s && (E = 1, a = 0);
                                        0 === t && 0 === e && (a = 0), c.animateCircle(f, {
                                            cx: b,
                                            cy: C,
                                            r: k
                                        }, {
                                            cx: t,
                                            cy: e,
                                            r: a
                                        }, E, o.globals.easing)
                                    } else f.attr({
                                        r: a
                                    });
                                return f.attr({
                                    rel: n,
                                    j: n,
                                    index: s,
                                    "default-marker-size": a
                                }), h.setSelectionFilter(f, s, n), u.addEvents(f), f.node.classList.add("apexcharts-marker"), f
                            }
                        }, {
                            key: "centerTextInBubble",
                            value: function(t) {
                                var e = this.w;
                                return {
                                    y: t += parseInt(e.config.dataLabels.style.fontSize, 10) / 4
                                }
                            }
                        }]), t
                    }(),
                    D = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "dataLabelsCorrection",
                            value: function(t, e, i, a, s, n, r) {
                                var o = this.w,
                                    l = !1,
                                    c = new S(this.ctx).getTextRects(i, r),
                                    h = c.width,
                                    d = c.height;
                                e < 0 && (e = 0), e > o.globals.gridHeight + d && (e = o.globals.gridHeight + d / 2), void 0 === o.globals.dataLabelsRects[a] && (o.globals.dataLabelsRects[a] = []), o.globals.dataLabelsRects[a].push({
                                    x: t,
                                    y: e,
                                    width: h,
                                    height: d
                                });
                                var u = o.globals.dataLabelsRects[a].length - 2,
                                    p = void 0 !== o.globals.lastDrawnDataLabelsIndexes[a] ? o.globals.lastDrawnDataLabelsIndexes[a][o.globals.lastDrawnDataLabelsIndexes[a].length - 1] : 0;
                                if (void 0 !== o.globals.dataLabelsRects[a][u]) {
                                    var g = o.globals.dataLabelsRects[a][p];
                                    (t > g.x + g.width + 2 || e > g.y + g.height + 2 || t + h < g.x) && (l = !0)
                                }
                                return (0 === s || n) && (l = !0), {
                                    x: t,
                                    y: e,
                                    textRects: c,
                                    drawnextLabel: l
                                }
                            }
                        }, {
                            key: "drawDataLabel",
                            value: function(t, e, i) {
                                var a = this,
                                    s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : 2,
                                    n = this.w,
                                    r = new S(this.ctx),
                                    o = n.config.dataLabels,
                                    l = 0,
                                    c = 0,
                                    h = i,
                                    d = null;
                                if (!o.enabled || !Array.isArray(t.x)) return d;
                                d = r.group({
                                    class: "apexcharts-data-labels"
                                });
                                for (var u = 0; u < t.x.length; u++)
                                    if (l = t.x[u] + o.offsetX, c = t.y[u] + o.offsetY + s, !isNaN(l)) {
                                        1 === i && 0 === u && (h = 0), 1 === i && 1 === u && (h = 1);
                                        var p = n.globals.series[e][h],
                                            g = "",
                                            f = function(t) {
                                                return n.config.dataLabels.formatter(t, {
                                                    ctx: a.ctx,
                                                    seriesIndex: e,
                                                    dataPointIndex: h,
                                                    w: n
                                                })
                                            };
                                        if ("bubble" === n.config.chart.type) {
                                            g = f(p = n.globals.seriesZ[e][h]), c = t.y[u];
                                            var m = new z(this.ctx),
                                                x = m.centerTextInBubble(c, e, h);
                                            c = x.y
                                        } else void 0 !== p && (g = f(p));
                                        this.plotDataLabelsText({
                                            x: l,
                                            y: c,
                                            text: g,
                                            i: e,
                                            j: h,
                                            parent: d,
                                            offsetCorrection: !0,
                                            dataLabelsConfig: n.config.dataLabels
                                        })
                                    }
                                return d
                            }
                        }, {
                            key: "plotDataLabelsText",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = t.x,
                                    s = t.y,
                                    n = t.i,
                                    r = t.j,
                                    o = t.text,
                                    l = t.textAnchor,
                                    c = t.fontSize,
                                    h = t.parent,
                                    d = t.dataLabelsConfig,
                                    u = t.color,
                                    p = t.alwaysDrawDataLabel,
                                    g = t.offsetCorrection;
                                if (!(Array.isArray(e.config.dataLabels.enabledOnSeries) && e.config.dataLabels.enabledOnSeries.indexOf(n) < 0)) {
                                    var f = {
                                        x: a,
                                        y: s,
                                        drawnextLabel: !0,
                                        textRects: null
                                    };
                                    g && (f = this.dataLabelsCorrection(a, s, o, n, r, p, parseInt(d.style.fontSize, 10))), e.globals.zoomed || (a = f.x, s = f.y), f.textRects && (a < -10 - f.textRects.width || a > e.globals.gridWidth + f.textRects.width + 10) && (o = "");
                                    var m = e.globals.dataLabels.style.colors[n];
                                    (("bar" === e.config.chart.type || "rangeBar" === e.config.chart.type) && e.config.plotOptions.bar.distributed || e.config.dataLabels.distributed) && (m = e.globals.dataLabels.style.colors[r]), "function" == typeof m && (m = m({
                                        series: e.globals.series,
                                        seriesIndex: n,
                                        dataPointIndex: r,
                                        w: e
                                    })), u && (m = u);
                                    var x = d.offsetX,
                                        v = d.offsetY;
                                    if ("bar" !== e.config.chart.type && "rangeBar" !== e.config.chart.type || (x = 0, v = 0), f.drawnextLabel) {
                                        var b = i.drawText({
                                            width: 100,
                                            height: parseInt(d.style.fontSize, 10),
                                            x: a + x,
                                            y: s + v,
                                            foreColor: m,
                                            textAnchor: l || d.textAnchor,
                                            text: o,
                                            fontSize: c || d.style.fontSize,
                                            fontFamily: d.style.fontFamily,
                                            fontWeight: d.style.fontWeight || "normal"
                                        });
                                        if (b.attr({
                                                class: "apexcharts-datalabel",
                                                cx: a,
                                                cy: s
                                            }), d.dropShadow.enabled) {
                                            var y = d.dropShadow;
                                            new w(this.ctx).dropShadow(b, y)
                                        }
                                        h.add(b), void 0 === e.globals.lastDrawnDataLabelsIndexes[n] && (e.globals.lastDrawnDataLabelsIndexes[n] = []), e.globals.lastDrawnDataLabelsIndexes[n].push(r)
                                    }
                                }
                            }
                        }, {
                            key: "addBackgroundToDataLabel",
                            value: function(t, e) {
                                var i = this.w,
                                    a = i.config.dataLabels.background,
                                    s = a.padding,
                                    n = a.padding / 2,
                                    r = e.width,
                                    o = e.height,
                                    l = new S(this.ctx).drawRect(e.x - s, e.y - n / 2, r + 2 * s, o + n, a.borderRadius, "transparent" === i.config.chart.background ? "#fff" : i.config.chart.background, a.opacity, a.borderWidth, a.borderColor);
                                return a.dropShadow.enabled && new w(this.ctx).dropShadow(l, a.dropShadow), l
                            }
                        }, {
                            key: "dataLabelsBackground",
                            value: function() {
                                var t = this.w;
                                if ("bubble" !== t.config.chart.type)
                                    for (var e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels text"), i = 0; i < e.length; i++) {
                                        var a = e[i],
                                            s = a.getBBox(),
                                            n = null;
                                        if (s.width && s.height && (n = this.addBackgroundToDataLabel(a, s)), n) {
                                            a.parentNode.insertBefore(n.node, a);
                                            var r = a.getAttribute("fill");
                                            !t.config.chart.animations.enabled || t.globals.resized || t.globals.dataChanged ? n.attr({
                                                fill: r
                                            }) : n.animate().attr({
                                                fill: r
                                            }), a.setAttribute("fill", t.config.dataLabels.background.foreColor)
                                        }
                                    }
                            }
                        }, {
                            key: "bringForward",
                            value: function() {
                                for (var t = this.w, e = t.globals.dom.baseEl.querySelectorAll(".apexcharts-datalabels"), i = t.globals.dom.baseEl.querySelector(".apexcharts-plot-series:last-child"), a = 0; a < e.length; a++) i && i.insertBefore(e[a], i.nextSibling)
                            }
                        }]), t
                    }(),
                    X = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.barCtx = e
                        }
                        return c(t, [{
                            key: "handleBarDataLabels",
                            value: function(t) {
                                var e = t.x,
                                    i = t.y,
                                    a = t.y1,
                                    s = t.y2,
                                    n = t.i,
                                    r = t.j,
                                    o = t.realIndex,
                                    l = t.series,
                                    c = t.barHeight,
                                    h = t.barWidth,
                                    d = t.barYPosition,
                                    u = t.visibleSeries,
                                    p = t.renderedPath,
                                    g = this.w,
                                    f = new S(this.barCtx.ctx),
                                    m = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[o] : this.barCtx.strokeWidth,
                                    x = e + parseFloat(h * u),
                                    v = i + parseFloat(c * u);
                                g.globals.isXNumeric && !g.globals.isBarHorizontal && (x = e + parseFloat(h * (u + 1)), v = i + parseFloat(c * (u + 1)) - m);
                                var b, y = e,
                                    w = i,
                                    C = g.config.dataLabels,
                                    k = this.barCtx.barOptions.dataLabels;
                                void 0 !== d && this.barCtx.isRangeBar && (v = d, w = d);
                                var A = C.offsetX,
                                    E = C.offsetY,
                                    T = {
                                        width: 0,
                                        height: 0
                                    };
                                if (g.config.dataLabels.enabled) {
                                    var P = this.barCtx.series[n][r];
                                    T = f.getTextRects(g.globals.yLabelFormatters[0](P), parseFloat(C.style.fontSize))
                                }
                                var M = {
                                    x: e,
                                    y: i,
                                    i: n,
                                    j: r,
                                    renderedPath: p,
                                    bcx: x,
                                    bcy: v,
                                    barHeight: c,
                                    barWidth: h,
                                    textRects: T,
                                    strokeWidth: m,
                                    dataLabelsX: y,
                                    dataLabelsY: w,
                                    barDataLabelsConfig: k,
                                    offX: A,
                                    offY: E
                                };
                                return b = this.barCtx.isHorizontal ? this.calculateBarsDataLabelsPosition(M) : this.calculateColumnsDataLabelsPosition(M), p.attr({
                                    cy: b.bcy,
                                    cx: b.bcx,
                                    j: r,
                                    val: l[n][r],
                                    barHeight: c,
                                    barWidth: h
                                }), this.drawCalculatedDataLabels({
                                    x: b.dataLabelsX,
                                    y: b.dataLabelsY,
                                    val: this.barCtx.isRangeBar ? [a, s] : l[n][r],
                                    i: o,
                                    j: r,
                                    barWidth: h,
                                    barHeight: c,
                                    textRects: T,
                                    dataLabelsConfig: C
                                })
                            }
                        }, {
                            key: "calculateColumnsDataLabelsPosition",
                            value: function(t) {
                                var e, i = this.w,
                                    a = t.i,
                                    s = t.j,
                                    n = t.y,
                                    r = t.bcx,
                                    o = t.barWidth,
                                    l = t.barHeight,
                                    c = t.textRects,
                                    h = t.dataLabelsY,
                                    d = t.barDataLabelsConfig,
                                    u = t.strokeWidth,
                                    p = t.offX,
                                    g = t.offY;
                                l = Math.abs(l);
                                var f = "vertical" === i.config.plotOptions.bar.dataLabels.orientation;
                                r -= u / 2;
                                var m = i.globals.gridWidth / i.globals.dataPoints;
                                e = i.globals.isXNumeric ? r - o / 2 + p : r - m + o / 2 + p, f && (e = e + c.height / 2 - u / 2 - 2);
                                var x = this.barCtx.series[a][s] < 0,
                                    v = n;
                                switch (this.barCtx.isReversed && (v = n - l + (x ? 2 * l : 0), n -= l), d.position) {
                                    case "center":
                                        h = f ? x ? v + l / 2 + g : v + l / 2 - g : x ? v - l / 2 + c.height / 2 + g : v + l / 2 + c.height / 2 - g;
                                        break;
                                    case "bottom":
                                        h = f ? x ? v + l + g : v + l - g : x ? v - l + c.height + u + g : v + l - c.height / 2 + u - g;
                                        break;
                                    case "top":
                                        h = f ? x ? v + g : v - g : x ? v - c.height / 2 - g : v + c.height + g
                                }
                                return i.config.chart.stacked || (h < 0 ? h = 0 + u : h + c.height / 3 > i.globals.gridHeight && (h = i.globals.gridHeight - u)), {
                                    bcx: r,
                                    bcy: n,
                                    dataLabelsX: e,
                                    dataLabelsY: h
                                }
                            }
                        }, {
                            key: "calculateBarsDataLabelsPosition",
                            value: function(t) {
                                var e = this.w,
                                    i = t.x,
                                    a = t.i,
                                    s = t.j,
                                    n = t.bcy,
                                    r = t.barHeight,
                                    o = t.barWidth,
                                    l = t.textRects,
                                    c = t.dataLabelsX,
                                    h = t.strokeWidth,
                                    d = t.barDataLabelsConfig,
                                    u = t.offX,
                                    p = t.offY,
                                    g = e.globals.gridHeight / e.globals.dataPoints;
                                o = Math.abs(o);
                                var f = n - (this.barCtx.isRangeBar ? 0 : g) + r / 2 + l.height / 2 + p - 3,
                                    m = this.barCtx.series[a][s] < 0,
                                    x = i;
                                switch (this.barCtx.isReversed && (x = i + o - (m ? 2 * o : 0), i = e.globals.gridWidth - o), d.position) {
                                    case "center":
                                        c = m ? x + o / 2 - u : Math.max(l.width / 2, x - o / 2) + u;
                                        break;
                                    case "bottom":
                                        c = m ? x + o - h - Math.round(l.width / 2) - u : x - o + h + Math.round(l.width / 2) + u;
                                        break;
                                    case "top":
                                        c = m ? x - h + Math.round(l.width / 2) - u : x - h - Math.round(l.width / 2) + u
                                }
                                return e.config.chart.stacked || (c < 0 ? c = c + l.width + h : c + l.width / 2 > e.globals.gridWidth && (c = e.globals.gridWidth - l.width - h)), {
                                    bcx: i,
                                    bcy: n,
                                    dataLabelsX: c,
                                    dataLabelsY: f
                                }
                            }
                        }, {
                            key: "drawCalculatedDataLabels",
                            value: function(t) {
                                var e = t.x,
                                    i = t.y,
                                    a = t.val,
                                    s = t.i,
                                    r = t.j,
                                    o = t.textRects,
                                    l = t.barHeight,
                                    c = t.barWidth,
                                    h = t.dataLabelsConfig,
                                    d = this.w,
                                    u = "rotate(0)";
                                "vertical" === d.config.plotOptions.bar.dataLabels.orientation && (u = "rotate(-90, ".concat(e, ", ").concat(i, ")"));
                                var p = new D(this.barCtx.ctx),
                                    g = new S(this.barCtx.ctx),
                                    f = h.formatter,
                                    m = null,
                                    x = d.globals.collapsedSeriesIndices.indexOf(s) > -1;
                                if (h.enabled && !x) {
                                    m = g.group({
                                        class: "apexcharts-data-labels",
                                        transform: u
                                    });
                                    var v = "";
                                    void 0 !== a && (v = f(a, {
                                        seriesIndex: s,
                                        dataPointIndex: r,
                                        w: d
                                    }));
                                    var b = d.globals.series[s][r] < 0,
                                        y = d.config.plotOptions.bar.dataLabels.position;
                                    "vertical" === d.config.plotOptions.bar.dataLabels.orientation && ("top" === y && (h.textAnchor = b ? "end" : "start"), "center" === y && (h.textAnchor = "middle"), "bottom" === y && (h.textAnchor = b ? "end" : "start")), this.barCtx.isRangeBar && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && c < g.getTextRects(v, parseFloat(h.style.fontSize)).width && (v = ""), d.config.chart.stacked && this.barCtx.barOptions.dataLabels.hideOverflowingLabels && (this.barCtx.isHorizontal ? o.width / 1.6 > Math.abs(c) && (v = "") : o.height / 1.6 > Math.abs(l) && (v = ""));
                                    var w = n({}, h);
                                    this.barCtx.isHorizontal && a < 0 && ("start" === h.textAnchor ? w.textAnchor = "end" : "end" === h.textAnchor && (w.textAnchor = "start")), p.plotDataLabelsText({
                                        x: e,
                                        y: i,
                                        text: v,
                                        i: s,
                                        j: r,
                                        parent: m,
                                        dataLabelsConfig: w,
                                        alwaysDrawDataLabel: !0,
                                        offsetCorrection: !0
                                    })
                                }
                                return m
                            }
                        }]), t
                    }(),
                    O = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.legendInactiveClass = "legend-mouseover-inactive"
                        }
                        return c(t, [{
                            key: "getAllSeriesEls",
                            value: function() {
                                return this.w.globals.dom.baseEl.getElementsByClassName("apexcharts-series")
                            }
                        }, {
                            key: "getSeriesByName",
                            value: function(t) {
                                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner .apexcharts-series[seriesName='".concat(b.escapeString(t), "']"))
                            }
                        }, {
                            key: "isSeriesHidden",
                            value: function(t) {
                                var e = this.getSeriesByName(t),
                                    i = parseInt(e.getAttribute("data:realIndex"), 10);
                                return {
                                    isHidden: e.classList.contains("apexcharts-series-collapsed"),
                                    realIndex: i
                                }
                            }
                        }, {
                            key: "addCollapsedClassToSeries",
                            value: function(t, e) {
                                var i = this.w;

                                function a(i) {
                                    for (var a = 0; a < i.length; a++) i[a].index === e && t.node.classList.add("apexcharts-series-collapsed")
                                }
                                a(i.globals.collapsedSeries), a(i.globals.ancillaryCollapsedSeries)
                            }
                        }, {
                            key: "toggleSeries",
                            value: function(t) {
                                var e = this.isSeriesHidden(t);
                                return this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, e.isHidden), e.isHidden
                            }
                        }, {
                            key: "showSeries",
                            value: function(t) {
                                var e = this.isSeriesHidden(t);
                                e.isHidden && this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !0)
                            }
                        }, {
                            key: "hideSeries",
                            value: function(t) {
                                var e = this.isSeriesHidden(t);
                                e.isHidden || this.ctx.legend.legendHelpers.toggleDataSeries(e.realIndex, !1)
                            }
                        }, {
                            key: "resetSeries",
                            value: function() {
                                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                    a = this.w,
                                    s = b.clone(a.globals.initialSeries);
                                a.globals.previousPaths = [], i ? (a.globals.collapsedSeries = [], a.globals.ancillaryCollapsedSeries = [], a.globals.collapsedSeriesIndices = [], a.globals.ancillaryCollapsedSeriesIndices = []) : s = this.emptyCollapsedSeries(s), a.config.series = s, t && (e && (a.globals.zoomed = !1, this.ctx.updateHelpers.revertDefaultAxisMinMax()), this.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled))
                            }
                        }, {
                            key: "emptyCollapsedSeries",
                            value: function(t) {
                                for (var e = this.w, i = 0; i < t.length; i++) e.globals.collapsedSeriesIndices.indexOf(i) > -1 && (t[i].data = []);
                                return t
                            }
                        }, {
                            key: "toggleSeriesOnHover",
                            value: function(t, e) {
                                var i = this.w;
                                e || (e = t.target);
                                var a = i.globals.dom.baseEl.querySelectorAll(".apexcharts-series, .apexcharts-datalabels");
                                if ("mousemove" === t.type) {
                                    var s = parseInt(e.getAttribute("rel"), 10) - 1,
                                        n = null,
                                        r = null;
                                    i.globals.axisCharts || "radialBar" === i.config.chart.type ? i.globals.axisCharts ? (n = i.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(s, "']")), r = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels[data\\:realIndex='".concat(s, "']"))) : n = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "']")) : n = i.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(s + 1, "'] path"));
                                    for (var o = 0; o < a.length; o++) a[o].classList.add(this.legendInactiveClass);
                                    null !== n && (i.globals.axisCharts || n.parentNode.classList.remove(this.legendInactiveClass), n.classList.remove(this.legendInactiveClass), null !== r && r.classList.remove(this.legendInactiveClass))
                                } else if ("mouseout" === t.type)
                                    for (var l = 0; l < a.length; l++) a[l].classList.remove(this.legendInactiveClass)
                            }
                        }, {
                            key: "highlightRangeInSeries",
                            value: function(t, e) {
                                var i = this,
                                    a = this.w,
                                    s = a.globals.dom.baseEl.getElementsByClassName("apexcharts-heatmap-rect"),
                                    n = function(t) {
                                        for (var e = 0; e < s.length; e++) s[e].classList[t](i.legendInactiveClass)
                                    };
                                if ("mousemove" === t.type) {
                                    var r = parseInt(e.getAttribute("rel"), 10) - 1;
                                    n("add"),
                                        function(t) {
                                            for (var e = 0; e < s.length; e++) {
                                                var a = parseInt(s[e].getAttribute("val"), 10);
                                                a >= t.from && a <= t.to && s[e].classList.remove(i.legendInactiveClass)
                                            }
                                        }(a.config.plotOptions.heatmap.colorScale.ranges[r])
                                } else "mouseout" === t.type && n("remove")
                            }
                        }, {
                            key: "getActiveConfigSeriesIndex",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
                                    e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "asc",
                                    i = this.w,
                                    a = 0;
                                if (i.config.series.length > 1)
                                    for (var s = i.config.series.map((function(e, a) {
                                            var s = !1;
                                            return t && (s = "bar" === i.config.series[a].type || "column" === i.config.series[a].type), e.data && e.data.length > 0 && !s ? a : -1
                                        })), n = "asc" === e ? 0 : s.length - 1;
                                        "asc" === e ? n < s.length : n >= 0;
                                        "asc" === e ? n++ : n--)
                                        if (-1 !== s[n]) {
                                            a = s[n];
                                            break
                                        }
                                return a
                            }
                        }, {
                            key: "getPreviousPaths",
                            value: function() {
                                var t = this.w;

                                function e(e, i, a) {
                                    for (var s = e[i].childNodes, n = {
                                            type: a,
                                            paths: [],
                                            realIndex: e[i].getAttribute("data:realIndex")
                                        }, r = 0; r < s.length; r++)
                                        if (s[r].hasAttribute("pathTo")) {
                                            var o = s[r].getAttribute("pathTo");
                                            n.paths.push({
                                                d: o
                                            })
                                        }
                                    t.globals.previousPaths.push(n)
                                }
                                t.globals.previousPaths = [], ["line", "area", "bar", "rangebar", "candlestick", "radar"].forEach((function(i) {
                                    for (var a, s = (a = i, t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(a, "-series .apexcharts-series"))), n = 0; n < s.length; n++) e(s, n, i)
                                })), this.handlePrevBubbleScatterPaths("bubble"), this.handlePrevBubbleScatterPaths("scatter");
                                var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series"));
                                if (i.length > 0)
                                    for (var a = function(e) {
                                            for (var i = t.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t.config.chart.type, " .apexcharts-series[data\\:realIndex='").concat(e, "'] rect")), a = [], s = function(t) {
                                                    var e = function(e) {
                                                            return i[t].getAttribute(e)
                                                        },
                                                        s = {
                                                            x: parseFloat(e("x")),
                                                            y: parseFloat(e("y")),
                                                            width: parseFloat(e("width")),
                                                            height: parseFloat(e("height"))
                                                        };
                                                    a.push({
                                                        rect: s,
                                                        color: i[t].getAttribute("color")
                                                    })
                                                }, n = 0; n < i.length; n++) s(n);
                                            t.globals.previousPaths.push(a)
                                        }, s = 0; s < i.length; s++) a(s);
                                t.globals.axisCharts || (t.globals.previousPaths = t.globals.series)
                            }
                        }, {
                            key: "handlePrevBubbleScatterPaths",
                            value: function(t) {
                                var e = this.w,
                                    i = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series"));
                                if (i.length > 0)
                                    for (var a = 0; a < i.length; a++) {
                                        for (var s = e.globals.dom.baseEl.querySelectorAll(".apexcharts-".concat(t, "-series .apexcharts-series[data\\:realIndex='").concat(a, "'] circle")), n = [], r = 0; r < s.length; r++) n.push({
                                            x: s[r].getAttribute("cx"),
                                            y: s[r].getAttribute("cy"),
                                            r: s[r].getAttribute("r")
                                        });
                                        e.globals.previousPaths.push(n)
                                    }
                            }
                        }, {
                            key: "clearPreviousPaths",
                            value: function() {
                                var t = this.w;
                                t.globals.previousPaths = [], t.globals.allSeriesCollapsed = !1
                            }
                        }, {
                            key: "handleNoData",
                            value: function() {
                                var t = this.w,
                                    e = t.config.noData,
                                    i = new S(this.ctx),
                                    a = t.globals.svgWidth / 2,
                                    s = t.globals.svgHeight / 2,
                                    n = "middle";
                                if (t.globals.noData = !0, t.globals.animationEnded = !0, "left" === e.align ? (a = 10, n = "start") : "right" === e.align && (a = t.globals.svgWidth - 10, n = "end"), "top" === e.verticalAlign ? s = 50 : "bottom" === e.verticalAlign && (s = t.globals.svgHeight - 50), a += e.offsetX, s = s + parseInt(e.style.fontSize, 10) + 2 + e.offsetY, void 0 !== e.text && "" !== e.text) {
                                    var r = i.drawText({
                                        x: a,
                                        y: s,
                                        text: e.text,
                                        textAnchor: n,
                                        fontSize: e.style.fontSize,
                                        fontFamily: e.style.fontFamily,
                                        foreColor: e.style.color,
                                        opacity: 1,
                                        class: "apexcharts-text-nodata"
                                    });
                                    t.globals.dom.Paper.add(r)
                                }
                            }
                        }, {
                            key: "setNullSeriesToZeroValues",
                            value: function(t) {
                                for (var e = this.w, i = 0; i < t.length; i++)
                                    if (0 === t[i].length)
                                        for (var a = 0; a < t[e.globals.maxValsInArrayIndex].length; a++) t[i].push(0);
                                return t
                            }
                        }, {
                            key: "hasAllSeriesEqualX",
                            value: function() {
                                for (var t = !0, e = this.w, i = this.filteredSeriesX(), a = 0; a < i.length - 1; a++)
                                    if (i[a][0] !== i[a + 1][0]) {
                                        t = !1;
                                        break
                                    }
                                return e.globals.allSeriesHasEqualX = t, t
                            }
                        }, {
                            key: "filteredSeriesX",
                            value: function() {
                                return this.w.globals.seriesX.map((function(t) {
                                    return t.length > 0 ? t : []
                                }))
                            }
                        }]), t
                    }(),
                    N = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.barCtx = e
                        }
                        return c(t, [{
                            key: "initVariables",
                            value: function(t) {
                                var e = this.w;
                                this.barCtx.series = t, this.barCtx.totalItems = 0, this.barCtx.seriesLen = 0, this.barCtx.visibleI = -1, this.barCtx.visibleItems = 1;
                                for (var i = 0; i < t.length; i++)
                                    if (t[i].length > 0 && (this.barCtx.seriesLen = this.barCtx.seriesLen + 1, this.barCtx.totalItems += t[i].length), e.globals.isXNumeric)
                                        for (var a = 0; a < t[i].length; a++) e.globals.seriesX[i][a] > e.globals.minX && e.globals.seriesX[i][a] < e.globals.maxX && this.barCtx.visibleItems++;
                                    else this.barCtx.visibleItems = e.globals.dataPoints;
                                0 === this.barCtx.seriesLen && (this.barCtx.seriesLen = 1), this.barCtx.zeroSerieses = [], this.barCtx.radiusOnSeriesNumber = t.length - 1, e.globals.comboCharts || this.checkZeroSeries({
                                    series: t
                                })
                            }
                        }, {
                            key: "initialPositions",
                            value: function() {
                                var t, e, i, a, s, n, r, o, l = this.w,
                                    c = l.globals.dataPoints;
                                this.barCtx.isRangeBar && (c = l.globals.labels.length);
                                var h = this.barCtx.seriesLen;
                                if (l.config.plotOptions.bar.rangeBarGroupRows && (h = 1), this.barCtx.isHorizontal) s = (i = l.globals.gridHeight / c) / h, l.globals.isXNumeric && (s = (i = l.globals.gridHeight / this.barCtx.totalItems) / this.barCtx.seriesLen), s = s * parseInt(this.barCtx.barOptions.barHeight, 10) / 100, o = this.barCtx.baseLineInvertedY + l.globals.padHorizontal + (this.barCtx.isReversed ? l.globals.gridWidth : 0) - (this.barCtx.isReversed ? 2 * this.barCtx.baseLineInvertedY : 0), e = (i - s * this.barCtx.seriesLen) / 2;
                                else {
                                    if (a = l.globals.gridWidth / this.barCtx.visibleItems, l.config.xaxis.convertedCatToNumeric && (a = l.globals.gridWidth / l.globals.dataPoints), n = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100, l.globals.isXNumeric) {
                                        var d = this.barCtx.xRatio;
                                        l.config.xaxis.convertedCatToNumeric && (d = this.barCtx.initialXRatio), l.globals.minXDiff && .5 !== l.globals.minXDiff && l.globals.minXDiff / d > 0 && (a = l.globals.minXDiff / d), (n = a / this.barCtx.seriesLen * parseInt(this.barCtx.barOptions.columnWidth, 10) / 100) < 1 && (n = 1)
                                    }
                                    r = l.globals.gridHeight - this.barCtx.baseLineY[this.barCtx.yaxisIndex] - (this.barCtx.isReversed ? l.globals.gridHeight : 0) + (this.barCtx.isReversed ? 2 * this.barCtx.baseLineY[this.barCtx.yaxisIndex] : 0), t = l.globals.padHorizontal + (a - n * this.barCtx.seriesLen) / 2
                                }
                                return {
                                    x: t,
                                    y: e,
                                    yDivision: i,
                                    xDivision: a,
                                    barHeight: s,
                                    barWidth: n,
                                    zeroH: r,
                                    zeroW: o
                                }
                            }
                        }, {
                            key: "getPathFillColor",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = new I(this.barCtx.ctx),
                                    r = null,
                                    o = this.barCtx.barOptions.distributed ? i : e;
                                return this.barCtx.barOptions.colors.ranges.length > 0 && this.barCtx.barOptions.colors.ranges.map((function(a) {
                                    t[e][i] >= a.from && t[e][i] <= a.to && (r = a.color)
                                })), s.config.series[e].data[i] && s.config.series[e].data[i].fillColor && (r = s.config.series[e].data[i].fillColor), n.fillPath({
                                    seriesNumber: this.barCtx.barOptions.distributed ? o : a,
                                    dataPointIndex: i,
                                    color: r,
                                    value: t[e][i]
                                })
                            }
                        }, {
                            key: "getStrokeWidth",
                            value: function(t, e, i) {
                                var a = 0,
                                    s = this.w;
                                return void 0 === this.barCtx.series[t][e] || null === this.barCtx.series[t][e] ? this.barCtx.isNullValue = !0 : this.barCtx.isNullValue = !1, s.config.stroke.show && (this.barCtx.isNullValue || (a = Array.isArray(this.barCtx.strokeWidth) ? this.barCtx.strokeWidth[i] : this.barCtx.strokeWidth)), a
                            }
                        }, {
                            key: "barBackground",
                            value: function(t) {
                                var e = t.j,
                                    i = t.i,
                                    a = t.x1,
                                    s = t.x2,
                                    n = t.y1,
                                    r = t.y2,
                                    o = t.elSeries,
                                    l = this.w,
                                    c = new S(this.barCtx.ctx),
                                    h = new O(this.barCtx.ctx).getActiveConfigSeriesIndex();
                                if (this.barCtx.barOptions.colors.backgroundBarColors.length > 0 && h === i) {
                                    e >= this.barCtx.barOptions.colors.backgroundBarColors.length && (e %= this.barCtx.barOptions.colors.backgroundBarColors.length);
                                    var d = this.barCtx.barOptions.colors.backgroundBarColors[e],
                                        u = c.drawRect(void 0 !== a ? a : 0, void 0 !== n ? n : 0, void 0 !== s ? s : l.globals.gridWidth, void 0 !== r ? r : l.globals.gridHeight, this.barCtx.barOptions.colors.backgroundBarRadius, d, this.barCtx.barOptions.colors.backgroundBarOpacity);
                                    o.add(u), u.node.classList.add("apexcharts-backgroundBar")
                                }
                            }
                        }, {
                            key: "getColumnPaths",
                            value: function(t) {
                                var e = t.barWidth,
                                    i = t.barXPosition,
                                    a = t.yRatio,
                                    s = t.y1,
                                    n = t.y2,
                                    r = t.strokeWidth,
                                    o = t.series,
                                    l = t.realIndex,
                                    c = t.i,
                                    h = t.j,
                                    d = t.w,
                                    u = new S(this.barCtx.ctx);
                                (r = Array.isArray(r) ? r[l] : r) || (r = 0);
                                var p = {
                                        barWidth: e,
                                        strokeWidth: r,
                                        yRatio: a,
                                        barXPosition: i,
                                        y1: s,
                                        y2: n
                                    },
                                    g = this.getRoundedBars(d, p, o, c, h),
                                    f = i,
                                    m = i + e,
                                    x = u.move(f, s),
                                    v = u.move(f, s),
                                    b = u.line(m - r, s);
                                return d.globals.previousPaths.length > 0 && (v = this.barCtx.getPreviousPath(l, h, !1)), x = x + u.line(f, g.y2) + g.pathWithRadius + u.line(m - r, g.y2) + b + b + "z", v = v + u.line(f, s) + b + b + b + b + b + u.line(f, s), d.config.chart.stacked && (this.barCtx.yArrj.push(g.y2WithRadius), this.barCtx.yArrjF.push(Math.abs(s - g.y2WithRadius)), this.barCtx.yArrjVal.push(this.barCtx.series[c][h])), {
                                    pathTo: x,
                                    pathFrom: v
                                }
                            }
                        }, {
                            key: "getBarpaths",
                            value: function(t) {
                                var e = t.barYPosition,
                                    i = t.barHeight,
                                    a = t.x1,
                                    s = t.x2,
                                    n = t.strokeWidth,
                                    r = t.series,
                                    o = t.realIndex,
                                    l = t.i,
                                    c = t.j,
                                    h = t.w,
                                    d = new S(this.barCtx.ctx);
                                (n = Array.isArray(n) ? n[o] : n) || (n = 0);
                                var u = {
                                        barHeight: i,
                                        strokeWidth: n,
                                        barYPosition: e,
                                        x2: s,
                                        x1: a
                                    },
                                    p = this.getRoundedBars(h, u, r, l, c),
                                    g = d.move(a, e),
                                    f = d.move(a, e);
                                h.globals.previousPaths.length > 0 && (f = this.barCtx.getPreviousPath(o, c, !1));
                                var m = e,
                                    x = e + i,
                                    v = d.line(a, x - n);
                                return g = g + d.line(p.x2, m) + p.pathWithRadius + d.line(p.x2, x - n) + v + v + "z", f = f + d.line(a, m) + v + v + v + v + v + d.line(a, m), h.config.chart.stacked && (this.barCtx.xArrj.push(p.x2WithRadius), this.barCtx.xArrjF.push(Math.abs(a - p.x2WithRadius)), this.barCtx.xArrjVal.push(this.barCtx.series[l][c])), {
                                    pathTo: g,
                                    pathFrom: f
                                }
                            }
                        }, {
                            key: "getRoundedBars",
                            value: function(t, e, i, a, s) {
                                var n = new S(this.barCtx.ctx),
                                    r = 0,
                                    o = t.config.plotOptions.bar.borderRadius,
                                    l = Array.isArray(o);
                                if (r = l ? o[a > o.length - 1 ? o.length - 1 : a] : o, t.config.chart.stacked && i.length > 1 && a !== this.barCtx.radiusOnSeriesNumber && !l && (r = 0), this.barCtx.isHorizontal) {
                                    var c = "",
                                        h = e.x2;
                                    if (Math.abs(e.x1 - e.x2) < r && (r = Math.abs(e.x1 - e.x2)), void 0 !== i[a][s] || null !== i[a][s]) {
                                        var d = this.barCtx.isReversed ? i[a][s] > 0 : i[a][s] < 0;
                                        d && (r *= -1), h -= r, c = n.quadraticCurve(h + r, e.barYPosition, h + r, e.barYPosition + (d ? -1 * r : r)) + n.line(h + r, e.barYPosition + e.barHeight - e.strokeWidth - (d ? -1 * r : r)) + n.quadraticCurve(h + r, e.barYPosition + e.barHeight - e.strokeWidth, h, e.barYPosition + e.barHeight - e.strokeWidth)
                                    }
                                    return {
                                        pathWithRadius: c,
                                        x2WithRadius: h + r,
                                        x2: h
                                    }
                                }
                                var u = "",
                                    p = e.y2;
                                if (Math.abs(e.y1 - e.y2) < r && (r = Math.abs(e.y1 - e.y2)), void 0 !== i[a][s] || null !== i[a][s]) {
                                    var g = i[a][s] < 0;
                                    g && (r *= -1), p += r, u = n.quadraticCurve(e.barXPosition, p - r, e.barXPosition + (g ? -1 * r : r), p - r) + n.line(e.barXPosition + e.barWidth - e.strokeWidth - (g ? -1 * r : r), p - r) + n.quadraticCurve(e.barXPosition + e.barWidth - e.strokeWidth, p - r, e.barXPosition + e.barWidth - e.strokeWidth, p)
                                }
                                return {
                                    pathWithRadius: u,
                                    y2WithRadius: p - r,
                                    y2: p
                                }
                            }
                        }, {
                            key: "checkZeroSeries",
                            value: function(t) {
                                for (var e = t.series, i = this.w, a = 0; a < e.length; a++) {
                                    for (var s = 0, n = 0; n < e[i.globals.maxValsInArrayIndex].length; n++) s += e[a][n];
                                    0 === s && this.barCtx.zeroSerieses.push(a)
                                }
                                for (var r = e.length - 1; r >= 0; r--) this.barCtx.zeroSerieses.indexOf(r) > -1 && r === this.radiusOnSeriesNumber && (this.barCtx.radiusOnSeriesNumber -= 1);
                                for (var o = e.length - 1; o >= 0; o--) i.globals.collapsedSeriesIndices.indexOf(this.barCtx.radiusOnSeriesNumber) > -1 && (this.barCtx.radiusOnSeriesNumber -= 1)
                            }
                        }, {
                            key: "getXForValue",
                            value: function(t, e) {
                                var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                    a = i ? e : null;
                                return null != t && (a = e + t / this.barCtx.invertedYRatio - 2 * (this.barCtx.isReversed ? t / this.barCtx.invertedYRatio : 0)), a
                            }
                        }, {
                            key: "getYForValue",
                            value: function(t, e) {
                                var i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                    a = i ? e : null;
                                return null != t && (a = e - t / this.barCtx.yRatio[this.barCtx.yaxisIndex] + 2 * (this.barCtx.isReversed ? t / this.barCtx.yRatio[this.barCtx.yaxisIndex] : 0)), a
                            }
                        }, {
                            key: "getGoalValues",
                            value: function(t, e, i, a, s) {
                                var n = this,
                                    r = this.w,
                                    o = [];
                                return r.globals.seriesGoals[a] && r.globals.seriesGoals[a][s] && Array.isArray(r.globals.seriesGoals[a][s]) && r.globals.seriesGoals[a][s].forEach((function(a) {
                                    var s;
                                    o.push((h(s = {}, t, "x" === t ? n.getXForValue(a.value, e, !1) : n.getYForValue(a.value, i, !1)), h(s, "attrs", a), s))
                                })), o
                            }
                        }, {
                            key: "drawGoalLine",
                            value: function(t) {
                                var e = t.barXPosition,
                                    i = t.barYPosition,
                                    a = t.goalX,
                                    s = t.goalY,
                                    n = t.barWidth,
                                    r = t.barHeight,
                                    o = new S(this.barCtx.ctx),
                                    l = o.group({
                                        className: "apexcharts-bar-goals-groups"
                                    }),
                                    c = null;
                                return this.barCtx.isHorizontal ? Array.isArray(a) && a.forEach((function(t) {
                                    var e = void 0 !== t.attrs.strokeHeight ? t.attrs.strokeHeight : r / 2,
                                        a = i + e + r / 2;
                                    c = o.drawLine(t.x, a - 2 * e, t.x, a, t.attrs.strokeColor ? t.attrs.strokeColor : void 0, t.attrs.strokeDashArray, t.attrs.strokeWidth ? t.attrs.strokeWidth : 2, t.attrs.strokeLineCap), l.add(c)
                                })) : Array.isArray(s) && s.forEach((function(t) {
                                    var i = void 0 !== t.attrs.strokeWidth ? t.attrs.strokeWidth : n / 2,
                                        a = e + i + n / 2;
                                    c = o.drawLine(a - 2 * i, t.y, a, t.y, t.attrs.strokeColor ? t.attrs.strokeColor : void 0, t.attrs.strokeDashArray, t.attrs.strokeHeight ? t.attrs.strokeHeight : 2, t.attrs.strokeLineCap), l.add(c)
                                })), l
                            }
                        }]), t
                    }(),
                    Y = function() {
                        function t(e, i) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var a = this.w;
                            this.barOptions = a.config.plotOptions.bar, this.isHorizontal = this.barOptions.horizontal, this.strokeWidth = a.config.stroke.width, this.isNullValue = !1, this.isRangeBar = a.globals.seriesRangeBar.length && this.isHorizontal, this.xyRatios = i, null !== this.xyRatios && (this.xRatio = i.xRatio, this.initialXRatio = i.initialXRatio, this.yRatio = i.yRatio, this.invertedXRatio = i.invertedXRatio, this.invertedYRatio = i.invertedYRatio, this.baseLineY = i.baseLineY, this.baseLineInvertedY = i.baseLineInvertedY), this.yaxisIndex = 0, this.seriesLen = 0, this.barHelpers = new N(this)
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new S(this.ctx),
                                    s = new C(this.ctx, i);
                                t = s.getLogSeries(t), this.series = t, this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                                var r = a.group({
                                    class: "apexcharts-bar-series apexcharts-plot-series"
                                });
                                i.config.dataLabels.enabled && this.totalItems > this.barOptions.dataLabels.maxItems && console.warn("WARNING: DataLabels are enabled but there are too many to display. This may cause performance issue when rendering.");
                                for (var o = 0, l = 0; o < t.length; o++, l++) {
                                    var c, h, d, u, p = void 0,
                                        g = void 0,
                                        f = [],
                                        m = [],
                                        x = i.globals.comboCharts ? e[o] : o,
                                        v = a.group({
                                            class: "apexcharts-series",
                                            rel: o + 1,
                                            seriesName: b.escapeString(i.globals.seriesNames[x]),
                                            "data:realIndex": x
                                        });
                                    this.ctx.series.addCollapsedClassToSeries(v, x), t[o].length > 0 && (this.visibleI = this.visibleI + 1);
                                    var y = 0,
                                        w = 0;
                                    this.yRatio.length > 1 && (this.yaxisIndex = x), this.isReversed = i.config.yaxis[this.yaxisIndex] && i.config.yaxis[this.yaxisIndex].reversed;
                                    var k = this.barHelpers.initialPositions();
                                    g = k.y, y = k.barHeight, h = k.yDivision, u = k.zeroW, p = k.x, w = k.barWidth, c = k.xDivision, d = k.zeroH, this.horizontal || m.push(p + w / 2);
                                    for (var A = a.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": x
                                        }), E = a.group({
                                            class: "apexcharts-bar-goals-markers",
                                            style: "pointer-events: none"
                                        }), T = 0; T < i.globals.dataPoints; T++) {
                                        var P = this.barHelpers.getStrokeWidth(o, T, x),
                                            M = null,
                                            L = {
                                                indexes: {
                                                    i: o,
                                                    j: T,
                                                    realIndex: x,
                                                    bc: l
                                                },
                                                x: p,
                                                y: g,
                                                strokeWidth: P,
                                                elSeries: v
                                            };
                                        this.isHorizontal ? (M = this.drawBarPaths(n(n({}, L), {}, {
                                            barHeight: y,
                                            zeroW: u,
                                            yDivision: h
                                        })), w = this.series[o][T] / this.invertedYRatio) : (M = this.drawColumnPaths(n(n({}, L), {}, {
                                            xDivision: c,
                                            barWidth: w,
                                            zeroH: d
                                        })), y = this.series[o][T] / this.yRatio[this.yaxisIndex]);
                                        var I = this.barHelpers.drawGoalLine({
                                            barXPosition: M.barXPosition,
                                            barYPosition: M.barYPosition,
                                            goalX: M.goalX,
                                            goalY: M.goalY,
                                            barHeight: y,
                                            barWidth: w
                                        });
                                        I && E.add(I), g = M.y, p = M.x, T > 0 && m.push(p + w / 2), f.push(g);
                                        var _ = this.barHelpers.getPathFillColor(t, o, T, x);
                                        this.renderSeries({
                                            realIndex: x,
                                            pathFill: _,
                                            j: T,
                                            i: o,
                                            pathFrom: M.pathFrom,
                                            pathTo: M.pathTo,
                                            strokeWidth: P,
                                            elSeries: v,
                                            x: p,
                                            y: g,
                                            series: t,
                                            barHeight: y,
                                            barWidth: w,
                                            elDataLabelsWrap: A,
                                            elGoalsMarkers: E,
                                            visibleSeries: this.visibleI,
                                            type: "bar"
                                        })
                                    }
                                    i.globals.seriesXvalues[x] = m, i.globals.seriesYvalues[x] = f, r.add(v)
                                }
                                return r
                            }
                        }, {
                            key: "renderSeries",
                            value: function(t) {
                                var e = t.realIndex,
                                    i = t.pathFill,
                                    a = t.lineFill,
                                    s = t.j,
                                    n = t.i,
                                    r = t.pathFrom,
                                    o = t.pathTo,
                                    l = t.strokeWidth,
                                    c = t.elSeries,
                                    h = t.x,
                                    d = t.y,
                                    u = t.y1,
                                    p = t.y2,
                                    g = t.series,
                                    f = t.barHeight,
                                    m = t.barWidth,
                                    x = t.barYPosition,
                                    v = t.elDataLabelsWrap,
                                    b = t.elGoalsMarkers,
                                    y = t.visibleSeries,
                                    C = t.type,
                                    k = this.w,
                                    A = new S(this.ctx);
                                a || (a = this.barOptions.distributed ? k.globals.stroke.colors[s] : k.globals.stroke.colors[e]), k.config.series[n].data[s] && k.config.series[n].data[s].strokeColor && (a = k.config.series[n].data[s].strokeColor), this.isNullValue && (i = "none");
                                var E = s / k.config.chart.animations.animateGradually.delay * (k.config.chart.animations.speed / k.globals.dataPoints) / 2.4,
                                    T = A.renderPaths({
                                        i: n,
                                        j: s,
                                        realIndex: e,
                                        pathFrom: r,
                                        pathTo: o,
                                        stroke: a,
                                        strokeWidth: l,
                                        strokeLineCap: k.config.stroke.lineCap,
                                        fill: i,
                                        animationDelay: E,
                                        initialSpeed: k.config.chart.animations.speed,
                                        dataChangeSpeed: k.config.chart.animations.dynamicAnimation.speed,
                                        className: "apexcharts-".concat(C, "-area")
                                    });
                                T.attr("clip-path", "url(#gridRectMask".concat(k.globals.cuid, ")"));
                                var P = k.config.forecastDataPoints;
                                P.count > 0 && s >= k.globals.dataPoints - P.count && (T.node.setAttribute("stroke-dasharray", P.dashArray), T.node.setAttribute("stroke-width", P.strokeWidth), T.node.setAttribute("fill-opacity", P.fillOpacity)), void 0 !== u && void 0 !== p && (T.attr("data-range-y1", u), T.attr("data-range-y2", p)), new w(this.ctx).setSelectionFilter(T, e, s), c.add(T);
                                var M = new X(this).handleBarDataLabels({
                                    x: h,
                                    y: d,
                                    y1: u,
                                    y2: p,
                                    i: n,
                                    j: s,
                                    series: g,
                                    realIndex: e,
                                    barHeight: f,
                                    barWidth: m,
                                    barYPosition: x,
                                    renderedPath: T,
                                    visibleSeries: y
                                });
                                return null !== M && v.add(M), c.add(v), b && c.add(b), c
                            }
                        }, {
                            key: "drawBarPaths",
                            value: function(t) {
                                var e = t.indexes,
                                    i = t.barHeight,
                                    a = t.strokeWidth,
                                    s = t.zeroW,
                                    n = t.x,
                                    r = t.y,
                                    o = t.yDivision,
                                    l = t.elSeries,
                                    c = this.w,
                                    h = e.i,
                                    d = e.j;
                                c.globals.isXNumeric && (r = (c.globals.seriesX[h][d] - c.globals.minX) / this.invertedXRatio - i);
                                var u = r + i * this.visibleI;
                                n = this.barHelpers.getXForValue(this.series[h][d], s);
                                var p = this.barHelpers.getBarpaths({
                                    barYPosition: u,
                                    barHeight: i,
                                    x1: s,
                                    x2: n,
                                    strokeWidth: a,
                                    series: this.series,
                                    realIndex: e.realIndex,
                                    i: h,
                                    j: d,
                                    w: c
                                });
                                return c.globals.isXNumeric || (r += o), this.barHelpers.barBackground({
                                    j: d,
                                    i: h,
                                    y1: u - i * this.visibleI,
                                    y2: i * this.seriesLen,
                                    elSeries: l
                                }), {
                                    pathTo: p.pathTo,
                                    pathFrom: p.pathFrom,
                                    x: n,
                                    y: r,
                                    goalX: this.barHelpers.getGoalValues("x", s, null, h, d),
                                    barYPosition: u
                                }
                            }
                        }, {
                            key: "drawColumnPaths",
                            value: function(t) {
                                var e = t.indexes,
                                    i = t.x,
                                    a = t.y,
                                    s = t.xDivision,
                                    n = t.barWidth,
                                    r = t.zeroH,
                                    o = t.strokeWidth,
                                    l = t.elSeries,
                                    c = this.w,
                                    h = e.realIndex,
                                    d = e.i,
                                    u = e.j,
                                    p = e.bc;
                                if (c.globals.isXNumeric) {
                                    var g = h;
                                    c.globals.seriesX[h].length || (g = c.globals.maxValsInArrayIndex), i = (c.globals.seriesX[g][u] - c.globals.minX) / this.xRatio - n * this.seriesLen / 2
                                }
                                var f = i + n * this.visibleI;
                                a = this.barHelpers.getYForValue(this.series[d][u], r);
                                var m = this.barHelpers.getColumnPaths({
                                    barXPosition: f,
                                    barWidth: n,
                                    y1: r,
                                    y2: a,
                                    strokeWidth: o,
                                    series: this.series,
                                    realIndex: e.realIndex,
                                    i: d,
                                    j: u,
                                    w: c
                                });
                                return c.globals.isXNumeric || (i += s), this.barHelpers.barBackground({
                                    bc: p,
                                    j: u,
                                    i: d,
                                    x1: f - o / 2 - n * this.visibleI,
                                    x2: n * this.seriesLen + o / 2,
                                    elSeries: l
                                }), {
                                    pathTo: m.pathTo,
                                    pathFrom: m.pathFrom,
                                    x: i,
                                    y: a,
                                    goalY: this.barHelpers.getGoalValues("y", null, r, d, u),
                                    barXPosition: f
                                }
                            }
                        }, {
                            key: "getPreviousPath",
                            value: function(t, e) {
                                for (var i, a = this.w, s = 0; s < a.globals.previousPaths.length; s++) {
                                    var n = a.globals.previousPaths[s];
                                    n.paths && n.paths.length > 0 && parseInt(n.realIndex, 10) === parseInt(t, 10) && void 0 !== a.globals.previousPaths[s].paths[e] && (i = a.globals.previousPaths[s].paths[e].d)
                                }
                                return i
                            }
                        }]), t
                    }(),
                    F = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.months31 = [1, 3, 5, 7, 8, 10, 12], this.months30 = [2, 4, 6, 9, 11], this.daysCntOfYear = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]
                        }
                        return c(t, [{
                            key: "isValidDate",
                            value: function(t) {
                                return !isNaN(this.parseDate(t))
                            }
                        }, {
                            key: "getTimeStamp",
                            value: function(t) {
                                return Date.parse(t) ? this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toISOString().substr(0, 25)).getTime() : new Date(t).getTime() : t
                            }
                        }, {
                            key: "getDate",
                            value: function(t) {
                                return this.w.config.xaxis.labels.datetimeUTC ? new Date(new Date(t).toUTCString()) : new Date(t)
                            }
                        }, {
                            key: "parseDate",
                            value: function(t) {
                                var e = Date.parse(t);
                                if (!isNaN(e)) return this.getTimeStamp(t);
                                var i = Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "));
                                return this.getTimeStamp(i)
                            }
                        }, {
                            key: "parseDateWithTimezone",
                            value: function(t) {
                                return Date.parse(t.replace(/-/g, "/").replace(/[a-z]+/gi, " "))
                            }
                        }, {
                            key: "formatDate",
                            value: function(t, e) {
                                var i = this.w.globals.locale,
                                    a = this.w.config.xaxis.labels.datetimeUTC,
                                    s = ["\0"].concat(m(i.months)),
                                    n = [""].concat(m(i.shortMonths)),
                                    r = [""].concat(m(i.days)),
                                    o = [""].concat(m(i.shortDays));

                                function l(t, e) {
                                    var i = t + "";
                                    for (e = e || 2; i.length < e;) i = "0" + i;
                                    return i
                                }
                                var c = a ? t.getUTCFullYear() : t.getFullYear();
                                e = (e = (e = e.replace(/(^|[^\\])yyyy+/g, "$1" + c)).replace(/(^|[^\\])yy/g, "$1" + c.toString().substr(2, 2))).replace(/(^|[^\\])y/g, "$1" + c);
                                var h = (a ? t.getUTCMonth() : t.getMonth()) + 1;
                                e = (e = (e = (e = e.replace(/(^|[^\\])MMMM+/g, "$1" + s[0])).replace(/(^|[^\\])MMM/g, "$1" + n[0])).replace(/(^|[^\\])MM/g, "$1" + l(h))).replace(/(^|[^\\])M/g, "$1" + h);
                                var d = a ? t.getUTCDate() : t.getDate();
                                e = (e = (e = (e = e.replace(/(^|[^\\])dddd+/g, "$1" + r[0])).replace(/(^|[^\\])ddd/g, "$1" + o[0])).replace(/(^|[^\\])dd/g, "$1" + l(d))).replace(/(^|[^\\])d/g, "$1" + d);
                                var u = a ? t.getUTCHours() : t.getHours(),
                                    p = u > 12 ? u - 12 : 0 === u ? 12 : u;
                                e = (e = (e = (e = e.replace(/(^|[^\\])HH+/g, "$1" + l(u))).replace(/(^|[^\\])H/g, "$1" + u)).replace(/(^|[^\\])hh+/g, "$1" + l(p))).replace(/(^|[^\\])h/g, "$1" + p);
                                var g = a ? t.getUTCMinutes() : t.getMinutes();
                                e = (e = e.replace(/(^|[^\\])mm+/g, "$1" + l(g))).replace(/(^|[^\\])m/g, "$1" + g);
                                var f = a ? t.getUTCSeconds() : t.getSeconds();
                                e = (e = e.replace(/(^|[^\\])ss+/g, "$1" + l(f))).replace(/(^|[^\\])s/g, "$1" + f);
                                var x = a ? t.getUTCMilliseconds() : t.getMilliseconds();
                                e = e.replace(/(^|[^\\])fff+/g, "$1" + l(x, 3)), x = Math.round(x / 10), e = e.replace(/(^|[^\\])ff/g, "$1" + l(x)), x = Math.round(x / 10);
                                var v = u < 12 ? "AM" : "PM";
                                e = (e = (e = e.replace(/(^|[^\\])f/g, "$1" + x)).replace(/(^|[^\\])TT+/g, "$1" + v)).replace(/(^|[^\\])T/g, "$1" + v.charAt(0));
                                var b = v.toLowerCase();
                                e = (e = e.replace(/(^|[^\\])tt+/g, "$1" + b)).replace(/(^|[^\\])t/g, "$1" + b.charAt(0));
                                var y = -t.getTimezoneOffset(),
                                    w = a || !y ? "Z" : y > 0 ? "+" : "-";
                                if (!a) {
                                    var S = (y = Math.abs(y)) % 60;
                                    w += l(Math.floor(y / 60)) + ":" + l(S)
                                }
                                e = e.replace(/(^|[^\\])K/g, "$1" + w);
                                var C = (a ? t.getUTCDay() : t.getDay()) + 1;
                                return (e = (e = (e = (e = e.replace(new RegExp(r[0], "g"), r[C])).replace(new RegExp(o[0], "g"), o[C])).replace(new RegExp(s[0], "g"), s[h])).replace(new RegExp(n[0], "g"), n[h])).replace(/\\(.)/g, "$1")
                            }
                        }, {
                            key: "getTimeUnitsfromTimestamp",
                            value: function(t, e, i) {
                                var a = this.w;
                                void 0 !== a.config.xaxis.min && (t = a.config.xaxis.min), void 0 !== a.config.xaxis.max && (e = a.config.xaxis.max);
                                var s = this.getDate(t),
                                    n = this.getDate(e),
                                    r = this.formatDate(s, "yyyy MM dd HH mm ss fff").split(" "),
                                    o = this.formatDate(n, "yyyy MM dd HH mm ss fff").split(" ");
                                return {
                                    minMillisecond: parseInt(r[6], 10),
                                    maxMillisecond: parseInt(o[6], 10),
                                    minSecond: parseInt(r[5], 10),
                                    maxSecond: parseInt(o[5], 10),
                                    minMinute: parseInt(r[4], 10),
                                    maxMinute: parseInt(o[4], 10),
                                    minHour: parseInt(r[3], 10),
                                    maxHour: parseInt(o[3], 10),
                                    minDate: parseInt(r[2], 10),
                                    maxDate: parseInt(o[2], 10),
                                    minMonth: parseInt(r[1], 10) - 1,
                                    maxMonth: parseInt(o[1], 10) - 1,
                                    minYear: parseInt(r[0], 10),
                                    maxYear: parseInt(o[0], 10)
                                }
                            }
                        }, {
                            key: "isLeapYear",
                            value: function(t) {
                                return t % 4 == 0 && t % 100 != 0 || t % 400 == 0
                            }
                        }, {
                            key: "calculcateLastDaysOfMonth",
                            value: function(t, e, i) {
                                return this.determineDaysOfMonths(t, e) - i
                            }
                        }, {
                            key: "determineDaysOfYear",
                            value: function(t) {
                                var e = 365;
                                return this.isLeapYear(t) && (e = 366), e
                            }
                        }, {
                            key: "determineRemainingDaysOfYear",
                            value: function(t, e, i) {
                                var a = this.daysCntOfYear[e] + i;
                                return e > 1 && this.isLeapYear() && a++, a
                            }
                        }, {
                            key: "determineDaysOfMonths",
                            value: function(t, e) {
                                var i = 30;
                                switch (t = b.monthMod(t), !0) {
                                    case this.months30.indexOf(t) > -1:
                                        2 === t && (i = this.isLeapYear(e) ? 29 : 28);
                                        break;
                                    case this.months31.indexOf(t) > -1:
                                    default:
                                        i = 31
                                }
                                return i
                            }
                        }]), t
                    }(),
                    R = function(t) {
                        d(i, Y);
                        var e = f(i);

                        function i() {
                            return o(this, i), e.apply(this, arguments)
                        }
                        return c(i, [{
                            key: "draw",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new S(this.ctx);
                                this.rangeBarOptions = this.w.config.plotOptions.rangeBar, this.series = t, this.seriesRangeStart = i.globals.seriesRangeStart, this.seriesRangeEnd = i.globals.seriesRangeEnd, this.barHelpers.initVariables(t);
                                for (var s = a.group({
                                        class: "apexcharts-rangebar-series apexcharts-plot-series"
                                    }), r = 0; r < t.length; r++) {
                                    var o, l, c, h = void 0,
                                        d = void 0,
                                        u = void 0,
                                        p = i.globals.comboCharts ? e[r] : r,
                                        g = a.group({
                                            class: "apexcharts-series",
                                            seriesName: b.escapeString(i.globals.seriesNames[p]),
                                            rel: r + 1,
                                            "data:realIndex": p
                                        });
                                    this.ctx.series.addCollapsedClassToSeries(g, p), t[r].length > 0 && (this.visibleI = this.visibleI + 1);
                                    var f = 0,
                                        m = 0;
                                    this.yRatio.length > 1 && (this.yaxisIndex = p);
                                    var x = this.barHelpers.initialPositions();
                                    d = x.y, c = x.zeroW, h = x.x, m = x.barWidth, o = x.xDivision, l = x.zeroH;
                                    for (var v = a.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": p
                                        }), y = a.group({
                                            class: "apexcharts-rangebar-goals-markers",
                                            style: "pointer-events: none"
                                        }), w = 0; w < i.globals.dataPoints; w++) {
                                        var C = this.barHelpers.getStrokeWidth(r, w, p),
                                            k = this.seriesRangeStart[r][w],
                                            A = this.seriesRangeEnd[r][w],
                                            E = null,
                                            T = null,
                                            P = {
                                                x: h,
                                                y: d,
                                                strokeWidth: C,
                                                elSeries: g
                                            };
                                        if (u = x.yDivision, f = x.barHeight, this.isHorizontal) {
                                            T = d + f * this.visibleI;
                                            var M = this.seriesLen;
                                            i.config.plotOptions.bar.rangeBarGroupRows && (M = 1);
                                            var L = (u - f * M) / 2;
                                            if (void 0 === i.config.series[r].data[w]) break;
                                            if (i.config.series[r].data[w].x) {
                                                var I = this.detectOverlappingBars({
                                                    i: r,
                                                    j: w,
                                                    barYPosition: T,
                                                    srty: L,
                                                    barHeight: f,
                                                    yDivision: u,
                                                    initPositions: x
                                                });
                                                f = I.barHeight, T = I.barYPosition
                                            }
                                            m = (E = this.drawRangeBarPaths(n({
                                                indexes: {
                                                    i: r,
                                                    j: w,
                                                    realIndex: p
                                                },
                                                barHeight: f,
                                                barYPosition: T,
                                                zeroW: c,
                                                yDivision: u,
                                                y1: k,
                                                y2: A
                                            }, P))).barWidth
                                        } else f = (E = this.drawRangeColumnPaths(n({
                                            indexes: {
                                                i: r,
                                                j: w,
                                                realIndex: p
                                            },
                                            zeroH: l,
                                            barWidth: m,
                                            xDivision: o
                                        }, P))).barHeight;
                                        var _ = this.barHelpers.drawGoalLine({
                                            barXPosition: E.barXPosition,
                                            barYPosition: T,
                                            goalX: E.goalX,
                                            goalY: E.goalY,
                                            barHeight: f,
                                            barWidth: m
                                        });
                                        _ && y.add(_), d = E.y, h = E.x;
                                        var z = this.barHelpers.getPathFillColor(t, r, w, p),
                                            D = i.globals.stroke.colors[p];
                                        this.renderSeries({
                                            realIndex: p,
                                            pathFill: z,
                                            lineFill: D,
                                            j: w,
                                            i: r,
                                            x: h,
                                            y: d,
                                            y1: k,
                                            y2: A,
                                            pathFrom: E.pathFrom,
                                            pathTo: E.pathTo,
                                            strokeWidth: C,
                                            elSeries: g,
                                            series: t,
                                            barHeight: f,
                                            barYPosition: T,
                                            barWidth: m,
                                            elDataLabelsWrap: v,
                                            elGoalsMarkers: y,
                                            visibleSeries: this.visibleI,
                                            type: "rangebar"
                                        })
                                    }
                                    s.add(g)
                                }
                                return s
                            }
                        }, {
                            key: "detectOverlappingBars",
                            value: function(t) {
                                var e = t.i,
                                    i = t.j,
                                    a = t.barYPosition,
                                    s = t.srty,
                                    n = t.barHeight,
                                    r = t.yDivision,
                                    o = t.initPositions,
                                    l = this.w,
                                    c = [],
                                    h = l.config.series[e].data[i].rangeName,
                                    d = l.config.series[e].data[i].x,
                                    u = l.globals.labels.indexOf(d),
                                    p = l.globals.seriesRangeBar[e].findIndex((function(t) {
                                        return t.x === d && t.overlaps.length > 0
                                    }));
                                return a = l.config.plotOptions.bar.rangeBarGroupRows ? s + r * u : s + n * this.visibleI + r * u, p > -1 && !l.config.plotOptions.bar.rangeBarOverlap && (c = l.globals.seriesRangeBar[e][p].overlaps).indexOf(h) > -1 && (a = (n = o.barHeight / c.length) * this.visibleI + r * (100 - parseInt(this.barOptions.barHeight, 10)) / 100 / 2 + n * (this.visibleI + c.indexOf(h)) + r * u), {
                                    barYPosition: a,
                                    barHeight: n
                                }
                            }
                        }, {
                            key: "drawRangeColumnPaths",
                            value: function(t) {
                                var e = t.indexes,
                                    i = t.x;
                                t.strokeWidth;
                                var a = t.xDivision,
                                    s = t.barWidth,
                                    n = t.zeroH,
                                    r = this.w,
                                    o = e.i,
                                    l = e.j,
                                    c = this.yRatio[this.yaxisIndex],
                                    h = e.realIndex,
                                    d = this.getRangeValue(h, l),
                                    u = Math.min(d.start, d.end),
                                    p = Math.max(d.start, d.end);
                                r.globals.isXNumeric && (i = (r.globals.seriesX[o][l] - r.globals.minX) / this.xRatio - s / 2);
                                var g = i + s * this.visibleI;
                                void 0 === this.series[o][l] || null === this.series[o][l] ? u = n : (u = n - u / c, p = n - p / c);
                                var f = Math.abs(p - u),
                                    m = this.barHelpers.getColumnPaths({
                                        barXPosition: g,
                                        barWidth: s,
                                        y1: u,
                                        y2: p,
                                        strokeWidth: this.strokeWidth,
                                        series: this.seriesRangeEnd,
                                        realIndex: e.realIndex,
                                        i: h,
                                        j: l,
                                        w: r
                                    });
                                return r.globals.isXNumeric || (i += a), {
                                    pathTo: m.pathTo,
                                    pathFrom: m.pathFrom,
                                    barHeight: f,
                                    x: i,
                                    y: p,
                                    goalY: this.barHelpers.getGoalValues("y", null, n, o, l),
                                    barXPosition: g
                                }
                            }
                        }, {
                            key: "drawRangeBarPaths",
                            value: function(t) {
                                var e = t.indexes,
                                    i = t.y,
                                    a = t.y1,
                                    s = t.y2,
                                    n = t.yDivision,
                                    r = t.barHeight,
                                    o = t.barYPosition,
                                    l = t.zeroW,
                                    c = this.w,
                                    h = l + a / this.invertedYRatio,
                                    d = l + s / this.invertedYRatio,
                                    u = Math.abs(d - h),
                                    p = this.barHelpers.getBarpaths({
                                        barYPosition: o,
                                        barHeight: r,
                                        x1: h,
                                        x2: d,
                                        strokeWidth: this.strokeWidth,
                                        series: this.seriesRangeEnd,
                                        i: e.realIndex,
                                        realIndex: e.realIndex,
                                        j: e.j,
                                        w: c
                                    });
                                return c.globals.isXNumeric || (i += n), {
                                    pathTo: p.pathTo,
                                    pathFrom: p.pathFrom,
                                    barWidth: u,
                                    x: d,
                                    goalX: this.barHelpers.getGoalValues("x", l, null, e.realIndex, e.j),
                                    y: i
                                }
                            }
                        }, {
                            key: "getRangeValue",
                            value: function(t, e) {
                                var i = this.w;
                                return {
                                    start: i.globals.seriesRangeStart[t][e],
                                    end: i.globals.seriesRangeEnd[t][e]
                                }
                            }
                        }, {
                            key: "getTooltipValues",
                            value: function(t) {
                                var e = t.ctx,
                                    i = t.seriesIndex,
                                    a = t.dataPointIndex,
                                    s = t.y1,
                                    n = t.y2,
                                    r = t.w,
                                    o = r.globals.seriesRangeStart[i][a],
                                    l = r.globals.seriesRangeEnd[i][a],
                                    c = r.globals.labels[a],
                                    h = r.config.series[i].name ? r.config.series[i].name : "",
                                    d = r.config.tooltip.y.formatter,
                                    u = r.config.tooltip.y.title.formatter,
                                    p = {
                                        w: r,
                                        seriesIndex: i,
                                        dataPointIndex: a,
                                        start: o,
                                        end: l
                                    };
                                "function" == typeof u && (h = u(h, p)), Number.isFinite(s) && Number.isFinite(n) && (o = s, l = n, r.config.series[i].data[a].x && (c = r.config.series[i].data[a].x + ":"), "function" == typeof d && (c = d(c, p)));
                                var g = "",
                                    f = "",
                                    m = r.globals.colors[i];
                                if (void 0 === r.config.tooltip.x.formatter)
                                    if ("datetime" === r.config.xaxis.type) {
                                        var x = new F(e);
                                        g = x.formatDate(x.getDate(o), r.config.tooltip.x.format), f = x.formatDate(x.getDate(l), r.config.tooltip.x.format)
                                    } else g = o, f = l;
                                else g = r.config.tooltip.x.formatter(o), f = r.config.tooltip.x.formatter(l);
                                return {
                                    start: o,
                                    end: l,
                                    startVal: g,
                                    endVal: f,
                                    ylabel: c,
                                    color: m,
                                    seriesName: h
                                }
                            }
                        }, {
                            key: "buildCustomTooltipHTML",
                            value: function(t) {
                                return '<div class="apexcharts-tooltip-rangebar"><div> <span class="series-name" style="color: ' + t.color + '">' + (t.seriesName || "") + '</span></div><div> <span class="category">' + t.ylabel + ' </span> <span class="value start-value">' + t.start + '</span> <span class="separator">-</span> <span class="value end-value">' + t.end + "</span></div></div>"
                            }
                        }]), i
                    }(),
                    H = function() {
                        function t(e) {
                            o(this, t), this.opts = e
                        }
                        return c(t, [{
                            key: "line",
                            value: function() {
                                return {
                                    chart: {
                                        animations: {
                                            easing: "swing"
                                        }
                                    },
                                    dataLabels: {
                                        enabled: !1
                                    },
                                    stroke: {
                                        width: 5,
                                        curve: "straight"
                                    },
                                    markers: {
                                        size: 0,
                                        hover: {
                                            sizeOffset: 6
                                        }
                                    },
                                    xaxis: {
                                        crosshairs: {
                                            width: 1
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "sparkline",
                            value: function(t) {
                                return this.opts.yaxis[0].show = !1, this.opts.yaxis[0].title.text = "", this.opts.yaxis[0].axisBorder.show = !1, this.opts.yaxis[0].axisTicks.show = !1, this.opts.yaxis[0].floating = !0, b.extend(t, {
                                    grid: {
                                        show: !1,
                                        padding: {
                                            left: 0,
                                            right: 0,
                                            top: 0,
                                            bottom: 0
                                        }
                                    },
                                    legend: {
                                        show: !1
                                    },
                                    xaxis: {
                                        labels: {
                                            show: !1
                                        },
                                        tooltip: {
                                            enabled: !1
                                        },
                                        axisBorder: {
                                            show: !1
                                        },
                                        axisTicks: {
                                            show: !1
                                        }
                                    },
                                    chart: {
                                        toolbar: {
                                            show: !1
                                        },
                                        zoom: {
                                            enabled: !1
                                        }
                                    },
                                    dataLabels: {
                                        enabled: !1
                                    }
                                })
                            }
                        }, {
                            key: "bar",
                            value: function() {
                                return {
                                    chart: {
                                        stacked: !1,
                                        animations: {
                                            easing: "swing"
                                        }
                                    },
                                    plotOptions: {
                                        bar: {
                                            dataLabels: {
                                                position: "center"
                                            }
                                        }
                                    },
                                    dataLabels: {
                                        style: {
                                            colors: ["#fff"]
                                        },
                                        background: {
                                            enabled: !1
                                        }
                                    },
                                    stroke: {
                                        width: 0,
                                        lineCap: "round"
                                    },
                                    fill: {
                                        opacity: .85
                                    },
                                    legend: {
                                        markers: {
                                            shape: "square",
                                            radius: 2,
                                            size: 8
                                        }
                                    },
                                    tooltip: {
                                        shared: !1,
                                        intersect: !0
                                    },
                                    xaxis: {
                                        tooltip: {
                                            enabled: !1
                                        },
                                        tickPlacement: "between",
                                        crosshairs: {
                                            width: "barWidth",
                                            position: "back",
                                            fill: {
                                                type: "gradient"
                                            },
                                            dropShadow: {
                                                enabled: !1
                                            },
                                            stroke: {
                                                width: 0
                                            }
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "candlestick",
                            value: function() {
                                var t = this;
                                return {
                                    stroke: {
                                        width: 1,
                                        colors: ["#333"]
                                    },
                                    fill: {
                                        opacity: 1
                                    },
                                    dataLabels: {
                                        enabled: !1
                                    },
                                    tooltip: {
                                        shared: !0,
                                        custom: function(e) {
                                            var i = e.seriesIndex,
                                                a = e.dataPointIndex,
                                                s = e.w;
                                            return t._getBoxTooltip(s, i, a, ["Open", "High", "", "Low", "Close"], "candlestick")
                                        }
                                    },
                                    states: {
                                        active: {
                                            filter: {
                                                type: "none"
                                            }
                                        }
                                    },
                                    xaxis: {
                                        crosshairs: {
                                            width: 1
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "boxPlot",
                            value: function() {
                                var t = this;
                                return {
                                    chart: {
                                        animations: {
                                            dynamicAnimation: {
                                                enabled: !1
                                            }
                                        }
                                    },
                                    stroke: {
                                        width: 1,
                                        colors: ["#24292e"]
                                    },
                                    dataLabels: {
                                        enabled: !1
                                    },
                                    tooltip: {
                                        shared: !0,
                                        custom: function(e) {
                                            var i = e.seriesIndex,
                                                a = e.dataPointIndex,
                                                s = e.w;
                                            return t._getBoxTooltip(s, i, a, ["Minimum", "Q1", "Median", "Q3", "Maximum"], "boxPlot")
                                        }
                                    },
                                    markers: {
                                        size: 5,
                                        strokeWidth: 1,
                                        strokeColors: "#111"
                                    },
                                    xaxis: {
                                        crosshairs: {
                                            width: 1
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "rangeBar",
                            value: function() {
                                return {
                                    stroke: {
                                        width: 0,
                                        lineCap: "square"
                                    },
                                    plotOptions: {
                                        bar: {
                                            borderRadius: 0,
                                            dataLabels: {
                                                position: "center"
                                            }
                                        }
                                    },
                                    dataLabels: {
                                        enabled: !1,
                                        formatter: function(t, e) {
                                            e.ctx;
                                            var i = e.seriesIndex,
                                                a = e.dataPointIndex,
                                                s = e.w,
                                                n = s.globals.seriesRangeStart[i][a];
                                            return s.globals.seriesRangeEnd[i][a] - n
                                        },
                                        background: {
                                            enabled: !1
                                        },
                                        style: {
                                            colors: ["#fff"]
                                        }
                                    },
                                    tooltip: {
                                        shared: !1,
                                        followCursor: !0,
                                        custom: function(t) {
                                            return t.w.config.plotOptions && t.w.config.plotOptions.bar && t.w.config.plotOptions.bar.horizontal ? function(t) {
                                                var e = new R(t.ctx, null),
                                                    i = e.getTooltipValues(t),
                                                    a = i.color,
                                                    s = i.seriesName,
                                                    n = i.ylabel,
                                                    r = i.startVal,
                                                    o = i.endVal;
                                                return e.buildCustomTooltipHTML({
                                                    color: a,
                                                    seriesName: s,
                                                    ylabel: n,
                                                    start: r,
                                                    end: o
                                                })
                                            }(t) : function(t) {
                                                var e = new R(t.ctx, null),
                                                    i = e.getTooltipValues(t),
                                                    a = i.color,
                                                    s = i.seriesName,
                                                    n = i.ylabel,
                                                    r = i.start,
                                                    o = i.end;
                                                return e.buildCustomTooltipHTML({
                                                    color: a,
                                                    seriesName: s,
                                                    ylabel: n,
                                                    start: r,
                                                    end: o
                                                })
                                            }(t)
                                        }
                                    },
                                    xaxis: {
                                        tickPlacement: "between",
                                        tooltip: {
                                            enabled: !1
                                        },
                                        crosshairs: {
                                            stroke: {
                                                width: 0
                                            }
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "area",
                            value: function() {
                                return {
                                    stroke: {
                                        width: 4,
                                        fill: {
                                            type: "solid",
                                            gradient: {
                                                inverseColors: !1,
                                                shade: "light",
                                                type: "vertical",
                                                opacityFrom: .65,
                                                opacityTo: .5,
                                                stops: [0, 100, 100]
                                            }
                                        }
                                    },
                                    fill: {
                                        type: "gradient",
                                        gradient: {
                                            inverseColors: !1,
                                            shade: "light",
                                            type: "vertical",
                                            opacityFrom: .65,
                                            opacityTo: .5,
                                            stops: [0, 100, 100]
                                        }
                                    },
                                    markers: {
                                        size: 0,
                                        hover: {
                                            sizeOffset: 6
                                        }
                                    },
                                    tooltip: {
                                        followCursor: !1
                                    }
                                }
                            }
                        }, {
                            key: "brush",
                            value: function(t) {
                                return b.extend(t, {
                                    chart: {
                                        toolbar: {
                                            autoSelected: "selection",
                                            show: !1
                                        },
                                        zoom: {
                                            enabled: !1
                                        }
                                    },
                                    dataLabels: {
                                        enabled: !1
                                    },
                                    stroke: {
                                        width: 1
                                    },
                                    tooltip: {
                                        enabled: !1
                                    },
                                    xaxis: {
                                        tooltip: {
                                            enabled: !1
                                        }
                                    }
                                })
                            }
                        }, {
                            key: "stacked100",
                            value: function(t) {
                                t.dataLabels = t.dataLabels || {}, t.dataLabels.formatter = t.dataLabels.formatter || void 0;
                                var e = t.dataLabels.formatter;
                                return t.yaxis.forEach((function(e, i) {
                                    t.yaxis[i].min = 0, t.yaxis[i].max = 100
                                })), "bar" === t.chart.type && (t.dataLabels.formatter = e || function(t) {
                                    return "number" == typeof t && t ? t.toFixed(0) + "%" : t
                                }), t
                            }
                        }, {
                            key: "convertCatToNumeric",
                            value: function(t) {
                                return t.xaxis.convertedCatToNumeric = !0, t
                            }
                        }, {
                            key: "convertCatToNumericXaxis",
                            value: function(t, e, i) {
                                t.xaxis.type = "numeric", t.xaxis.labels = t.xaxis.labels || {}, t.xaxis.labels.formatter = t.xaxis.labels.formatter || function(t) {
                                    return b.isNumber(t) ? Math.floor(t) : t
                                };
                                var a = t.xaxis.labels.formatter,
                                    s = t.xaxis.categories && t.xaxis.categories.length ? t.xaxis.categories : t.labels;
                                return i && i.length && (s = i.map((function(t) {
                                    return Array.isArray(t) ? t : String(t)
                                }))), s && s.length && (t.xaxis.labels.formatter = function(t) {
                                    return b.isNumber(t) ? a(s[Math.floor(t) - 1]) : a(t)
                                }), t.xaxis.categories = [], t.labels = [], t.xaxis.tickAmount = t.xaxis.tickAmount || "dataPoints", t
                            }
                        }, {
                            key: "bubble",
                            value: function() {
                                return {
                                    dataLabels: {
                                        style: {
                                            colors: ["#fff"]
                                        }
                                    },
                                    tooltip: {
                                        shared: !1,
                                        intersect: !0
                                    },
                                    xaxis: {
                                        crosshairs: {
                                            width: 0
                                        }
                                    },
                                    fill: {
                                        type: "solid",
                                        gradient: {
                                            shade: "light",
                                            inverse: !0,
                                            shadeIntensity: .55,
                                            opacityFrom: .4,
                                            opacityTo: .8
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "scatter",
                            value: function() {
                                return {
                                    dataLabels: {
                                        enabled: !1
                                    },
                                    tooltip: {
                                        shared: !1,
                                        intersect: !0
                                    },
                                    markers: {
                                        size: 6,
                                        strokeWidth: 1,
                                        hover: {
                                            sizeOffset: 2
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "heatmap",
                            value: function() {
                                return {
                                    chart: {
                                        stacked: !1
                                    },
                                    fill: {
                                        opacity: 1
                                    },
                                    dataLabels: {
                                        style: {
                                            colors: ["#fff"]
                                        }
                                    },
                                    stroke: {
                                        colors: ["#fff"]
                                    },
                                    tooltip: {
                                        followCursor: !0,
                                        marker: {
                                            show: !1
                                        },
                                        x: {
                                            show: !1
                                        }
                                    },
                                    legend: {
                                        position: "top",
                                        markers: {
                                            shape: "square",
                                            size: 10,
                                            offsetY: 2
                                        }
                                    },
                                    grid: {
                                        padding: {
                                            right: 20
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "treemap",
                            value: function() {
                                return {
                                    chart: {
                                        zoom: {
                                            enabled: !1
                                        }
                                    },
                                    dataLabels: {
                                        style: {
                                            fontSize: 14,
                                            fontWeight: 600,
                                            colors: ["#fff"]
                                        }
                                    },
                                    stroke: {
                                        show: !0,
                                        width: 2,
                                        colors: ["#fff"]
                                    },
                                    legend: {
                                        show: !1
                                    },
                                    fill: {
                                        gradient: {
                                            stops: [0, 100]
                                        }
                                    },
                                    tooltip: {
                                        followCursor: !0,
                                        x: {
                                            show: !1
                                        }
                                    },
                                    grid: {
                                        padding: {
                                            left: 0,
                                            right: 0
                                        }
                                    },
                                    xaxis: {
                                        crosshairs: {
                                            show: !1
                                        },
                                        tooltip: {
                                            enabled: !1
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "pie",
                            value: function() {
                                return {
                                    chart: {
                                        toolbar: {
                                            show: !1
                                        }
                                    },
                                    plotOptions: {
                                        pie: {
                                            donut: {
                                                labels: {
                                                    show: !1
                                                }
                                            }
                                        }
                                    },
                                    dataLabels: {
                                        formatter: function(t) {
                                            return t.toFixed(1) + "%"
                                        },
                                        style: {
                                            colors: ["#fff"]
                                        },
                                        background: {
                                            enabled: !1
                                        },
                                        dropShadow: {
                                            enabled: !0
                                        }
                                    },
                                    stroke: {
                                        colors: ["#fff"]
                                    },
                                    fill: {
                                        opacity: 1,
                                        gradient: {
                                            shade: "light",
                                            stops: [0, 100]
                                        }
                                    },
                                    tooltip: {
                                        theme: "dark",
                                        fillSeriesColor: !0
                                    },
                                    legend: {
                                        position: "right"
                                    }
                                }
                            }
                        }, {
                            key: "donut",
                            value: function() {
                                return {
                                    chart: {
                                        toolbar: {
                                            show: !1
                                        }
                                    },
                                    dataLabels: {
                                        formatter: function(t) {
                                            return t.toFixed(1) + "%"
                                        },
                                        style: {
                                            colors: ["#fff"]
                                        },
                                        background: {
                                            enabled: !1
                                        },
                                        dropShadow: {
                                            enabled: !0
                                        }
                                    },
                                    stroke: {
                                        colors: ["#fff"]
                                    },
                                    fill: {
                                        opacity: 1,
                                        gradient: {
                                            shade: "light",
                                            shadeIntensity: .35,
                                            stops: [80, 100],
                                            opacityFrom: 1,
                                            opacityTo: 1
                                        }
                                    },
                                    tooltip: {
                                        theme: "dark",
                                        fillSeriesColor: !0
                                    },
                                    legend: {
                                        position: "right"
                                    }
                                }
                            }
                        }, {
                            key: "polarArea",
                            value: function() {
                                return this.opts.yaxis[0].tickAmount = this.opts.yaxis[0].tickAmount ? this.opts.yaxis[0].tickAmount : 6, {
                                    chart: {
                                        toolbar: {
                                            show: !1
                                        }
                                    },
                                    dataLabels: {
                                        formatter: function(t) {
                                            return t.toFixed(1) + "%"
                                        },
                                        enabled: !1
                                    },
                                    stroke: {
                                        show: !0,
                                        width: 2
                                    },
                                    fill: {
                                        opacity: .7
                                    },
                                    tooltip: {
                                        theme: "dark",
                                        fillSeriesColor: !0
                                    },
                                    legend: {
                                        position: "right"
                                    }
                                }
                            }
                        }, {
                            key: "radar",
                            value: function() {
                                return this.opts.yaxis[0].labels.offsetY = this.opts.yaxis[0].labels.offsetY ? this.opts.yaxis[0].labels.offsetY : 6, {
                                    dataLabels: {
                                        enabled: !1,
                                        style: {
                                            fontSize: "11px"
                                        }
                                    },
                                    stroke: {
                                        width: 2
                                    },
                                    markers: {
                                        size: 3,
                                        strokeWidth: 1,
                                        strokeOpacity: 1
                                    },
                                    fill: {
                                        opacity: .2
                                    },
                                    tooltip: {
                                        shared: !1,
                                        intersect: !0,
                                        followCursor: !0
                                    },
                                    grid: {
                                        show: !1
                                    },
                                    xaxis: {
                                        labels: {
                                            formatter: function(t) {
                                                return t
                                            },
                                            style: {
                                                colors: ["#a8a8a8"],
                                                fontSize: "11px"
                                            }
                                        },
                                        tooltip: {
                                            enabled: !1
                                        },
                                        crosshairs: {
                                            show: !1
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "radialBar",
                            value: function() {
                                return {
                                    chart: {
                                        animations: {
                                            dynamicAnimation: {
                                                enabled: !0,
                                                speed: 800
                                            }
                                        },
                                        toolbar: {
                                            show: !1
                                        }
                                    },
                                    fill: {
                                        gradient: {
                                            shade: "dark",
                                            shadeIntensity: .4,
                                            inverseColors: !1,
                                            type: "diagonal2",
                                            opacityFrom: 1,
                                            opacityTo: 1,
                                            stops: [70, 98, 100]
                                        }
                                    },
                                    legend: {
                                        show: !1,
                                        position: "right"
                                    },
                                    tooltip: {
                                        enabled: !1,
                                        fillSeriesColor: !0
                                    }
                                }
                            }
                        }, {
                            key: "_getBoxTooltip",
                            value: function(t, e, i, a, s) {
                                var n = t.globals.seriesCandleO[e][i],
                                    r = t.globals.seriesCandleH[e][i],
                                    o = t.globals.seriesCandleM[e][i],
                                    l = t.globals.seriesCandleL[e][i],
                                    c = t.globals.seriesCandleC[e][i];
                                return t.config.series[e].type && t.config.series[e].type !== s ? '<div class="apexcharts-custom-tooltip">\n          '.concat(t.config.series[e].name ? t.config.series[e].name : "series-" + (e + 1), ": <strong>").concat(t.globals.series[e][i], "</strong>\n        </div>") : '<div class="apexcharts-tooltip-box apexcharts-tooltip-'.concat(t.config.chart.type, '">') + "<div>".concat(a[0], ': <span class="value">') + n + "</span></div>" + "<div>".concat(a[1], ': <span class="value">') + r + "</span></div>" + (o ? "<div>".concat(a[2], ': <span class="value">') + o + "</span></div>" : "") + "<div>".concat(a[3], ': <span class="value">') + l + "</span></div>" + "<div>".concat(a[4], ': <span class="value">') + c + "</span></div></div>"
                            }
                        }]), t
                    }(),
                    W = function() {
                        function t(e) {
                            o(this, t), this.opts = e
                        }
                        return c(t, [{
                            key: "init",
                            value: function(t) {
                                var e = t.responsiveOverride,
                                    i = this.opts,
                                    a = new M,
                                    s = new H(i);
                                this.chartType = i.chart.type, "histogram" === this.chartType && (i.chart.type = "bar", i = b.extend({
                                    plotOptions: {
                                        bar: {
                                            columnWidth: "99.99%"
                                        }
                                    }
                                }, i)), i = this.extendYAxis(i), i = this.extendAnnotations(i);
                                var n = a.init(),
                                    o = {};
                                if (i && "object" === r(i)) {
                                    var l = {};
                                    l = -1 !== ["line", "area", "bar", "candlestick", "boxPlot", "rangeBar", "histogram", "bubble", "scatter", "heatmap", "treemap", "pie", "polarArea", "donut", "radar", "radialBar"].indexOf(i.chart.type) ? s[i.chart.type]() : s.line(), i.chart.brush && i.chart.brush.enabled && (l = s.brush(l)), i.chart.stacked && "100%" === i.chart.stackType && (i = s.stacked100(i)), this.checkForDarkTheme(window.Apex), this.checkForDarkTheme(i), i.xaxis = i.xaxis || window.Apex.xaxis || {}, e || (i.xaxis.convertedCatToNumeric = !1), ((i = this.checkForCatToNumericXAxis(this.chartType, l, i)).chart.sparkline && i.chart.sparkline.enabled || window.Apex.chart && window.Apex.chart.sparkline && window.Apex.chart.sparkline.enabled) && (l = s.sparkline(l)), o = b.extend(n, l)
                                }
                                var c = b.extend(o, window.Apex);
                                return n = b.extend(c, i), this.handleUserInputErrors(n)
                            }
                        }, {
                            key: "checkForCatToNumericXAxis",
                            value: function(t, e, i) {
                                var a = new H(i),
                                    s = ("bar" === t || "boxPlot" === t) && i.plotOptions && i.plotOptions.bar && i.plotOptions.bar.horizontal,
                                    n = "pie" === t || "polarArea" === t || "donut" === t || "radar" === t || "radialBar" === t || "heatmap" === t,
                                    r = "datetime" !== i.xaxis.type && "numeric" !== i.xaxis.type,
                                    o = i.xaxis.tickPlacement ? i.xaxis.tickPlacement : e.xaxis && e.xaxis.tickPlacement;
                                return s || n || !r || "between" === o || (i = a.convertCatToNumeric(i)), i
                            }
                        }, {
                            key: "extendYAxis",
                            value: function(t, e) {
                                var i = new M;
                                (void 0 === t.yaxis || !t.yaxis || Array.isArray(t.yaxis) && 0 === t.yaxis.length) && (t.yaxis = {}), t.yaxis.constructor !== Array && window.Apex.yaxis && window.Apex.yaxis.constructor !== Array && (t.yaxis = b.extend(t.yaxis, window.Apex.yaxis)), t.yaxis.constructor !== Array ? t.yaxis = [b.extend(i.yAxis, t.yaxis)] : t.yaxis = b.extendArray(t.yaxis, i.yAxis);
                                var a = !1;
                                t.yaxis.forEach((function(t) {
                                    t.logarithmic && (a = !0)
                                }));
                                var s = t.series;
                                return e && !s && (s = e.config.series), a && s.length !== t.yaxis.length && s.length && (t.yaxis = s.map((function(e, a) {
                                    if (e.name || (s[a].name = "series-".concat(a + 1)), t.yaxis[a]) return t.yaxis[a].seriesName = s[a].name, t.yaxis[a];
                                    var n = b.extend(i.yAxis, t.yaxis[0]);
                                    return n.show = !1, n
                                }))), a && s.length > 1 && s.length !== t.yaxis.length && console.warn("A multi-series logarithmic chart should have equal number of series and y-axes. Please make sure to equalize both."), t
                            }
                        }, {
                            key: "extendAnnotations",
                            value: function(t) {
                                return void 0 === t.annotations && (t.annotations = {}, t.annotations.yaxis = [], t.annotations.xaxis = [], t.annotations.points = []), t = this.extendYAxisAnnotations(t), t = this.extendXAxisAnnotations(t), this.extendPointAnnotations(t)
                            }
                        }, {
                            key: "extendYAxisAnnotations",
                            value: function(t) {
                                var e = new M;
                                return t.annotations.yaxis = b.extendArray(void 0 !== t.annotations.yaxis ? t.annotations.yaxis : [], e.yAxisAnnotation), t
                            }
                        }, {
                            key: "extendXAxisAnnotations",
                            value: function(t) {
                                var e = new M;
                                return t.annotations.xaxis = b.extendArray(void 0 !== t.annotations.xaxis ? t.annotations.xaxis : [], e.xAxisAnnotation), t
                            }
                        }, {
                            key: "extendPointAnnotations",
                            value: function(t) {
                                var e = new M;
                                return t.annotations.points = b.extendArray(void 0 !== t.annotations.points ? t.annotations.points : [], e.pointAnnotation), t
                            }
                        }, {
                            key: "checkForDarkTheme",
                            value: function(t) {
                                t.theme && "dark" === t.theme.mode && (t.tooltip || (t.tooltip = {}), "light" !== t.tooltip.theme && (t.tooltip.theme = "dark"), t.chart.foreColor || (t.chart.foreColor = "#f6f7f8"), t.chart.background || (t.chart.background = "#424242"), t.theme.palette || (t.theme.palette = "palette4"))
                            }
                        }, {
                            key: "handleUserInputErrors",
                            value: function(t) {
                                var e = t;
                                if (e.tooltip.shared && e.tooltip.intersect) throw new Error("tooltip.shared cannot be enabled when tooltip.intersect is true. Turn off any other option by setting it to false.");
                                if ("bar" === e.chart.type && e.plotOptions.bar.horizontal) {
                                    if (e.yaxis.length > 1) throw new Error("Multiple Y Axis for bars are not supported. Switch to column chart by setting plotOptions.bar.horizontal=false");
                                    e.yaxis[0].reversed && (e.yaxis[0].opposite = !0), e.xaxis.tooltip.enabled = !1, e.yaxis[0].tooltip.enabled = !1, e.chart.zoom.enabled = !1
                                }
                                return "bar" !== e.chart.type && "rangeBar" !== e.chart.type || e.tooltip.shared && "barWidth" === e.xaxis.crosshairs.width && e.series.length > 1 && (e.xaxis.crosshairs.width = "tickWidth"), "candlestick" !== e.chart.type && "boxPlot" !== e.chart.type || e.yaxis[0].reversed && (console.warn("Reversed y-axis in ".concat(e.chart.type, " chart is not supported.")), e.yaxis[0].reversed = !1), e
                            }
                        }]), t
                    }(),
                    B = function() {
                        function t() {
                            o(this, t)
                        }
                        return c(t, [{
                            key: "initGlobalVars",
                            value: function(t) {
                                t.series = [], t.seriesCandleO = [], t.seriesCandleH = [], t.seriesCandleM = [], t.seriesCandleL = [], t.seriesCandleC = [], t.seriesRangeStart = [], t.seriesRangeEnd = [], t.seriesRangeBar = [], t.seriesPercent = [], t.seriesGoals = [], t.seriesX = [], t.seriesZ = [], t.seriesNames = [], t.seriesTotals = [], t.seriesLog = [], t.seriesColors = [], t.stackedSeriesTotals = [], t.seriesXvalues = [], t.seriesYvalues = [], t.labels = [], t.hasGroups = !1, t.groups = [], t.categoryLabels = [], t.timescaleLabels = [], t.noLabelsProvided = !1, t.resizeTimer = null, t.selectionResizeTimer = null, t.delayedElements = [], t.pointsArray = [], t.dataLabelsRects = [], t.isXNumeric = !1, t.xaxisLabelsCount = 0, t.skipLastTimelinelabel = !1, t.skipFirstTimelinelabel = !1, t.isDataXYZ = !1, t.isMultiLineX = !1, t.isMultipleYAxis = !1, t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE, t.minYArr = [], t.maxYArr = [], t.maxX = -Number.MAX_VALUE, t.minX = Number.MAX_VALUE, t.initialMaxX = -Number.MAX_VALUE, t.initialMinX = Number.MAX_VALUE, t.maxDate = 0, t.minDate = Number.MAX_VALUE, t.minZ = Number.MAX_VALUE, t.maxZ = -Number.MAX_VALUE, t.minXDiff = Number.MAX_VALUE, t.yAxisScale = [], t.xAxisScale = null, t.xAxisTicksPositions = [], t.yLabelsCoords = [], t.yTitleCoords = [], t.barPadForNumericAxis = 0, t.padHorizontal = 0, t.xRange = 0, t.yRange = [], t.zRange = 0, t.dataPoints = 0, t.xTickAmount = 0
                            }
                        }, {
                            key: "globalVars",
                            value: function(t) {
                                return {
                                    chartID: null,
                                    cuid: null,
                                    events: {
                                        beforeMount: [],
                                        mounted: [],
                                        updated: [],
                                        clicked: [],
                                        selection: [],
                                        dataPointSelection: [],
                                        zoomed: [],
                                        scrolled: []
                                    },
                                    colors: [],
                                    clientX: null,
                                    clientY: null,
                                    fill: {
                                        colors: []
                                    },
                                    stroke: {
                                        colors: []
                                    },
                                    dataLabels: {
                                        style: {
                                            colors: []
                                        }
                                    },
                                    radarPolygons: {
                                        fill: {
                                            colors: []
                                        }
                                    },
                                    markers: {
                                        colors: [],
                                        size: t.markers.size,
                                        largestSize: 0
                                    },
                                    animationEnded: !1,
                                    isTouchDevice: "ontouchstart" in window || navigator.msMaxTouchPoints,
                                    isDirty: !1,
                                    isExecCalled: !1,
                                    initialConfig: null,
                                    initialSeries: [],
                                    lastXAxis: [],
                                    lastYAxis: [],
                                    columnSeries: null,
                                    labels: [],
                                    timescaleLabels: [],
                                    noLabelsProvided: !1,
                                    allSeriesCollapsed: !1,
                                    collapsedSeries: [],
                                    collapsedSeriesIndices: [],
                                    ancillaryCollapsedSeries: [],
                                    ancillaryCollapsedSeriesIndices: [],
                                    risingSeries: [],
                                    dataFormatXNumeric: !1,
                                    capturedSeriesIndex: -1,
                                    capturedDataPointIndex: -1,
                                    selectedDataPoints: [],
                                    goldenPadding: 35,
                                    invalidLogScale: !1,
                                    ignoreYAxisIndexes: [],
                                    yAxisSameScaleIndices: [],
                                    maxValsInArrayIndex: 0,
                                    radialSize: 0,
                                    selection: void 0,
                                    zoomEnabled: "zoom" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.zoom && t.chart.zoom.enabled,
                                    panEnabled: "pan" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.pan,
                                    selectionEnabled: "selection" === t.chart.toolbar.autoSelected && t.chart.toolbar.tools.selection,
                                    yaxis: null,
                                    mousedown: !1,
                                    lastClientPosition: {},
                                    visibleXRange: void 0,
                                    yValueDecimal: 0,
                                    total: 0,
                                    SVGNS: "http://www.w3.org/2000/svg",
                                    svgWidth: 0,
                                    svgHeight: 0,
                                    noData: !1,
                                    locale: {},
                                    dom: {},
                                    memory: {
                                        methodsToExec: []
                                    },
                                    shouldAnimate: !0,
                                    skipLastTimelinelabel: !1,
                                    skipFirstTimelinelabel: !1,
                                    delayedElements: [],
                                    axisCharts: !0,
                                    isDataXYZ: !1,
                                    resized: !1,
                                    resizeTimer: null,
                                    comboCharts: !1,
                                    dataChanged: !1,
                                    previousPaths: [],
                                    allSeriesHasEqualX: !0,
                                    pointsArray: [],
                                    dataLabelsRects: [],
                                    lastDrawnDataLabelsIndexes: [],
                                    hasNullValues: !1,
                                    easing: null,
                                    zoomed: !1,
                                    gridWidth: 0,
                                    gridHeight: 0,
                                    rotateXLabels: !1,
                                    defaultLabels: !1,
                                    xLabelFormatter: void 0,
                                    yLabelFormatters: [],
                                    xaxisTooltipFormatter: void 0,
                                    ttKeyFormatter: void 0,
                                    ttVal: void 0,
                                    ttZFormatter: void 0,
                                    LINE_HEIGHT_RATIO: 1.618,
                                    xAxisLabelsHeight: 0,
                                    xAxisGroupLabelsHeight: 0,
                                    xAxisLabelsWidth: 0,
                                    yAxisLabelsWidth: 0,
                                    scaleX: 1,
                                    scaleY: 1,
                                    translateX: 0,
                                    translateY: 0,
                                    translateYAxisX: [],
                                    yAxisWidths: [],
                                    translateXAxisY: 0,
                                    translateXAxisX: 0,
                                    tooltip: null
                                }
                            }
                        }, {
                            key: "init",
                            value: function(t) {
                                var e = this.globalVars(t);
                                return this.initGlobalVars(e), e.initialConfig = b.extend({}, t), e.initialSeries = b.clone(t.series), e.lastXAxis = b.clone(e.initialConfig.xaxis), e.lastYAxis = b.clone(e.initialConfig.yaxis), e
                            }
                        }]), t
                    }(),
                    $ = function() {
                        function t(e) {
                            o(this, t), this.opts = e
                        }
                        return c(t, [{
                            key: "init",
                            value: function() {
                                var t = new W(this.opts).init({
                                    responsiveOverride: !1
                                });
                                return {
                                    config: t,
                                    globals: (new B).init(t)
                                }
                            }
                        }]), t
                    }(),
                    G = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.twoDSeries = [], this.threeDSeries = [], this.twoDSeriesX = [], this.seriesGoals = [], this.coreUtils = new C(this.ctx)
                        }
                        return c(t, [{
                            key: "isMultiFormat",
                            value: function() {
                                return this.isFormatXY() || this.isFormat2DArray()
                            }
                        }, {
                            key: "isFormatXY",
                            value: function() {
                                var t = this.w.config.series.slice(),
                                    e = new O(this.ctx);
                                if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && null !== t[this.activeSeriesIndex].data[0] && void 0 !== t[this.activeSeriesIndex].data[0].x && null !== t[this.activeSeriesIndex].data[0]) return !0
                            }
                        }, {
                            key: "isFormat2DArray",
                            value: function() {
                                var t = this.w.config.series.slice(),
                                    e = new O(this.ctx);
                                if (this.activeSeriesIndex = e.getActiveConfigSeriesIndex(), void 0 !== t[this.activeSeriesIndex].data && t[this.activeSeriesIndex].data.length > 0 && void 0 !== t[this.activeSeriesIndex].data[0] && null !== t[this.activeSeriesIndex].data[0] && t[this.activeSeriesIndex].data[0].constructor === Array) return !0
                            }
                        }, {
                            key: "handleFormat2DArray",
                            value: function(t, e) {
                                for (var i = this.w.config, a = this.w.globals, s = "boxPlot" === i.chart.type || "boxPlot" === i.series[e].type, n = 0; n < t[e].data.length; n++)
                                    if (void 0 !== t[e].data[n][1] && (Array.isArray(t[e].data[n][1]) && 4 === t[e].data[n][1].length && !s ? this.twoDSeries.push(b.parseNumber(t[e].data[n][1][3])) : t[e].data[n].length >= 5 ? this.twoDSeries.push(b.parseNumber(t[e].data[n][4])) : this.twoDSeries.push(b.parseNumber(t[e].data[n][1])), a.dataFormatXNumeric = !0), "datetime" === i.xaxis.type) {
                                        var r = new Date(t[e].data[n][0]);
                                        r = new Date(r).getTime(), this.twoDSeriesX.push(r)
                                    } else this.twoDSeriesX.push(t[e].data[n][0]);
                                for (var o = 0; o < t[e].data.length; o++) void 0 !== t[e].data[o][2] && (this.threeDSeries.push(t[e].data[o][2]), a.isDataXYZ = !0)
                            }
                        }, {
                            key: "handleFormatXY",
                            value: function(t, e) {
                                var i = this.w.config,
                                    a = this.w.globals,
                                    s = new F(this.ctx),
                                    n = e;
                                a.collapsedSeriesIndices.indexOf(e) > -1 && (n = this.activeSeriesIndex);
                                for (var r = 0; r < t[e].data.length; r++) void 0 !== t[e].data[r].y && (Array.isArray(t[e].data[r].y) ? this.twoDSeries.push(b.parseNumber(t[e].data[r].y[t[e].data[r].y.length - 1])) : this.twoDSeries.push(b.parseNumber(t[e].data[r].y))), void 0 !== t[e].data[r].goals && Array.isArray(t[e].data[r].goals) ? (void 0 === this.seriesGoals[e] && (this.seriesGoals[e] = []), this.seriesGoals[e].push(t[e].data[r].goals)) : (void 0 === this.seriesGoals[e] && (this.seriesGoals[e] = []), this.seriesGoals[e].push(null));
                                for (var o = 0; o < t[n].data.length; o++) {
                                    var l = "string" == typeof t[n].data[o].x,
                                        c = Array.isArray(t[n].data[o].x),
                                        h = !c && !!s.isValidDate(t[n].data[o].x.toString());
                                    if (l || h)
                                        if (l || i.xaxis.convertedCatToNumeric) {
                                            var d = a.isBarHorizontal && a.isRangeData;
                                            "datetime" !== i.xaxis.type || d ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[n].data[o].x)) : this.twoDSeriesX.push(s.parseDate(t[n].data[o].x))
                                        } else "datetime" === i.xaxis.type ? this.twoDSeriesX.push(s.parseDate(t[n].data[o].x.toString())) : (a.dataFormatXNumeric = !0, a.isXNumeric = !0, this.twoDSeriesX.push(parseFloat(t[n].data[o].x)));
                                    else c ? (this.fallbackToCategory = !0, this.twoDSeriesX.push(t[n].data[o].x)) : (a.isXNumeric = !0, a.dataFormatXNumeric = !0, this.twoDSeriesX.push(t[n].data[o].x))
                                }
                                if (t[e].data[0] && void 0 !== t[e].data[0].z) {
                                    for (var u = 0; u < t[e].data.length; u++) this.threeDSeries.push(t[e].data[u].z);
                                    a.isDataXYZ = !0
                                }
                            }
                        }, {
                            key: "handleRangeData",
                            value: function(t, e) {
                                var i = this.w.globals,
                                    a = {};
                                return this.isFormat2DArray() ? a = this.handleRangeDataFormat("array", t, e) : this.isFormatXY() && (a = this.handleRangeDataFormat("xy", t, e)), i.seriesRangeStart.push(a.start), i.seriesRangeEnd.push(a.end), i.seriesRangeBar.push(a.rangeUniques), i.seriesRangeBar.forEach((function(t, e) {
                                    t && t.forEach((function(t, e) {
                                        t.y.forEach((function(e, i) {
                                            for (var a = 0; a < t.y.length; a++)
                                                if (i !== a) {
                                                    var s = e.y1,
                                                        n = e.y2,
                                                        r = t.y[a].y1;
                                                    s <= t.y[a].y2 && r <= n && (t.overlaps.indexOf(e.rangeName) < 0 && t.overlaps.push(e.rangeName), t.overlaps.indexOf(t.y[a].rangeName) < 0 && t.overlaps.push(t.y[a].rangeName))
                                                }
                                        }))
                                    }))
                                })), a
                            }
                        }, {
                            key: "handleCandleStickBoxData",
                            value: function(t, e) {
                                var i = this.w.globals,
                                    a = {};
                                return this.isFormat2DArray() ? a = this.handleCandleStickBoxDataFormat("array", t, e) : this.isFormatXY() && (a = this.handleCandleStickBoxDataFormat("xy", t, e)), i.seriesCandleO[e] = a.o, i.seriesCandleH[e] = a.h, i.seriesCandleM[e] = a.m, i.seriesCandleL[e] = a.l, i.seriesCandleC[e] = a.c, a
                            }
                        }, {
                            key: "handleRangeDataFormat",
                            value: function(t, e, i) {
                                var a = [],
                                    s = [],
                                    n = e[i].data.filter((function(t, e, i) {
                                        return e === i.findIndex((function(e) {
                                            return e.x === t.x
                                        }))
                                    })).map((function(t, e) {
                                        return {
                                            x: t.x,
                                            overlaps: [],
                                            y: []
                                        }
                                    })),
                                    r = "Please provide [Start, End] values in valid format. Read more https://apexcharts.com/docs/series/#rangecharts",
                                    o = new O(this.ctx).getActiveConfigSeriesIndex();
                                if ("array" === t) {
                                    if (2 !== e[o].data[0][1].length) throw new Error(r);
                                    for (var l = 0; l < e[i].data.length; l++) a.push(e[i].data[l][1][0]), s.push(e[i].data[l][1][1])
                                } else if ("xy" === t) {
                                    if (2 !== e[o].data[0].y.length) throw new Error(r);
                                    for (var c = function(t) {
                                            var r = b.randomId(),
                                                o = e[i].data[t].x,
                                                l = {
                                                    y1: e[i].data[t].y[0],
                                                    y2: e[i].data[t].y[1],
                                                    rangeName: r
                                                };
                                            e[i].data[t].rangeName = r;
                                            var c = n.findIndex((function(t) {
                                                return t.x === o
                                            }));
                                            n[c].y.push(l), a.push(l.y1), s.push(l.y2)
                                        }, h = 0; h < e[i].data.length; h++) c(h)
                                }
                                return {
                                    start: a,
                                    end: s,
                                    rangeUniques: n
                                }
                            }
                        }, {
                            key: "handleCandleStickBoxDataFormat",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = "boxPlot" === a.config.chart.type || "boxPlot" === a.config.series[i].type,
                                    n = [],
                                    r = [],
                                    o = [],
                                    l = [],
                                    c = [];
                                if ("array" === t)
                                    if (s && 6 === e[i].data[0].length || !s && 5 === e[i].data[0].length)
                                        for (var h = 0; h < e[i].data.length; h++) n.push(e[i].data[h][1]), r.push(e[i].data[h][2]), s ? (o.push(e[i].data[h][3]), l.push(e[i].data[h][4]), c.push(e[i].data[h][5])) : (l.push(e[i].data[h][3]), c.push(e[i].data[h][4]));
                                    else
                                        for (var d = 0; d < e[i].data.length; d++) Array.isArray(e[i].data[d][1]) && (n.push(e[i].data[d][1][0]), r.push(e[i].data[d][1][1]), s ? (o.push(e[i].data[d][1][2]), l.push(e[i].data[d][1][3]), c.push(e[i].data[d][1][4])) : (l.push(e[i].data[d][1][2]), c.push(e[i].data[d][1][3])));
                                else if ("xy" === t)
                                    for (var u = 0; u < e[i].data.length; u++) Array.isArray(e[i].data[u].y) && (n.push(e[i].data[u].y[0]), r.push(e[i].data[u].y[1]), s ? (o.push(e[i].data[u].y[2]), l.push(e[i].data[u].y[3]), c.push(e[i].data[u].y[4])) : (l.push(e[i].data[u].y[2]), c.push(e[i].data[u].y[3])));
                                return {
                                    o: n,
                                    h: r,
                                    m: o,
                                    l,
                                    c
                                }
                            }
                        }, {
                            key: "parseDataAxisCharts",
                            value: function(t) {
                                var e = this,
                                    i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.ctx,
                                    a = this.w.config,
                                    s = this.w.globals,
                                    n = new F(i),
                                    r = a.labels.length > 0 ? a.labels.slice() : a.xaxis.categories.slice();
                                s.isRangeBar = "rangeBar" === a.chart.type && s.isBarHorizontal, s.hasGroups = "category" === a.xaxis.type && a.xaxis.group.groups.length > 0, s.hasGroups && (s.groups = a.xaxis.group.groups);
                                for (var o = function() {
                                        for (var t = 0; t < r.length; t++)
                                            if ("string" == typeof r[t]) {
                                                if (!n.isValidDate(r[t])) throw new Error("You have provided invalid Date format. Please provide a valid JavaScript Date");
                                                e.twoDSeriesX.push(n.parseDate(r[t]))
                                            } else e.twoDSeriesX.push(r[t])
                                    }, l = 0; l < t.length; l++) {
                                    if (this.twoDSeries = [], this.twoDSeriesX = [], this.threeDSeries = [], void 0 === t[l].data) return void console.error("It is a possibility that you may have not included 'data' property in series.");
                                    if ("rangeBar" !== a.chart.type && "rangeArea" !== a.chart.type && "rangeBar" !== t[l].type && "rangeArea" !== t[l].type || (s.isRangeData = !0, this.handleRangeData(t, l)), this.isMultiFormat()) this.isFormat2DArray() ? this.handleFormat2DArray(t, l) : this.isFormatXY() && this.handleFormatXY(t, l), "candlestick" !== a.chart.type && "candlestick" !== t[l].type && "boxPlot" !== a.chart.type && "boxPlot" !== t[l].type || this.handleCandleStickBoxData(t, l), s.series.push(this.twoDSeries), s.labels.push(this.twoDSeriesX), s.seriesX.push(this.twoDSeriesX), s.seriesGoals = this.seriesGoals, l !== this.activeSeriesIndex || this.fallbackToCategory || (s.isXNumeric = !0);
                                    else {
                                        "datetime" === a.xaxis.type ? (s.isXNumeric = !0, o(), s.seriesX.push(this.twoDSeriesX)) : "numeric" === a.xaxis.type && (s.isXNumeric = !0, r.length > 0 && (this.twoDSeriesX = r, s.seriesX.push(this.twoDSeriesX))), s.labels.push(this.twoDSeriesX);
                                        var c = t[l].data.map((function(t) {
                                            return b.parseNumber(t)
                                        }));
                                        s.series.push(c)
                                    }
                                    s.seriesZ.push(this.threeDSeries), void 0 !== t[l].name ? s.seriesNames.push(t[l].name) : s.seriesNames.push("series-" + parseInt(l + 1, 10)), void 0 !== t[l].color ? s.seriesColors.push(t[l].color) : s.seriesColors.push(void 0)
                                }
                                return this.w
                            }
                        }, {
                            key: "parseDataNonAxisCharts",
                            value: function(t) {
                                var e = this.w.globals,
                                    i = this.w.config;
                                e.series = t.slice(), e.seriesNames = i.labels.slice();
                                for (var a = 0; a < e.series.length; a++) void 0 === e.seriesNames[a] && e.seriesNames.push("series-" + (a + 1));
                                return this.w
                            }
                        }, {
                            key: "handleExternalLabelsData",
                            value: function(t) {
                                var e = this.w.config,
                                    i = this.w.globals;
                                e.xaxis.categories.length > 0 ? i.labels = e.xaxis.categories : e.labels.length > 0 ? i.labels = e.labels.slice() : this.fallbackToCategory ? (i.labels = i.labels[0], i.seriesRangeBar.length && (i.seriesRangeBar.map((function(t) {
                                    t.forEach((function(t) {
                                        i.labels.indexOf(t.x) < 0 && t.x && i.labels.push(t.x)
                                    }))
                                })), i.labels = i.labels.filter((function(t, e, i) {
                                    return i.indexOf(t) === e
                                }))), e.xaxis.convertedCatToNumeric && (new H(e).convertCatToNumericXaxis(e, this.ctx, i.seriesX[0]), this._generateExternalLabels(t))) : this._generateExternalLabels(t)
                            }
                        }, {
                            key: "_generateExternalLabels",
                            value: function(t) {
                                var e = this.w.globals,
                                    i = this.w.config,
                                    a = [];
                                if (e.axisCharts) {
                                    if (e.series.length > 0)
                                        if (this.isFormatXY())
                                            for (var s = i.series.map((function(t, e) {
                                                    return t.data.filter((function(t, e, i) {
                                                        return i.findIndex((function(e) {
                                                            return e.x === t.x
                                                        })) === e
                                                    }))
                                                })), n = s.reduce((function(t, e, i, a) {
                                                    return a[t].length > e.length ? t : i
                                                }), 0), r = 0; r < s[n].length; r++) a.push(r + 1);
                                        else
                                            for (var o = 0; o < e.series[e.maxValsInArrayIndex].length; o++) a.push(o + 1);
                                    e.seriesX = [];
                                    for (var l = 0; l < t.length; l++) e.seriesX.push(a);
                                    e.isXNumeric = !0
                                }
                                if (0 === a.length) {
                                    a = e.axisCharts ? [] : e.series.map((function(t, e) {
                                        return e + 1
                                    }));
                                    for (var c = 0; c < t.length; c++) e.seriesX.push(a)
                                }
                                e.labels = a, i.xaxis.convertedCatToNumeric && (e.categoryLabels = a.map((function(t) {
                                    return i.xaxis.labels.formatter(t)
                                }))), e.noLabelsProvided = !0
                            }
                        }, {
                            key: "parseData",
                            value: function(t) {
                                var e = this.w,
                                    i = e.config,
                                    a = e.globals;
                                if (this.excludeCollapsedSeriesInYAxis(), this.fallbackToCategory = !1, this.ctx.core.resetGlobals(), this.ctx.core.isMultipleY(), a.axisCharts ? this.parseDataAxisCharts(t) : this.parseDataNonAxisCharts(t), this.coreUtils.getLargestSeries(), "bar" === i.chart.type && i.chart.stacked) {
                                    var s = new O(this.ctx);
                                    a.series = s.setNullSeriesToZeroValues(a.series)
                                }
                                this.coreUtils.getSeriesTotals(), a.axisCharts && this.coreUtils.getStackedSeriesTotals(), this.coreUtils.getPercentSeries(), a.dataFormatXNumeric || a.isXNumeric && ("numeric" !== i.xaxis.type || 0 !== i.labels.length || 0 !== i.xaxis.categories.length) || this.handleExternalLabelsData(t);
                                for (var n = this.coreUtils.getCategoryLabels(a.labels), r = 0; r < n.length; r++)
                                    if (Array.isArray(n[r])) {
                                        a.isMultiLineX = !0;
                                        break
                                    }
                            }
                        }, {
                            key: "excludeCollapsedSeriesInYAxis",
                            value: function() {
                                var t = this,
                                    e = this.w;
                                e.globals.ignoreYAxisIndexes = e.globals.collapsedSeries.map((function(i, a) {
                                    if (t.w.globals.isMultipleYAxis && !e.config.chart.stacked) return i.index
                                }))
                            }
                        }]), t
                    }(),
                    V = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.tooltipKeyFormat = "dd MMM"
                        }
                        return c(t, [{
                            key: "xLabelFormat",
                            value: function(t, e, i, a) {
                                var s = this.w;
                                if ("datetime" === s.config.xaxis.type && void 0 === s.config.xaxis.labels.formatter && void 0 === s.config.tooltip.x.formatter) {
                                    var n = new F(this.ctx);
                                    return n.formatDate(n.getDate(e), s.config.tooltip.x.format)
                                }
                                return t(e, i, a)
                            }
                        }, {
                            key: "defaultGeneralFormatter",
                            value: function(t) {
                                return Array.isArray(t) ? t.map((function(t) {
                                    return t
                                })) : t
                            }
                        }, {
                            key: "defaultYFormatter",
                            value: function(t, e, i) {
                                var a = this.w;
                                return b.isNumber(t) && (t = 0 !== a.globals.yValueDecimal ? t.toFixed(void 0 !== e.decimalsInFloat ? e.decimalsInFloat : a.globals.yValueDecimal) : a.globals.maxYArr[i] - a.globals.minYArr[i] < 5 ? t.toFixed(1) : t.toFixed(0)), t
                            }
                        }, {
                            key: "setLabelFormatters",
                            value: function() {
                                var t = this,
                                    e = this.w;
                                return e.globals.xaxisTooltipFormatter = function(e) {
                                    return t.defaultGeneralFormatter(e)
                                }, e.globals.ttKeyFormatter = function(e) {
                                    return t.defaultGeneralFormatter(e)
                                }, e.globals.ttZFormatter = function(t) {
                                    return t
                                }, e.globals.legendFormatter = function(e) {
                                    return t.defaultGeneralFormatter(e)
                                }, void 0 !== e.config.xaxis.labels.formatter ? e.globals.xLabelFormatter = e.config.xaxis.labels.formatter : e.globals.xLabelFormatter = function(t) {
                                    if (b.isNumber(t)) {
                                        if (!e.config.xaxis.convertedCatToNumeric && "numeric" === e.config.xaxis.type) {
                                            if (b.isNumber(e.config.xaxis.decimalsInFloat)) return t.toFixed(e.config.xaxis.decimalsInFloat);
                                            var i = e.globals.maxX - e.globals.minX;
                                            return i > 0 && i < 100 ? t.toFixed(1) : t.toFixed(0)
                                        }
                                        return e.globals.isBarHorizontal && e.globals.maxY - e.globals.minYArr < 4 ? t.toFixed(1) : t.toFixed(0)
                                    }
                                    return t
                                }, "function" == typeof e.config.tooltip.x.formatter ? e.globals.ttKeyFormatter = e.config.tooltip.x.formatter : e.globals.ttKeyFormatter = e.globals.xLabelFormatter, "function" == typeof e.config.xaxis.tooltip.formatter && (e.globals.xaxisTooltipFormatter = e.config.xaxis.tooltip.formatter), (Array.isArray(e.config.tooltip.y) || void 0 !== e.config.tooltip.y.formatter) && (e.globals.ttVal = e.config.tooltip.y), void 0 !== e.config.tooltip.z.formatter && (e.globals.ttZFormatter = e.config.tooltip.z.formatter), void 0 !== e.config.legend.formatter && (e.globals.legendFormatter = e.config.legend.formatter), e.config.yaxis.forEach((function(i, a) {
                                    void 0 !== i.labels.formatter ? e.globals.yLabelFormatters[a] = i.labels.formatter : e.globals.yLabelFormatters[a] = function(s) {
                                        return e.globals.xyCharts ? Array.isArray(s) ? s.map((function(e) {
                                            return t.defaultYFormatter(e, i, a)
                                        })) : t.defaultYFormatter(s, i, a) : s
                                    }
                                })), e.globals
                            }
                        }, {
                            key: "heatmapLabelFormatters",
                            value: function() {
                                var t = this.w;
                                if ("heatmap" === t.config.chart.type) {
                                    t.globals.yAxisScale[0].result = t.globals.seriesNames.slice();
                                    var e = t.globals.seriesNames.reduce((function(t, e) {
                                        return t.length > e.length ? t : e
                                    }), 0);
                                    t.globals.yAxisScale[0].niceMax = e, t.globals.yAxisScale[0].niceMin = e
                                }
                            }
                        }]), t
                    }(),
                    j = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "getLabel",
                            value: function(t, e, i, a) {
                                var s = arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : [],
                                    n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : "12px",
                                    r = !(arguments.length > 6 && void 0 !== arguments[6]) || arguments[6],
                                    o = this.w,
                                    l = void 0 === t[a] ? "" : t[a],
                                    c = l,
                                    h = o.globals.xLabelFormatter,
                                    d = o.config.xaxis.labels.formatter,
                                    u = !1,
                                    p = new V(this.ctx),
                                    g = l;
                                r && (c = p.xLabelFormat(h, l, g, {
                                    i: a,
                                    dateFormatter: new F(this.ctx).formatDate,
                                    w: o
                                }), void 0 !== d && (c = d(l, t[a], {
                                    i: a,
                                    dateFormatter: new F(this.ctx).formatDate,
                                    w: o
                                })));
                                var f = function(t) {
                                    var i = null;
                                    return e.forEach((function(t) {
                                        "month" === t.unit ? i = "year" : "day" === t.unit ? i = "month" : "hour" === t.unit ? i = "day" : "minute" === t.unit && (i = "hour")
                                    })), i === t
                                };
                                e.length > 0 ? (u = f(e[a].unit), i = e[a].position, c = e[a].value) : "datetime" === o.config.xaxis.type && void 0 === d && (c = ""), void 0 === c && (c = ""), c = Array.isArray(c) ? c : c.toString();
                                var m = new S(this.ctx),
                                    x = {};
                                x = o.globals.rotateXLabels && r ? m.getTextRects(c, parseInt(n, 10), null, "rotate(".concat(o.config.xaxis.labels.rotate, " 0 0)"), !1) : m.getTextRects(c, parseInt(n, 10));
                                var v = !o.config.xaxis.labels.showDuplicates && this.ctx.timeScale;
                                return !Array.isArray(c) && (0 === c.indexOf("NaN") || 0 === c.toLowerCase().indexOf("invalid") || c.toLowerCase().indexOf("infinity") >= 0 || s.indexOf(c) >= 0 && v) && (c = ""), {
                                    x: i,
                                    text: c,
                                    textRect: x,
                                    isBold: u
                                }
                            }
                        }, {
                            key: "checkLabelBasedOnTickamount",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = a.config.xaxis.tickAmount;
                                return "dataPoints" === s && (s = Math.round(a.globals.gridWidth / 120)), s > i || t % Math.round(i / (s + 1)) == 0 || (e.text = ""), e
                            }
                        }, {
                            key: "checkForOverflowingLabels",
                            value: function(t, e, i, a, s) {
                                var n = this.w;
                                if (0 === t && n.globals.skipFirstTimelinelabel && (e.text = ""), t === i - 1 && n.globals.skipLastTimelinelabel && (e.text = ""), n.config.xaxis.labels.hideOverlappingLabels && a.length > 0) {
                                    var r = s[s.length - 1];
                                    e.x < r.textRect.width / (n.globals.rotateXLabels ? Math.abs(n.config.xaxis.labels.rotate) / 12 : 1.01) + r.x && (e.text = "")
                                }
                                return e
                            }
                        }, {
                            key: "checkForReversedLabels",
                            value: function(t, e) {
                                var i = this.w;
                                return i.config.yaxis[t] && i.config.yaxis[t].reversed && e.reverse(), e
                            }
                        }, {
                            key: "isYAxisHidden",
                            value: function(t) {
                                var e = this.w,
                                    i = new C(this.ctx);
                                return !e.config.yaxis[t].show || !e.config.yaxis[t].showForNullSeries && i.isSeriesNull(t) && -1 === e.globals.collapsedSeriesIndices.indexOf(t)
                            }
                        }, {
                            key: "getYAxisForeColor",
                            value: function(t, e) {
                                var i = this.w;
                                return Array.isArray(t) && i.globals.yAxisScale[e] && this.ctx.theme.pushExtraColors(t, i.globals.yAxisScale[e].result.length, !1), t
                            }
                        }, {
                            key: "drawYAxisTicks",
                            value: function(t, e, i, a, s, n, r) {
                                var o = this.w,
                                    l = new S(this.ctx),
                                    c = o.globals.translateY;
                                if (a.show && e > 0) {
                                    !0 === o.config.yaxis[s].opposite && (t += a.width);
                                    for (var h = e; h >= 0; h--) {
                                        var d = c + e / 10 + o.config.yaxis[s].labels.offsetY - 1;
                                        o.globals.isBarHorizontal && (d = n * h), "heatmap" === o.config.chart.type && (d += n / 2);
                                        var u = l.drawLine(t + i.offsetX - a.width + a.offsetX, d + a.offsetY, t + i.offsetX + a.offsetX, d + a.offsetY, a.color);
                                        r.add(u), c += n
                                    }
                                }
                            }
                        }]), t
                    }(),
                    U = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "scaleSvgNode",
                            value: function(t, e) {
                                var i = parseFloat(t.getAttributeNS(null, "width")),
                                    a = parseFloat(t.getAttributeNS(null, "height"));
                                t.setAttributeNS(null, "width", i * e), t.setAttributeNS(null, "height", a * e), t.setAttributeNS(null, "viewBox", "0 0 " + i + " " + a)
                            }
                        }, {
                            key: "fixSvgStringForIe11",
                            value: function(t) {
                                if (!b.isIE11()) return t.replace(/&nbsp;/g, "&#160;");
                                var e = 0,
                                    i = t.replace(/xmlns="http:\/\/www.w3.org\/2000\/svg"/g, (function(t) {
                                        return 2 == ++e ? 'xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:svgjs="http://svgjs.dev"' : t
                                    }));
                                return (i = i.replace(/xmlns:NS\d+=""/g, "")).replace(/NS\d+:(\w+:\w+=")/g, "$1")
                            }
                        }, {
                            key: "getSvgString",
                            value: function(t) {
                                null == t && (t = 1);
                                var e = this.w.globals.dom.Paper.svg();
                                if (1 !== t) {
                                    var i = this.w.globals.dom.Paper.node.cloneNode(!0);
                                    this.scaleSvgNode(i, t), e = (new XMLSerializer).serializeToString(i)
                                }
                                return this.fixSvgStringForIe11(e)
                            }
                        }, {
                            key: "cleanup",
                            value: function() {
                                var t = this.w,
                                    e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-xcrosshairs"),
                                    i = t.globals.dom.baseEl.getElementsByClassName("apexcharts-ycrosshairs"),
                                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-zoom-rect, .apexcharts-selection-rect");
                                Array.prototype.forEach.call(a, (function(t) {
                                    t.setAttribute("width", 0)
                                })), e && e[0] && (e[0].setAttribute("x", -500), e[0].setAttribute("x1", -500), e[0].setAttribute("x2", -500)), i && i[0] && (i[0].setAttribute("y", -100), i[0].setAttribute("y1", -100), i[0].setAttribute("y2", -100))
                            }
                        }, {
                            key: "svgUrl",
                            value: function() {
                                this.cleanup();
                                var t = this.getSvgString(),
                                    e = new Blob([t], {
                                        type: "image/svg+xml;charset=utf-8"
                                    });
                                return URL.createObjectURL(e)
                            }
                        }, {
                            key: "dataURI",
                            value: function(t) {
                                var e = this;
                                return new Promise((function(i) {
                                    var a = e.w,
                                        s = t ? t.scale || t.width / a.globals.svgWidth : 1;
                                    e.cleanup();
                                    var n = document.createElement("canvas");
                                    n.width = a.globals.svgWidth * s, n.height = parseInt(a.globals.dom.elWrap.style.height, 10) * s;
                                    var r = "transparent" === a.config.chart.background ? "#fff" : a.config.chart.background,
                                        o = n.getContext("2d");
                                    o.fillStyle = r, o.fillRect(0, 0, n.width * s, n.height * s);
                                    var l = e.getSvgString(s);
                                    if (window.canvg && b.isIE11()) {
                                        var c = window.canvg.Canvg.fromString(o, l, {
                                            ignoreClear: !0,
                                            ignoreDimensions: !0
                                        });
                                        c.start();
                                        var h = n.msToBlob();
                                        c.stop(), i({
                                            blob: h
                                        })
                                    } else {
                                        var d = "data:image/svg+xml," + encodeURIComponent(l),
                                            u = new Image;
                                        u.crossOrigin = "anonymous", u.onload = function() {
                                            if (o.drawImage(u, 0, 0), n.msToBlob) {
                                                var t = n.msToBlob();
                                                i({
                                                    blob: t
                                                })
                                            } else {
                                                var e = n.toDataURL("image/png");
                                                i({
                                                    imgURI: e
                                                })
                                            }
                                        }, u.src = d
                                    }
                                }))
                            }
                        }, {
                            key: "exportToSVG",
                            value: function() {
                                this.triggerDownload(this.svgUrl(), this.w.config.chart.toolbar.export.svg.filename, ".svg")
                            }
                        }, {
                            key: "exportToPng",
                            value: function() {
                                var t = this;
                                this.dataURI().then((function(e) {
                                    var i = e.imgURI,
                                        a = e.blob;
                                    a ? navigator.msSaveOrOpenBlob(a, t.w.globals.chartID + ".png") : t.triggerDownload(i, t.w.config.chart.toolbar.export.png.filename, ".png")
                                }))
                            }
                        }, {
                            key: "exportToCSV",
                            value: function(t) {
                                var e = this,
                                    i = t.series,
                                    a = t.fileName,
                                    s = t.columnDelimiter,
                                    n = void 0 === s ? "," : s,
                                    r = t.lineDelimiter,
                                    o = void 0 === r ? "\n" : r,
                                    l = this.w;
                                i || (i = l.config.series);
                                var c = [],
                                    h = [],
                                    d = "",
                                    u = new G(this.ctx),
                                    p = new j(this.ctx),
                                    g = function(t) {
                                        var i = "";
                                        if (l.globals.axisCharts) {
                                            if ("category" === l.config.xaxis.type || l.config.xaxis.convertedCatToNumeric)
                                                if (l.globals.isBarHorizontal) {
                                                    var a = l.globals.yLabelFormatters[0],
                                                        s = new O(e.ctx).getActiveConfigSeriesIndex();
                                                    i = a(l.globals.labels[t], {
                                                        seriesIndex: s,
                                                        dataPointIndex: t,
                                                        w: l
                                                    })
                                                } else i = p.getLabel(l.globals.labels, l.globals.timescaleLabels, 0, t).text;
                                            "datetime" === l.config.xaxis.type && (l.config.xaxis.categories.length ? i = l.config.xaxis.categories[t] : l.config.labels.length && (i = l.config.labels[t]))
                                        } else i = l.config.labels[t];
                                        return Array.isArray(i) && (i = i.join(" ")), b.isNumber(i) ? i : i.split(n).join("")
                                    };
                                c.push(l.config.chart.toolbar.export.csv.headerCategory), "boxPlot" === l.config.chart.type ? (c.push("minimum"), c.push("q1"), c.push("median"), c.push("q3"), c.push("maximum")) : "candlestick" === l.config.chart.type ? (c.push("open"), c.push("high"), c.push("low"), c.push("close")) : "rangeBar" === l.config.chart.type ? (c.push("minimum"), c.push("maximum")) : i.map((function(t, e) {
                                    var i = t.name ? t.name : "series-".concat(e);
                                    l.globals.axisCharts && c.push(i.split(n).join("") ? i.split(n).join("") : "series-".concat(e))
                                })), l.globals.axisCharts || (c.push(l.config.chart.toolbar.export.csv.headerValue), h.push(c.join(n))), i.map((function(t, e) {
                                    l.globals.axisCharts ? function(t, e) {
                                        if (c.length && 0 === e && h.push(c.join(n)), t.data && t.data.length)
                                            for (var a = 0; a < t.data.length; a++) {
                                                c = [];
                                                var s = g(a);
                                                if (s || (u.isFormatXY() ? s = i[e].data[a].x : u.isFormat2DArray() && (s = i[e].data[a] ? i[e].data[a][0] : "")), 0 === e) {
                                                    c.push((o = s, "datetime" === l.config.xaxis.type && String(o).length >= 10 ? l.config.chart.toolbar.export.csv.dateFormatter(s) : b.isNumber(s) ? s : s.split(n).join("")));
                                                    for (var r = 0; r < l.globals.series.length; r++) u.isFormatXY() ? c.push(i[r].data[a].y) : c.push(l.globals.series[r][a])
                                                }("candlestick" === l.config.chart.type || t.type && "candlestick" === t.type) && (c.pop(), c.push(l.globals.seriesCandleO[e][a]), c.push(l.globals.seriesCandleH[e][a]), c.push(l.globals.seriesCandleL[e][a]), c.push(l.globals.seriesCandleC[e][a])), ("boxPlot" === l.config.chart.type || t.type && "boxPlot" === t.type) && (c.pop(), c.push(l.globals.seriesCandleO[e][a]), c.push(l.globals.seriesCandleH[e][a]), c.push(l.globals.seriesCandleM[e][a]), c.push(l.globals.seriesCandleL[e][a]), c.push(l.globals.seriesCandleC[e][a])), "rangeBar" === l.config.chart.type && (c.pop(), c.push(l.globals.seriesRangeStart[e][a]), c.push(l.globals.seriesRangeEnd[e][a])), c.length && h.push(c.join(n))
                                            }
                                        var o
                                    }(t, e) : ((c = []).push(l.globals.labels[e].split(n).join("")), c.push(l.globals.series[e]), h.push(c.join(n)))
                                })), d += h.join(o), this.triggerDownload("data:text/csv; charset=utf-8," + encodeURIComponent("\ufeff" + d), a || l.config.chart.toolbar.export.csv.filename, ".csv")
                            }
                        }, {
                            key: "triggerDownload",
                            value: function(t, e, i) {
                                var a = document.createElement("a");
                                a.href = t, a.download = (e || this.w.globals.chartID) + i, document.body.appendChild(a), a.click(), document.body.removeChild(a)
                            }
                        }]), t
                    }(),
                    q = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var i = this.w;
                            this.axesUtils = new j(e), this.xaxisLabels = i.globals.labels.slice(), i.globals.timescaleLabels.length > 0 && !i.globals.isBarHorizontal && (this.xaxisLabels = i.globals.timescaleLabels.slice()), i.config.xaxis.overwriteCategories && (this.xaxisLabels = i.config.xaxis.overwriteCategories), this.drawnLabels = [], this.drawnLabelsRects = [], "top" === i.config.xaxis.position ? this.offY = 0 : this.offY = i.globals.gridHeight + 1, this.offY = this.offY + i.config.xaxis.axisBorder.offsetY, this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal, this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.xaxisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.xaxisBorderWidth = i.config.xaxis.axisBorder.width, this.isCategoryBarHorizontal && (this.xaxisBorderWidth = i.config.yaxis[0].axisBorder.width.toString()), this.xaxisBorderWidth.indexOf("%") > -1 ? this.xaxisBorderWidth = i.globals.gridWidth * parseInt(this.xaxisBorderWidth, 10) / 100 : this.xaxisBorderWidth = parseInt(this.xaxisBorderWidth, 10), this.xaxisBorderHeight = i.config.xaxis.axisBorder.height, this.yaxis = i.config.yaxis[0]
                        }
                        return c(t, [{
                            key: "drawXaxis",
                            value: function() {
                                var t = this.w,
                                    e = new S(this.ctx),
                                    i = e.group({
                                        class: "apexcharts-xaxis",
                                        transform: "translate(".concat(t.config.xaxis.offsetX, ", ").concat(t.config.xaxis.offsetY, ")")
                                    }),
                                    a = e.group({
                                        class: "apexcharts-xaxis-texts-g",
                                        transform: "translate(".concat(t.globals.translateXAxisX, ", ").concat(t.globals.translateXAxisY, ")")
                                    });
                                i.add(a);
                                for (var s = [], n = 0; n < this.xaxisLabels.length; n++) s.push(this.xaxisLabels[n]);
                                if (this.drawXAxisLabelAndGroup(!0, e, a, s, t.globals.isXNumeric, (function(t, e) {
                                        return e
                                    })), t.globals.hasGroups) {
                                    var r = t.globals.groups;
                                    s = [];
                                    for (var o = 0; o < r.length; o++) s.push(r[o].title);
                                    var l = {};
                                    t.config.xaxis.group.style && (l.xaxisFontSize = t.config.xaxis.group.style.fontSize, l.xaxisFontFamily = t.config.xaxis.group.style.fontFamily, l.xaxisForeColors = t.config.xaxis.group.style.colors, l.fontWeight = t.config.xaxis.group.style.fontWeight, l.cssClass = t.config.xaxis.group.style.cssClass), this.drawXAxisLabelAndGroup(!1, e, a, s, !1, (function(t, e) {
                                        return r[t].cols * e
                                    }), l)
                                }
                                if (void 0 !== t.config.xaxis.title.text) {
                                    var c = e.group({
                                            class: "apexcharts-xaxis-title"
                                        }),
                                        h = e.drawText({
                                            x: t.globals.gridWidth / 2 + t.config.xaxis.title.offsetX,
                                            y: this.offY + parseFloat(this.xaxisFontSize) + t.globals.xAxisLabelsHeight + t.config.xaxis.title.offsetY,
                                            text: t.config.xaxis.title.text,
                                            textAnchor: "middle",
                                            fontSize: t.config.xaxis.title.style.fontSize,
                                            fontFamily: t.config.xaxis.title.style.fontFamily,
                                            fontWeight: t.config.xaxis.title.style.fontWeight,
                                            foreColor: t.config.xaxis.title.style.color,
                                            cssClass: "apexcharts-xaxis-title-text " + t.config.xaxis.title.style.cssClass
                                        });
                                    c.add(h), i.add(c)
                                }
                                if (t.config.xaxis.axisBorder.show) {
                                    var d = t.globals.barPadForNumericAxis,
                                        u = e.drawLine(t.globals.padHorizontal + t.config.xaxis.axisBorder.offsetX - d, this.offY, this.xaxisBorderWidth + d, this.offY, t.config.xaxis.axisBorder.color, 0, this.xaxisBorderHeight);
                                    i.add(u)
                                }
                                return i
                            }
                        }, {
                            key: "drawXAxisLabelAndGroup",
                            value: function(t, e, i, a, s, n) {
                                var r, o = this,
                                    l = arguments.length > 6 && void 0 !== arguments[6] ? arguments[6] : {},
                                    c = [],
                                    h = [],
                                    d = this.w,
                                    u = l.xaxisFontSize || this.xaxisFontSize,
                                    p = l.xaxisFontFamily || this.xaxisFontFamily,
                                    g = l.xaxisForeColors || this.xaxisForeColors,
                                    f = l.fontWeight || d.config.xaxis.labels.style.fontWeight,
                                    m = l.cssClass || d.config.xaxis.labels.style.cssClass,
                                    x = d.globals.padHorizontal,
                                    v = a.length,
                                    b = "category" === d.config.xaxis.type ? d.globals.dataPoints : v;
                                if (s) {
                                    var y = b > 1 ? b - 1 : b;
                                    r = d.globals.gridWidth / y, x = x + n(0, r) / 2 + d.config.xaxis.labels.offsetX
                                } else r = d.globals.gridWidth / b, x = x + n(0, r) + d.config.xaxis.labels.offsetX;
                                for (var w = function(s) {
                                        var l = x - n(s, r) / 2 + d.config.xaxis.labels.offsetX;
                                        0 === s && 1 === v && r / 2 === x && 1 === b && (l = d.globals.gridWidth / 2);
                                        var y = o.axesUtils.getLabel(a, d.globals.timescaleLabels, l, s, c, u, t),
                                            w = 28;
                                        if (d.globals.rotateXLabels && t && (w = 22), t || (w = w + parseFloat(u) + (d.globals.xAxisLabelsHeight - d.globals.xAxisGroupLabelsHeight) + (d.globals.rotateXLabels ? 10 : 0)), y = void 0 !== d.config.xaxis.tickAmount && "dataPoints" !== d.config.xaxis.tickAmount && "datetime" !== d.config.xaxis.type ? o.axesUtils.checkLabelBasedOnTickamount(s, y, v) : o.axesUtils.checkForOverflowingLabels(s, y, v, c, h), t && y.text && d.globals.xaxisLabelsCount++, d.config.xaxis.labels.show) {
                                            var S = e.drawText({
                                                x: y.x,
                                                y: o.offY + d.config.xaxis.labels.offsetY + w - ("top" === d.config.xaxis.position ? d.globals.xAxisHeight + d.config.xaxis.axisTicks.height - 2 : 0),
                                                text: y.text,
                                                textAnchor: "middle",
                                                fontWeight: y.isBold ? 600 : f,
                                                fontSize: u,
                                                fontFamily: p,
                                                foreColor: Array.isArray(g) ? t && d.config.xaxis.convertedCatToNumeric ? g[d.globals.minX + s - 1] : g[s] : g,
                                                isPlainText: !1,
                                                cssClass: (t ? "apexcharts-xaxis-label " : "apexcharts-xaxis-group-label ") + m
                                            });
                                            if (i.add(S), t) {
                                                var C = document.createElementNS(d.globals.SVGNS, "title");
                                                C.textContent = Array.isArray(y.text) ? y.text.join(" ") : y.text, S.node.appendChild(C), "" !== y.text && (c.push(y.text), h.push(y))
                                            }
                                        }
                                        s < v - 1 && (x += n(s + 1, r))
                                    }, S = 0; S <= v - 1; S++) w(S)
                            }
                        }, {
                            key: "drawXaxisInversed",
                            value: function(t) {
                                var e, i, a = this,
                                    s = this.w,
                                    n = new S(this.ctx),
                                    r = s.config.yaxis[0].opposite ? s.globals.translateYAxisX[t] : 0,
                                    o = n.group({
                                        class: "apexcharts-yaxis apexcharts-xaxis-inversed",
                                        rel: t
                                    }),
                                    l = n.group({
                                        class: "apexcharts-yaxis-texts-g apexcharts-xaxis-inversed-texts-g",
                                        transform: "translate(" + r + ", 0)"
                                    });
                                o.add(l);
                                var c = [];
                                if (s.config.yaxis[t].show)
                                    for (var h = 0; h < this.xaxisLabels.length; h++) c.push(this.xaxisLabels[h]);
                                e = s.globals.gridHeight / c.length, i = -e / 2.2;
                                var d = s.globals.yLabelFormatters[0],
                                    u = s.config.yaxis[0].labels;
                                if (u.show)
                                    for (var p = function(r) {
                                            var o = void 0 === c[r] ? "" : c[r];
                                            o = d(o, {
                                                seriesIndex: t,
                                                dataPointIndex: r,
                                                w: s
                                            });
                                            var h = a.axesUtils.getYAxisForeColor(u.style.colors, t),
                                                p = 0;
                                            Array.isArray(o) && (p = o.length / 2 * parseInt(u.style.fontSize, 10));
                                            var g = n.drawText({
                                                x: u.offsetX - 15,
                                                y: i + e + u.offsetY - p,
                                                text: o,
                                                textAnchor: a.yaxis.opposite ? "start" : "end",
                                                foreColor: Array.isArray(h) ? h[r] : h,
                                                fontSize: u.style.fontSize,
                                                fontFamily: u.style.fontFamily,
                                                fontWeight: u.style.fontWeight,
                                                isPlainText: !1,
                                                cssClass: "apexcharts-yaxis-label " + u.style.cssClass,
                                                maxWidth: u.maxWidth
                                            });
                                            l.add(g);
                                            var f = document.createElementNS(s.globals.SVGNS, "title");
                                            if (f.textContent = Array.isArray(o) ? o.join(" ") : o, g.node.appendChild(f), 0 !== s.config.yaxis[t].labels.rotate) {
                                                var m = n.rotateAroundCenter(g.node);
                                                g.node.setAttribute("transform", "rotate(".concat(s.config.yaxis[t].labels.rotate, " 0 ").concat(m.y, ")"))
                                            }
                                            i += e
                                        }, g = 0; g <= c.length - 1; g++) p(g);
                                if (void 0 !== s.config.yaxis[0].title.text) {
                                    var f = n.group({
                                            class: "apexcharts-yaxis-title apexcharts-xaxis-title-inversed",
                                            transform: "translate(" + r + ", 0)"
                                        }),
                                        m = n.drawText({
                                            x: 0,
                                            y: s.globals.gridHeight / 2,
                                            text: s.config.yaxis[0].title.text,
                                            textAnchor: "middle",
                                            foreColor: s.config.yaxis[0].title.style.color,
                                            fontSize: s.config.yaxis[0].title.style.fontSize,
                                            fontWeight: s.config.yaxis[0].title.style.fontWeight,
                                            fontFamily: s.config.yaxis[0].title.style.fontFamily,
                                            cssClass: "apexcharts-yaxis-title-text " + s.config.yaxis[0].title.style.cssClass
                                        });
                                    f.add(m), o.add(f)
                                }
                                var x = 0;
                                this.isCategoryBarHorizontal && s.config.yaxis[0].opposite && (x = s.globals.gridWidth);
                                var v = s.config.xaxis.axisBorder;
                                if (v.show) {
                                    var b = n.drawLine(s.globals.padHorizontal + v.offsetX + x, 1 + v.offsetY, s.globals.padHorizontal + v.offsetX + x, s.globals.gridHeight + v.offsetY, v.color, 0);
                                    o.add(b)
                                }
                                return s.config.yaxis[0].axisTicks.show && this.axesUtils.drawYAxisTicks(x, c.length, s.config.yaxis[0].axisBorder, s.config.yaxis[0].axisTicks, 0, e, o), o
                            }
                        }, {
                            key: "drawXaxisTicks",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = t;
                                if (!(t < 0 || t - 2 > a.globals.gridWidth)) {
                                    var n = this.offY + a.config.xaxis.axisTicks.offsetY;
                                    if (e = e + n + a.config.xaxis.axisTicks.height, "top" === a.config.xaxis.position && (e = n - a.config.xaxis.axisTicks.height), a.config.xaxis.axisTicks.show) {
                                        var r = new S(this.ctx).drawLine(t + a.config.xaxis.axisTicks.offsetX, n + a.config.xaxis.offsetY, s + a.config.xaxis.axisTicks.offsetX, e + a.config.xaxis.offsetY, a.config.xaxis.axisTicks.color);
                                        i.add(r), r.node.classList.add("apexcharts-xaxis-tick")
                                    }
                                }
                            }
                        }, {
                            key: "getXAxisTicksPositions",
                            value: function() {
                                var t = this.w,
                                    e = [],
                                    i = this.xaxisLabels.length,
                                    a = t.globals.padHorizontal;
                                if (t.globals.timescaleLabels.length > 0)
                                    for (var s = 0; s < i; s++) a = this.xaxisLabels[s].position, e.push(a);
                                else
                                    for (var n = i, r = 0; r < n; r++) {
                                        var o = n;
                                        t.globals.isXNumeric && "bar" !== t.config.chart.type && (o -= 1), a += t.globals.gridWidth / o, e.push(a)
                                    }
                                return e
                            }
                        }, {
                            key: "xAxisLabelCorrections",
                            value: function() {
                                var t = this.w,
                                    e = new S(this.ctx),
                                    i = t.globals.dom.baseEl.querySelector(".apexcharts-xaxis-texts-g"),
                                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-texts-g text:not(.apexcharts-xaxis-group-label)"),
                                    s = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis-inversed text"),
                                    n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-xaxis-inversed-texts-g text tspan");
                                if (t.globals.rotateXLabels || t.config.xaxis.labels.rotateAlways)
                                    for (var r = 0; r < a.length; r++) {
                                        var o = e.rotateAroundCenter(a[r]);
                                        o.y = o.y - 1, o.x = o.x + 1, a[r].setAttribute("transform", "rotate(".concat(t.config.xaxis.labels.rotate, " ").concat(o.x, " ").concat(o.y, ")")), a[r].setAttribute("text-anchor", "end"), i.setAttribute("transform", "translate(0, ".concat(-10, ")"));
                                        var l = a[r].childNodes;
                                        t.config.xaxis.labels.trim && Array.prototype.forEach.call(l, (function(i) {
                                            e.placeTextWithEllipsis(i, i.textContent, t.globals.xAxisLabelsHeight - ("bottom" === t.config.legend.position ? 20 : 10))
                                        }))
                                    } else ! function() {
                                        for (var i = t.globals.gridWidth / (t.globals.labels.length + 1), s = 0; s < a.length; s++) {
                                            var n = a[s].childNodes;
                                            t.config.xaxis.labels.trim && "datetime" !== t.config.xaxis.type && Array.prototype.forEach.call(n, (function(t) {
                                                e.placeTextWithEllipsis(t, t.textContent, i)
                                            }))
                                        }
                                    }();
                                if (s.length > 0) {
                                    var c = s[s.length - 1].getBBox(),
                                        h = s[0].getBBox();
                                    c.x < -20 && s[s.length - 1].parentNode.removeChild(s[s.length - 1]), h.x + h.width > t.globals.gridWidth && !t.globals.isBarHorizontal && s[0].parentNode.removeChild(s[0]);
                                    for (var d = 0; d < n.length; d++) e.placeTextWithEllipsis(n[d], n[d].textContent, t.config.yaxis[0].labels.maxWidth - (t.config.yaxis[0].title.text ? 2 * parseFloat(t.config.yaxis[0].title.style.fontSize) : 0) - 15)
                                }
                            }
                        }]), t
                    }(),
                    Z = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var i = this.w;
                            this.xaxisLabels = i.globals.labels.slice(), this.axesUtils = new j(e), this.isRangeBar = i.globals.seriesRangeBar.length, i.globals.timescaleLabels.length > 0 && (this.xaxisLabels = i.globals.timescaleLabels.slice())
                        }
                        return c(t, [{
                            key: "drawGridArea",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                    e = this.w,
                                    i = new S(this.ctx);
                                null === t && (t = i.group({
                                    class: "apexcharts-grid"
                                }));
                                var a = i.drawLine(e.globals.padHorizontal, 1, e.globals.padHorizontal, e.globals.gridHeight, "transparent"),
                                    s = i.drawLine(e.globals.padHorizontal, e.globals.gridHeight, e.globals.gridWidth, e.globals.gridHeight, "transparent");
                                return t.add(s), t.add(a), t
                            }
                        }, {
                            key: "drawGrid",
                            value: function() {
                                var t = null;
                                return this.w.globals.axisCharts && (t = this.renderGrid(), this.drawGridArea(t.el)), t
                            }
                        }, {
                            key: "createGridMask",
                            value: function() {
                                var t = this.w,
                                    e = t.globals,
                                    i = new S(this.ctx),
                                    a = Array.isArray(t.config.stroke.width) ? 0 : t.config.stroke.width;
                                if (Array.isArray(t.config.stroke.width)) {
                                    var s = 0;
                                    t.config.stroke.width.forEach((function(t) {
                                        s = Math.max(s, t)
                                    })), a = s
                                }
                                e.dom.elGridRectMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMask.setAttribute("id", "gridRectMask".concat(e.cuid)), e.dom.elGridRectMarkerMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elGridRectMarkerMask.setAttribute("id", "gridRectMarkerMask".concat(e.cuid)), e.dom.elForecastMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elForecastMask.setAttribute("id", "forecastMask".concat(e.cuid)), e.dom.elNonForecastMask = document.createElementNS(e.SVGNS, "clipPath"), e.dom.elNonForecastMask.setAttribute("id", "nonForecastMask".concat(e.cuid));
                                var n = t.config.chart.type,
                                    r = 0,
                                    o = 0;
                                ("bar" === n || "rangeBar" === n || "candlestick" === n || "boxPlot" === n || t.globals.comboBarCount > 0) && t.globals.isXNumeric && !t.globals.isBarHorizontal && (r = t.config.grid.padding.left, o = t.config.grid.padding.right, e.barPadForNumericAxis > r && (r = e.barPadForNumericAxis, o = e.barPadForNumericAxis)), e.dom.elGridRect = i.drawRect(-a / 2 - r - 2, -a / 2, e.gridWidth + a + o + r + 4, e.gridHeight + a, 0, "#fff");
                                var l = t.globals.markers.largestSize + 1;
                                e.dom.elGridRectMarker = i.drawRect(2 * -l, 2 * -l, e.gridWidth + 4 * l, e.gridHeight + 4 * l, 0, "#fff"), e.dom.elGridRectMask.appendChild(e.dom.elGridRect.node), e.dom.elGridRectMarkerMask.appendChild(e.dom.elGridRectMarker.node);
                                var c = e.dom.baseEl.querySelector("defs");
                                c.appendChild(e.dom.elGridRectMask), c.appendChild(e.dom.elForecastMask), c.appendChild(e.dom.elNonForecastMask), c.appendChild(e.dom.elGridRectMarkerMask)
                            }
                        }, {
                            key: "_drawGridLines",
                            value: function(t) {
                                var e = t.i,
                                    i = t.x1,
                                    a = t.y1,
                                    s = t.x2,
                                    n = t.y2,
                                    r = t.xCount,
                                    o = t.parent,
                                    l = this.w;
                                if (!(0 === e && l.globals.skipFirstTimelinelabel || e === r - 1 && l.globals.skipLastTimelinelabel && !l.config.xaxis.labels.formatter || "radar" === l.config.chart.type)) {
                                    l.config.grid.xaxis.lines.show && this._drawGridLine({
                                        x1: i,
                                        y1: a,
                                        x2: s,
                                        y2: n,
                                        parent: o
                                    });
                                    var c = 0;
                                    if (l.globals.hasGroups && "between" === l.config.xaxis.tickPlacement) {
                                        var h = l.globals.groups;
                                        if (h) {
                                            for (var d = 0, u = 0; d < e && u < h.length; u++) d += h[u].cols;
                                            d === e && (c = .6 * l.globals.xAxisLabelsHeight)
                                        }
                                    }
                                    new q(this.ctx).drawXaxisTicks(i, c, this.elg)
                                }
                            }
                        }, {
                            key: "_drawGridLine",
                            value: function(t) {
                                var e = t.x1,
                                    i = t.y1,
                                    a = t.x2,
                                    s = t.y2,
                                    n = t.parent,
                                    r = this.w,
                                    o = n.node.classList.contains("apexcharts-gridlines-horizontal"),
                                    l = r.config.grid.strokeDashArray,
                                    c = r.globals.barPadForNumericAxis,
                                    h = new S(this).drawLine(e - (o ? c : 0), i, a + (o ? c : 0), s, r.config.grid.borderColor, l);
                                h.node.classList.add("apexcharts-gridline"), n.add(h)
                            }
                        }, {
                            key: "_drawGridBandRect",
                            value: function(t) {
                                var e = t.c,
                                    i = t.x1,
                                    a = t.y1,
                                    s = t.x2,
                                    n = t.y2,
                                    r = t.type,
                                    o = this.w,
                                    l = new S(this.ctx),
                                    c = o.globals.barPadForNumericAxis;
                                if ("column" !== r || "datetime" !== o.config.xaxis.type) {
                                    var h = o.config.grid[r].colors[e],
                                        d = l.drawRect(i - ("row" === r ? c : 0), a, s + ("row" === r ? 2 * c : 0), n, 0, h, o.config.grid[r].opacity);
                                    this.elg.add(d), d.attr("clip-path", "url(#gridRectMask".concat(o.globals.cuid, ")")), d.node.classList.add("apexcharts-grid-".concat(r))
                                }
                            }
                        }, {
                            key: "_drawXYLines",
                            value: function(t) {
                                var e = this,
                                    i = t.xCount,
                                    a = t.tickAmount,
                                    s = this.w;
                                if (s.config.grid.xaxis.lines.show || s.config.xaxis.axisTicks.show) {
                                    var n, r = s.globals.padHorizontal,
                                        o = s.globals.gridHeight;
                                    s.globals.timescaleLabels.length ? function(t) {
                                        for (var a = t.xC, s = t.x1, n = t.y1, r = t.x2, o = t.y2, l = 0; l < a; l++) s = e.xaxisLabels[l].position, r = e.xaxisLabels[l].position, e._drawGridLines({
                                            i: l,
                                            x1: s,
                                            y1: n,
                                            x2: r,
                                            y2: o,
                                            xCount: i,
                                            parent: e.elgridLinesV
                                        })
                                    }({
                                        xC: i,
                                        x1: r,
                                        y1: 0,
                                        x2: n,
                                        y2: o
                                    }) : (s.globals.isXNumeric && (i = s.globals.xAxisScale.result.length), s.config.xaxis.convertedCatToNumeric && (i = s.globals.xaxisLabelsCount), function(t) {
                                        var a = t.xC,
                                            n = t.x1,
                                            r = t.y1,
                                            o = t.x2,
                                            l = t.y2;
                                        if (void 0 !== s.config.xaxis.tickAmount && "dataPoints" !== s.config.xaxis.tickAmount && "on" === s.config.xaxis.tickPlacement) s.globals.dom.baseEl.querySelectorAll(".apexcharts-text.apexcharts-xaxis-label tspan:not(:empty)").forEach((function(t, a) {
                                            var s = t.getBBox();
                                            e._drawGridLines({
                                                i: a,
                                                x1: s.x + s.width / 2,
                                                y1: r,
                                                x2: s.x + s.width / 2,
                                                y2: l,
                                                xCount: i,
                                                parent: e.elgridLinesV
                                            })
                                        }));
                                        else
                                            for (var c = 0; c < a + (s.globals.isXNumeric ? 0 : 1); c++) 0 === c && 1 === a && 1 === s.globals.dataPoints && (o = n = s.globals.gridWidth / 2), e._drawGridLines({
                                                i: c,
                                                x1: n,
                                                y1: r,
                                                x2: o,
                                                y2: l,
                                                xCount: i,
                                                parent: e.elgridLinesV
                                            }), o = n += s.globals.gridWidth / (s.globals.isXNumeric ? a - 1 : a)
                                    }({
                                        xC: i,
                                        x1: r,
                                        y1: 0,
                                        x2: n,
                                        y2: o
                                    }))
                                }
                                if (s.config.grid.yaxis.lines.show) {
                                    var l = 0,
                                        c = 0,
                                        h = s.globals.gridWidth,
                                        d = a + 1;
                                    this.isRangeBar && (d = s.globals.labels.length);
                                    for (var u = 0; u < d + (this.isRangeBar ? 1 : 0); u++) this._drawGridLine({
                                        x1: 0,
                                        y1: l,
                                        x2: h,
                                        y2: c,
                                        parent: this.elgridLinesH
                                    }), c = l += s.globals.gridHeight / (this.isRangeBar ? d : a)
                                }
                            }
                        }, {
                            key: "_drawInvertedXYLines",
                            value: function(t) {
                                var e = t.xCount,
                                    i = this.w;
                                if (i.config.grid.xaxis.lines.show || i.config.xaxis.axisTicks.show)
                                    for (var a, s = i.globals.padHorizontal, n = i.globals.gridHeight, r = 0; r < e + 1; r++) i.config.grid.xaxis.lines.show && this._drawGridLine({
                                        x1: s,
                                        y1: 0,
                                        x2: a,
                                        y2: n,
                                        parent: this.elgridLinesV
                                    }), new q(this.ctx).drawXaxisTicks(s, 0, this.elg), a = s = s + i.globals.gridWidth / e + .3;
                                if (i.config.grid.yaxis.lines.show)
                                    for (var o = 0, l = 0, c = i.globals.gridWidth, h = 0; h < i.globals.dataPoints + 1; h++) this._drawGridLine({
                                        x1: 0,
                                        y1: o,
                                        x2: c,
                                        y2: l,
                                        parent: this.elgridLinesH
                                    }), l = o += i.globals.gridHeight / i.globals.dataPoints
                            }
                        }, {
                            key: "renderGrid",
                            value: function() {
                                var t = this.w,
                                    e = new S(this.ctx);
                                this.elg = e.group({
                                    class: "apexcharts-grid"
                                }), this.elgridLinesH = e.group({
                                    class: "apexcharts-gridlines-horizontal"
                                }), this.elgridLinesV = e.group({
                                    class: "apexcharts-gridlines-vertical"
                                }), this.elg.add(this.elgridLinesH), this.elg.add(this.elgridLinesV), t.config.grid.show || (this.elgridLinesV.hide(), this.elgridLinesH.hide());
                                for (var i, a = t.globals.yAxisScale.length ? t.globals.yAxisScale[0].result.length - 1 : 5, s = 0; s < t.globals.series.length && (void 0 !== t.globals.yAxisScale[s] && (a = t.globals.yAxisScale[s].result.length - 1), !(a > 2)); s++);
                                return !t.globals.isBarHorizontal || this.isRangeBar ? (i = this.xaxisLabels.length, this.isRangeBar && (a = t.globals.labels.length, t.config.xaxis.tickAmount && t.config.xaxis.labels.formatter && (i = t.config.xaxis.tickAmount)), this._drawXYLines({
                                    xCount: i,
                                    tickAmount: a
                                })) : (i = a, a = t.globals.xTickAmount, this._drawInvertedXYLines({
                                    xCount: i,
                                    tickAmount: a
                                })), this.drawGridBands(i, a), {
                                    el: this.elg,
                                    xAxisTickWidth: t.globals.gridWidth / i
                                }
                            }
                        }, {
                            key: "drawGridBands",
                            value: function(t, e) {
                                var i = this.w;
                                if (void 0 !== i.config.grid.row.colors && i.config.grid.row.colors.length > 0)
                                    for (var a = 0, s = i.globals.gridHeight / e, n = i.globals.gridWidth, r = 0, o = 0; r < e; r++, o++) o >= i.config.grid.row.colors.length && (o = 0), this._drawGridBandRect({
                                        c: o,
                                        x1: 0,
                                        y1: a,
                                        x2: n,
                                        y2: s,
                                        type: "row"
                                    }), a += i.globals.gridHeight / e;
                                if (void 0 !== i.config.grid.column.colors && i.config.grid.column.colors.length > 0)
                                    for (var l = i.globals.isBarHorizontal || "category" !== i.config.xaxis.type && !i.config.xaxis.convertedCatToNumeric ? t : t - 1, c = i.globals.padHorizontal, h = i.globals.padHorizontal + i.globals.gridWidth / l, d = i.globals.gridHeight, u = 0, p = 0; u < t; u++, p++) p >= i.config.grid.column.colors.length && (p = 0), this._drawGridBandRect({
                                        c: p,
                                        x1: c,
                                        y1: 0,
                                        x2: h,
                                        y2: d,
                                        type: "column"
                                    }), c += i.globals.gridWidth / l
                            }
                        }]), t
                    }(),
                    K = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "niceScale",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : 0,
                                    s = arguments.length > 4 ? arguments[4] : void 0,
                                    n = this.w,
                                    r = Math.abs(e - t);
                                if ("dataPoints" === (i = this._adjustTicksForSmallRange(i, a, r)) && (i = n.globals.dataPoints - 1), t === Number.MIN_VALUE && 0 === e || !b.isNumber(t) && !b.isNumber(e) || t === Number.MIN_VALUE && e === -Number.MAX_VALUE) {
                                    t = 0, e = i;
                                    var o = this.linearScale(t, e, i);
                                    return o
                                }
                                t > e ? (console.warn("axis.min cannot be greater than axis.max"), e = t + .1) : t === e && (t = 0 === t ? 0 : t - .5, e = 0 === e ? 2 : e + .5);
                                var l = [];
                                r < 1 && s && ("candlestick" === n.config.chart.type || "candlestick" === n.config.series[a].type || "boxPlot" === n.config.chart.type || "boxPlot" === n.config.series[a].type || n.globals.isRangeData) && (e *= 1.01);
                                var c = i + 1;
                                c < 2 ? c = 2 : c > 2 && (c -= 2);
                                var h = r / c,
                                    d = Math.floor(b.log10(h)),
                                    u = Math.pow(10, d),
                                    p = Math.round(h / u);
                                p < 1 && (p = 1);
                                var g = p * u,
                                    f = g * Math.floor(t / g),
                                    m = g * Math.ceil(e / g),
                                    x = f;
                                if (s && r > 2) {
                                    for (; l.push(x), !((x += g) > m););
                                    return {
                                        result: l,
                                        niceMin: l[0],
                                        niceMax: l[l.length - 1]
                                    }
                                }
                                var v = t;
                                (l = []).push(v);
                                for (var y = Math.abs(e - t) / i, w = 0; w <= i; w++) v += y, l.push(v);
                                return l[l.length - 2] >= e && l.pop(), {
                                    result: l,
                                    niceMin: l[0],
                                    niceMax: l[l.length - 1]
                                }
                            }
                        }, {
                            key: "linearScale",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 10,
                                    a = arguments.length > 3 ? arguments[3] : void 0,
                                    s = Math.abs(e - t);
                                "dataPoints" === (i = this._adjustTicksForSmallRange(i, a, s)) && (i = this.w.globals.dataPoints - 1);
                                var n = s / i;
                                i === Number.MAX_VALUE && (i = 10, n = 1);
                                for (var r = [], o = t; i >= 0;) r.push(o), o += n, i -= 1;
                                return {
                                    result: r,
                                    niceMin: r[0],
                                    niceMax: r[r.length - 1]
                                }
                            }
                        }, {
                            key: "logarithmicScaleNice",
                            value: function(t, e, i) {
                                e <= 0 && (e = Math.max(t, i)), t <= 0 && (t = Math.min(e, i));
                                for (var a = [], s = Math.ceil(Math.log(e) / Math.log(i) + 1), n = Math.floor(Math.log(t) / Math.log(i)); n < s; n++) a.push(Math.pow(i, n));
                                return {
                                    result: a,
                                    niceMin: a[0],
                                    niceMax: a[a.length - 1]
                                }
                            }
                        }, {
                            key: "logarithmicScale",
                            value: function(t, e, i) {
                                e <= 0 && (e = Math.max(t, i)), t <= 0 && (t = Math.min(e, i));
                                for (var a = [], s = Math.log(e) / Math.log(i), n = Math.log(t) / Math.log(i), r = s - n, o = Math.round(r), l = r / o, c = 0, h = n; c < o; c++, h += l) a.push(Math.pow(i, h));
                                return a.push(Math.pow(i, s)), {
                                    result: a,
                                    niceMin: t,
                                    niceMax: e
                                }
                            }
                        }, {
                            key: "_adjustTicksForSmallRange",
                            value: function(t, e, i) {
                                var a = t;
                                if (void 0 !== e && this.w.config.yaxis[e].labels.formatter && void 0 === this.w.config.yaxis[e].tickAmount) {
                                    var s = this.w.config.yaxis[e].labels.formatter(1);
                                    b.isNumber(Number(s)) && !b.isFloat(s) && (a = Math.ceil(i))
                                }
                                return a < t ? a : t
                            }
                        }, {
                            key: "setYScaleForIndex",
                            value: function(t, e, i) {
                                var a = this.w.globals,
                                    s = this.w.config,
                                    n = a.isBarHorizontal ? s.xaxis : s.yaxis[t];
                                void 0 === a.yAxisScale[t] && (a.yAxisScale[t] = []);
                                var r = Math.abs(i - e);
                                if (n.logarithmic && r <= 5 && (a.invalidLogScale = !0), n.logarithmic && r > 5) a.allSeriesCollapsed = !1, a.yAxisScale[t] = this.logarithmicScale(e, i, n.logBase), a.yAxisScale[t] = n.forceNiceScale ? this.logarithmicScaleNice(e, i, n.logBase) : this.logarithmicScale(e, i, n.logBase);
                                else if (i !== -Number.MAX_VALUE && b.isNumber(i))
                                    if (a.allSeriesCollapsed = !1, void 0 === n.min && void 0 === n.max || n.forceNiceScale) {
                                        var o = void 0 === s.yaxis[t].max && void 0 === s.yaxis[t].min || s.yaxis[t].forceNiceScale;
                                        a.yAxisScale[t] = this.niceScale(e, i, n.tickAmount ? n.tickAmount : r < 5 && r > 1 ? r + 1 : 5, t, o)
                                    } else a.yAxisScale[t] = this.linearScale(e, i, n.tickAmount, t);
                                else a.yAxisScale[t] = this.linearScale(0, 5, 5)
                            }
                        }, {
                            key: "setXScale",
                            value: function(t, e) {
                                var i = this.w,
                                    a = i.globals,
                                    s = i.config.xaxis,
                                    n = Math.abs(e - t);
                                return e !== -Number.MAX_VALUE && b.isNumber(e) ? a.xAxisScale = this.linearScale(t, e, s.tickAmount ? s.tickAmount : n < 5 && n > 1 ? n + 1 : 5, 0) : a.xAxisScale = this.linearScale(0, 5, 5), a.xAxisScale
                            }
                        }, {
                            key: "setMultipleYScales",
                            value: function() {
                                var t = this,
                                    e = this.w.globals,
                                    i = this.w.config,
                                    a = e.minYArr.concat([]),
                                    s = e.maxYArr.concat([]),
                                    n = [];
                                i.yaxis.forEach((function(e, r) {
                                    var o = r;
                                    i.series.forEach((function(t, i) {
                                        t.name === e.seriesName && (o = i, r !== i ? n.push({
                                            index: i,
                                            similarIndex: r,
                                            alreadyExists: !0
                                        }) : n.push({
                                            index: i
                                        }))
                                    }));
                                    var l = a[o],
                                        c = s[o];
                                    t.setYScaleForIndex(r, l, c)
                                })), this.sameScaleInMultipleAxes(a, s, n)
                            }
                        }, {
                            key: "sameScaleInMultipleAxes",
                            value: function(t, e, i) {
                                var a = this,
                                    s = this.w.config,
                                    n = this.w.globals,
                                    r = [];
                                i.forEach((function(t) {
                                    t.alreadyExists && (void 0 === r[t.index] && (r[t.index] = []), r[t.index].push(t.index), r[t.index].push(t.similarIndex))
                                })), n.yAxisSameScaleIndices = r, r.forEach((function(t, e) {
                                    r.forEach((function(i, a) {
                                        var s, n;
                                        e !== a && (s = t, n = i, s.filter((function(t) {
                                            return -1 !== n.indexOf(t)
                                        }))).length > 0 && (r[e] = r[e].concat(r[a]))
                                    }))
                                }));
                                var o = r.map((function(t) {
                                    return t.filter((function(e, i) {
                                        return t.indexOf(e) === i
                                    }))
                                })).map((function(t) {
                                    return t.sort()
                                }));
                                r = r.filter((function(t) {
                                    return !!t
                                }));
                                var l = o.slice(),
                                    c = l.map((function(t) {
                                        return JSON.stringify(t)
                                    }));
                                l = l.filter((function(t, e) {
                                    return c.indexOf(JSON.stringify(t)) === e
                                }));
                                var h = [],
                                    d = [];
                                t.forEach((function(t, i) {
                                    l.forEach((function(a, s) {
                                        a.indexOf(i) > -1 && (void 0 === h[s] && (h[s] = [], d[s] = []), h[s].push({
                                            key: i,
                                            value: t
                                        }), d[s].push({
                                            key: i,
                                            value: e[i]
                                        }))
                                    }))
                                }));
                                var u = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, Number.MIN_VALUE),
                                    p = Array.apply(null, Array(l.length)).map(Number.prototype.valueOf, -Number.MAX_VALUE);
                                h.forEach((function(t, e) {
                                    t.forEach((function(t, i) {
                                        u[e] = Math.min(t.value, u[e])
                                    }))
                                })), d.forEach((function(t, e) {
                                    t.forEach((function(t, i) {
                                        p[e] = Math.max(t.value, p[e])
                                    }))
                                })), t.forEach((function(t, e) {
                                    d.forEach((function(t, i) {
                                        var r = u[i],
                                            o = p[i];
                                        s.chart.stacked && (o = 0, t.forEach((function(t, e) {
                                            t.value !== -Number.MAX_VALUE && (o += t.value), r !== Number.MIN_VALUE && (r += h[i][e].value)
                                        }))), t.forEach((function(i, l) {
                                            t[l].key === e && (void 0 !== s.yaxis[e].min && (r = "function" == typeof s.yaxis[e].min ? s.yaxis[e].min(n.minY) : s.yaxis[e].min), void 0 !== s.yaxis[e].max && (o = "function" == typeof s.yaxis[e].max ? s.yaxis[e].max(n.maxY) : s.yaxis[e].max), a.setYScaleForIndex(e, r, o))
                                        }))
                                    }))
                                }))
                            }
                        }, {
                            key: "autoScaleY",
                            value: function(t, e, i) {
                                t || (t = this);
                                var a = t.w;
                                if (a.globals.isMultipleYAxis || a.globals.collapsedSeries.length) return console.warn("autoScaleYaxis is not supported in a multi-yaxis chart."), e;
                                var s = a.globals.seriesX[0],
                                    n = a.config.chart.stacked;
                                return e.forEach((function(t, r) {
                                    for (var o = 0, l = 0; l < s.length; l++)
                                        if (s[l] >= i.xaxis.min) {
                                            o = l;
                                            break
                                        }
                                    var c, h, d = a.globals.minYArr[r],
                                        u = a.globals.maxYArr[r],
                                        p = a.globals.stackedSeriesTotals;
                                    a.globals.series.forEach((function(r, l) {
                                        var g = r[o];
                                        n ? (g = p[o], c = h = g, p.forEach((function(t, e) {
                                            s[e] <= i.xaxis.max && s[e] >= i.xaxis.min && (t > h && null !== t && (h = t), r[e] < c && null !== r[e] && (c = r[e]))
                                        }))) : (c = h = g, r.forEach((function(t, e) {
                                            if (s[e] <= i.xaxis.max && s[e] >= i.xaxis.min) {
                                                var n = t,
                                                    r = t;
                                                a.globals.series.forEach((function(i, a) {
                                                    null !== t && (n = Math.min(i[e], n), r = Math.max(i[e], r))
                                                })), r > h && null !== r && (h = r), n < c && null !== n && (c = n)
                                            }
                                        }))), void 0 === c && void 0 === h && (c = d, h = u), h *= h < 0 ? .9 : 1.1, 0 == (c *= c < 0 ? 1.1 : .9) && 0 === h && (c = -1, h = 1), h < 0 && h < u && (h = u), c < 0 && c > d && (c = d), e.length > 1 ? (e[l].min = void 0 === t.min ? c : t.min, e[l].max = void 0 === t.max ? h : t.max) : (e[0].min = void 0 === t.min ? c : t.min, e[0].max = void 0 === t.max ? h : t.max)
                                    }))
                                })), e
                            }
                        }]), t
                    }(),
                    Q = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.scales = new K(e)
                        }
                        return c(t, [{
                            key: "init",
                            value: function() {
                                this.setYRange(), this.setXRange(), this.setZRange()
                            }
                        }, {
                            key: "getMinYMaxY",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE,
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : -Number.MAX_VALUE,
                                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                    s = this.w.config,
                                    n = this.w.globals,
                                    r = -Number.MAX_VALUE,
                                    o = Number.MIN_VALUE;
                                null === a && (a = t + 1);
                                var l = n.series,
                                    c = l,
                                    h = l;
                                "candlestick" === s.chart.type ? (c = n.seriesCandleL, h = n.seriesCandleH) : "boxPlot" === s.chart.type ? (c = n.seriesCandleO, h = n.seriesCandleC) : n.isRangeData && (c = n.seriesRangeStart, h = n.seriesRangeEnd);
                                for (var d = t; d < a; d++) {
                                    n.dataPoints = Math.max(n.dataPoints, l[d].length), n.categoryLabels.length && (n.dataPoints = n.categoryLabels.filter((function(t) {
                                        return void 0 !== t
                                    })).length);
                                    for (var u = 0; u < n.series[d].length; u++) {
                                        var p = l[d][u];
                                        null !== p && b.isNumber(p) ? (void 0 !== h[d][u] && (r = Math.max(r, h[d][u]), e = Math.min(e, h[d][u])), void 0 !== c[d][u] && (e = Math.min(e, c[d][u]), i = Math.max(i, c[d][u])), "candlestick" !== this.w.config.chart.type && "boxPlot" !== this.w.config.chart.type || (void 0 !== n.seriesCandleC[d][u] && (r = Math.max(r, n.seriesCandleO[d][u]), r = Math.max(r, n.seriesCandleH[d][u]), r = Math.max(r, n.seriesCandleL[d][u]), r = Math.max(r, n.seriesCandleC[d][u]), "boxPlot" === this.w.config.chart.type && (r = Math.max(r, n.seriesCandleM[d][u]))), !s.series[d].type || "candlestick" === s.series[d].type && "boxPlot" === s.series[d].type || (r = Math.max(r, n.series[d][u]), e = Math.min(e, n.series[d][u])), i = r), n.seriesGoals[d] && n.seriesGoals[d][u] && Array.isArray(n.seriesGoals[d][u]) && n.seriesGoals[d][u].forEach((function(t) {
                                            o !== Number.MIN_VALUE && (o = Math.min(o, t.value), e = o), r = Math.max(r, t.value), i = r
                                        })), b.isFloat(p) && (p = b.noExponents(p), n.yValueDecimal = Math.max(n.yValueDecimal, p.toString().split(".")[1].length)), o > c[d][u] && c[d][u] < 0 && (o = c[d][u])) : n.hasNullValues = !0
                                    }
                                }
                                return "rangeBar" === s.chart.type && n.seriesRangeStart.length && n.isBarHorizontal && (o = e), "bar" === s.chart.type && (o < 0 && r < 0 && (r = 0), o === Number.MIN_VALUE && (o = 0)), {
                                    minY: o,
                                    maxY: r,
                                    lowestY: e,
                                    highestY: i
                                }
                            }
                        }, {
                            key: "setYRange",
                            value: function() {
                                var t = this.w.globals,
                                    e = this.w.config;
                                t.maxY = -Number.MAX_VALUE, t.minY = Number.MIN_VALUE;
                                var i = Number.MAX_VALUE;
                                if (t.isMultipleYAxis)
                                    for (var a = 0; a < t.series.length; a++) {
                                        var s = this.getMinYMaxY(a, i, null, a + 1);
                                        t.minYArr.push(s.minY), t.maxYArr.push(s.maxY), i = s.lowestY
                                    }
                                var n = this.getMinYMaxY(0, i, null, t.series.length);
                                if (t.minY = n.minY, t.maxY = n.maxY, i = n.lowestY, e.chart.stacked && this._setStackedMinMax(), ("line" === e.chart.type || "area" === e.chart.type || "candlestick" === e.chart.type || "boxPlot" === e.chart.type || "rangeBar" === e.chart.type && !t.isBarHorizontal) && t.minY === Number.MIN_VALUE && i !== -Number.MAX_VALUE && i !== t.maxY) {
                                    var r = t.maxY - i;
                                    (i >= 0 && i <= 10 || void 0 !== e.yaxis[0].min || void 0 !== e.yaxis[0].max) && (r = 0), t.minY = i - 5 * r / 100, i > 0 && t.minY < 0 && (t.minY = 0), t.maxY = t.maxY + 5 * r / 100
                                }
                                return e.yaxis.forEach((function(e, i) {
                                    void 0 !== e.max && ("number" == typeof e.max ? t.maxYArr[i] = e.max : "function" == typeof e.max && (t.maxYArr[i] = e.max(t.isMultipleYAxis ? t.maxYArr[i] : t.maxY)), t.maxY = t.maxYArr[i]), void 0 !== e.min && ("number" == typeof e.min ? t.minYArr[i] = e.min : "function" == typeof e.min && (t.minYArr[i] = e.min(t.isMultipleYAxis ? t.minYArr[i] === Number.MIN_VALUE ? 0 : t.minYArr[i] : t.minY)), t.minY = t.minYArr[i])
                                })), t.isBarHorizontal && ["min", "max"].forEach((function(i) {
                                    void 0 !== e.xaxis[i] && "number" == typeof e.xaxis[i] && ("min" === i ? t.minY = e.xaxis[i] : t.maxY = e.xaxis[i])
                                })), t.isMultipleYAxis ? (this.scales.setMultipleYScales(), t.minY = i, t.yAxisScale.forEach((function(e, i) {
                                    t.minYArr[i] = e.niceMin, t.maxYArr[i] = e.niceMax
                                }))) : (this.scales.setYScaleForIndex(0, t.minY, t.maxY), t.minY = t.yAxisScale[0].niceMin, t.maxY = t.yAxisScale[0].niceMax, t.minYArr[0] = t.yAxisScale[0].niceMin, t.maxYArr[0] = t.yAxisScale[0].niceMax), {
                                    minY: t.minY,
                                    maxY: t.maxY,
                                    minYArr: t.minYArr,
                                    maxYArr: t.maxYArr,
                                    yAxisScale: t.yAxisScale
                                }
                            }
                        }, {
                            key: "setXRange",
                            value: function() {
                                var t = this.w.globals,
                                    e = this.w.config,
                                    i = "numeric" === e.xaxis.type || "datetime" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided || t.noLabelsProvided || t.isXNumeric;
                                if (t.isXNumeric && function() {
                                        for (var e = 0; e < t.series.length; e++)
                                            if (t.labels[e])
                                                for (var i = 0; i < t.labels[e].length; i++) null !== t.labels[e][i] && b.isNumber(t.labels[e][i]) && (t.maxX = Math.max(t.maxX, t.labels[e][i]), t.initialMaxX = Math.max(t.maxX, t.labels[e][i]), t.minX = Math.min(t.minX, t.labels[e][i]), t.initialMinX = Math.min(t.minX, t.labels[e][i]))
                                    }(), t.noLabelsProvided && 0 === e.xaxis.categories.length && (t.maxX = t.labels[t.labels.length - 1], t.initialMaxX = t.labels[t.labels.length - 1], t.minX = 1, t.initialMinX = 1), t.isXNumeric || t.noLabelsProvided || t.dataFormatXNumeric) {
                                    var a;
                                    if (void 0 === e.xaxis.tickAmount ? (a = Math.round(t.svgWidth / 150), "numeric" === e.xaxis.type && t.dataPoints < 30 && (a = t.dataPoints - 1), a > t.dataPoints && 0 !== t.dataPoints && (a = t.dataPoints - 1)) : "dataPoints" === e.xaxis.tickAmount ? (t.series.length > 1 && (a = t.series[t.maxValsInArrayIndex].length - 1), t.isXNumeric && (a = t.maxX - t.minX - 1)) : a = e.xaxis.tickAmount, t.xTickAmount = a, void 0 !== e.xaxis.max && "number" == typeof e.xaxis.max && (t.maxX = e.xaxis.max), void 0 !== e.xaxis.min && "number" == typeof e.xaxis.min && (t.minX = e.xaxis.min), void 0 !== e.xaxis.range && (t.minX = t.maxX - e.xaxis.range), t.minX !== Number.MAX_VALUE && t.maxX !== -Number.MAX_VALUE)
                                        if (e.xaxis.convertedCatToNumeric && !t.dataFormatXNumeric) {
                                            for (var s = [], n = t.minX - 1; n < t.maxX; n++) s.push(n + 1);
                                            t.xAxisScale = {
                                                result: s,
                                                niceMin: s[0],
                                                niceMax: s[s.length - 1]
                                            }
                                        } else t.xAxisScale = this.scales.setXScale(t.minX, t.maxX);
                                    else t.xAxisScale = this.scales.linearScale(1, a, a), t.noLabelsProvided && t.labels.length > 0 && (t.xAxisScale = this.scales.linearScale(1, t.labels.length, a - 1), t.seriesX = t.labels.slice());
                                    i && (t.labels = t.xAxisScale.result.slice())
                                }
                                return t.isBarHorizontal && t.labels.length && (t.xTickAmount = t.labels.length), this._handleSingleDataPoint(), this._getMinXDiff(), {
                                    minX: t.minX,
                                    maxX: t.maxX
                                }
                            }
                        }, {
                            key: "setZRange",
                            value: function() {
                                var t = this.w.globals;
                                if (t.isDataXYZ)
                                    for (var e = 0; e < t.series.length; e++)
                                        if (void 0 !== t.seriesZ[e])
                                            for (var i = 0; i < t.seriesZ[e].length; i++) null !== t.seriesZ[e][i] && b.isNumber(t.seriesZ[e][i]) && (t.maxZ = Math.max(t.maxZ, t.seriesZ[e][i]), t.minZ = Math.min(t.minZ, t.seriesZ[e][i]))
                            }
                        }, {
                            key: "_handleSingleDataPoint",
                            value: function() {
                                var t = this.w.globals,
                                    e = this.w.config;
                                if (t.minX === t.maxX) {
                                    var i = new F(this.ctx);
                                    if ("datetime" === e.xaxis.type) {
                                        var a = i.getDate(t.minX);
                                        e.xaxis.labels.datetimeUTC ? a.setUTCDate(a.getUTCDate() - 2) : a.setDate(a.getDate() - 2), t.minX = new Date(a).getTime();
                                        var s = i.getDate(t.maxX);
                                        e.xaxis.labels.datetimeUTC ? s.setUTCDate(s.getUTCDate() + 2) : s.setDate(s.getDate() + 2), t.maxX = new Date(s).getTime()
                                    } else("numeric" === e.xaxis.type || "category" === e.xaxis.type && !t.noLabelsProvided) && (t.minX = t.minX - 2, t.initialMinX = t.minX, t.maxX = t.maxX + 2, t.initialMaxX = t.maxX)
                                }
                            }
                        }, {
                            key: "_getMinXDiff",
                            value: function() {
                                var t = this.w.globals;
                                t.isXNumeric && t.seriesX.forEach((function(e, i) {
                                    1 === e.length && e.push(t.seriesX[t.maxValsInArrayIndex][t.seriesX[t.maxValsInArrayIndex].length - 1]);
                                    var a = e.slice();
                                    a.sort((function(t, e) {
                                        return t - e
                                    })), a.forEach((function(e, i) {
                                        if (i > 0) {
                                            var s = e - a[i - 1];
                                            s > 0 && (t.minXDiff = Math.min(s, t.minXDiff))
                                        }
                                    })), 1 !== t.dataPoints && t.minXDiff !== Number.MAX_VALUE || (t.minXDiff = .5)
                                }))
                            }
                        }, {
                            key: "_setStackedMinMax",
                            value: function() {
                                var t = this.w.globals,
                                    e = [],
                                    i = [];
                                if (t.series.length)
                                    for (var a = 0; a < t.series[t.maxValsInArrayIndex].length; a++)
                                        for (var s = 0, n = 0, r = 0; r < t.series.length; r++) null !== t.series[r][a] && b.isNumber(t.series[r][a]) && (t.series[r][a] > 0 ? s = s + parseFloat(t.series[r][a]) + 1e-4 : n += parseFloat(t.series[r][a])), r === t.series.length - 1 && (e.push(s), i.push(n));
                                for (var o = 0; o < e.length; o++) t.maxY = Math.max(t.maxY, e[o]), t.minY = Math.min(t.minY, i[o])
                            }
                        }]), t
                    }(),
                    J = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var i = this.w;
                            this.xaxisFontSize = i.config.xaxis.labels.style.fontSize, this.axisFontFamily = i.config.xaxis.labels.style.fontFamily, this.xaxisForeColors = i.config.xaxis.labels.style.colors, this.isCategoryBarHorizontal = "bar" === i.config.chart.type && i.config.plotOptions.bar.horizontal, this.xAxisoffX = 0, "bottom" === i.config.xaxis.position && (this.xAxisoffX = i.globals.gridHeight), this.drawnLabels = [], this.axesUtils = new j(e)
                        }
                        return c(t, [{
                            key: "drawYaxis",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = new S(this.ctx),
                                    s = i.config.yaxis[t].labels.style,
                                    n = s.fontSize,
                                    r = s.fontFamily,
                                    o = s.fontWeight,
                                    l = a.group({
                                        class: "apexcharts-yaxis",
                                        rel: t,
                                        transform: "translate(" + i.globals.translateYAxisX[t] + ", 0)"
                                    });
                                if (this.axesUtils.isYAxisHidden(t)) return l;
                                var c = a.group({
                                    class: "apexcharts-yaxis-texts-g"
                                });
                                l.add(c);
                                var h = i.globals.yAxisScale[t].result.length - 1,
                                    d = i.globals.gridHeight / h,
                                    u = i.globals.translateY,
                                    p = i.globals.yLabelFormatters[t],
                                    g = i.globals.yAxisScale[t].result.slice();
                                g = this.axesUtils.checkForReversedLabels(t, g);
                                var f = "";
                                if (i.config.yaxis[t].labels.show)
                                    for (var m = function(l) {
                                            var m = g[l];
                                            m = p(m, l, i);
                                            var x = i.config.yaxis[t].labels.padding;
                                            i.config.yaxis[t].opposite && 0 !== i.config.yaxis.length && (x *= -1);
                                            var v = e.axesUtils.getYAxisForeColor(s.colors, t),
                                                b = a.drawText({
                                                    x,
                                                    y: u + h / 10 + i.config.yaxis[t].labels.offsetY + 1,
                                                    text: m,
                                                    textAnchor: i.config.yaxis[t].opposite ? "start" : "end",
                                                    fontSize: n,
                                                    fontFamily: r,
                                                    fontWeight: o,
                                                    maxWidth: i.config.yaxis[t].labels.maxWidth,
                                                    foreColor: Array.isArray(v) ? v[l] : v,
                                                    isPlainText: !1,
                                                    cssClass: "apexcharts-yaxis-label " + s.cssClass
                                                });
                                            l === h && (f = b), c.add(b);
                                            var y = document.createElementNS(i.globals.SVGNS, "title");
                                            if (y.textContent = Array.isArray(m) ? m.join(" ") : m, b.node.appendChild(y), 0 !== i.config.yaxis[t].labels.rotate) {
                                                var w = a.rotateAroundCenter(f.node),
                                                    S = a.rotateAroundCenter(b.node);
                                                b.node.setAttribute("transform", "rotate(".concat(i.config.yaxis[t].labels.rotate, " ").concat(w.x, " ").concat(S.y, ")"))
                                            }
                                            u += d
                                        }, x = h; x >= 0; x--) m(x);
                                if (void 0 !== i.config.yaxis[t].title.text) {
                                    var v = a.group({
                                            class: "apexcharts-yaxis-title"
                                        }),
                                        b = 0;
                                    i.config.yaxis[t].opposite && (b = i.globals.translateYAxisX[t]);
                                    var y = a.drawText({
                                        x: b,
                                        y: i.globals.gridHeight / 2 + i.globals.translateY + i.config.yaxis[t].title.offsetY,
                                        text: i.config.yaxis[t].title.text,
                                        textAnchor: "end",
                                        foreColor: i.config.yaxis[t].title.style.color,
                                        fontSize: i.config.yaxis[t].title.style.fontSize,
                                        fontWeight: i.config.yaxis[t].title.style.fontWeight,
                                        fontFamily: i.config.yaxis[t].title.style.fontFamily,
                                        cssClass: "apexcharts-yaxis-title-text " + i.config.yaxis[t].title.style.cssClass
                                    });
                                    v.add(y), l.add(v)
                                }
                                var w = i.config.yaxis[t].axisBorder,
                                    C = 31 + w.offsetX;
                                if (i.config.yaxis[t].opposite && (C = -31 - w.offsetX), w.show) {
                                    var k = a.drawLine(C, i.globals.translateY + w.offsetY - 2, C, i.globals.gridHeight + i.globals.translateY + w.offsetY + 2, w.color, 0, w.width);
                                    l.add(k)
                                }
                                return i.config.yaxis[t].axisTicks.show && this.axesUtils.drawYAxisTicks(C, h, w, i.config.yaxis[t].axisTicks, t, d, l), l
                            }
                        }, {
                            key: "drawYaxisInversed",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = i.group({
                                        class: "apexcharts-xaxis apexcharts-yaxis-inversed"
                                    }),
                                    s = i.group({
                                        class: "apexcharts-xaxis-texts-g",
                                        transform: "translate(".concat(e.globals.translateXAxisX, ", ").concat(e.globals.translateXAxisY, ")")
                                    });
                                a.add(s);
                                var n = e.globals.yAxisScale[t].result.length - 1,
                                    r = e.globals.gridWidth / n + .1,
                                    o = r + e.config.xaxis.labels.offsetX,
                                    l = e.globals.xLabelFormatter,
                                    c = e.globals.yAxisScale[t].result.slice(),
                                    h = e.globals.timescaleLabels;
                                h.length > 0 && (this.xaxisLabels = h.slice(), n = (c = h.slice()).length), c = this.axesUtils.checkForReversedLabels(t, c);
                                var d = h.length;
                                if (e.config.xaxis.labels.show)
                                    for (var u = d ? 0 : n; d ? u < d : u >= 0; d ? u++ : u--) {
                                        var p = c[u];
                                        p = l(p, u, e);
                                        var g = e.globals.gridWidth + e.globals.padHorizontal - (o - r + e.config.xaxis.labels.offsetX);
                                        if (h.length) {
                                            var f = this.axesUtils.getLabel(c, h, g, u, this.drawnLabels, this.xaxisFontSize);
                                            g = f.x, p = f.text, this.drawnLabels.push(f.text), 0 === u && e.globals.skipFirstTimelinelabel && (p = ""), u === c.length - 1 && e.globals.skipLastTimelinelabel && (p = "")
                                        }
                                        var m = i.drawText({
                                            x: g,
                                            y: this.xAxisoffX + e.config.xaxis.labels.offsetY + 30 - ("top" === e.config.xaxis.position ? e.globals.xAxisHeight + e.config.xaxis.axisTicks.height - 2 : 0),
                                            text: p,
                                            textAnchor: "middle",
                                            foreColor: Array.isArray(this.xaxisForeColors) ? this.xaxisForeColors[t] : this.xaxisForeColors,
                                            fontSize: this.xaxisFontSize,
                                            fontFamily: this.xaxisFontFamily,
                                            fontWeight: e.config.xaxis.labels.style.fontWeight,
                                            isPlainText: !1,
                                            cssClass: "apexcharts-xaxis-label " + e.config.xaxis.labels.style.cssClass
                                        });
                                        s.add(m), m.tspan(p);
                                        var x = document.createElementNS(e.globals.SVGNS, "title");
                                        x.textContent = p, m.node.appendChild(x), o += r
                                    }
                                return this.inversedYAxisTitleText(a), this.inversedYAxisBorder(a), a
                            }
                        }, {
                            key: "inversedYAxisBorder",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = e.config.xaxis.axisBorder;
                                if (a.show) {
                                    var s = 0;
                                    "bar" === e.config.chart.type && e.globals.isXNumeric && (s -= 15);
                                    var n = i.drawLine(e.globals.padHorizontal + s + a.offsetX, this.xAxisoffX, e.globals.gridWidth, this.xAxisoffX, a.color, 0, a.height);
                                    t.add(n)
                                }
                            }
                        }, {
                            key: "inversedYAxisTitleText",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx);
                                if (void 0 !== e.config.xaxis.title.text) {
                                    var a = i.group({
                                            class: "apexcharts-xaxis-title apexcharts-yaxis-title-inversed"
                                        }),
                                        s = i.drawText({
                                            x: e.globals.gridWidth / 2 + e.config.xaxis.title.offsetX,
                                            y: this.xAxisoffX + parseFloat(this.xaxisFontSize) + parseFloat(e.config.xaxis.title.style.fontSize) + e.config.xaxis.title.offsetY + 20,
                                            text: e.config.xaxis.title.text,
                                            textAnchor: "middle",
                                            fontSize: e.config.xaxis.title.style.fontSize,
                                            fontFamily: e.config.xaxis.title.style.fontFamily,
                                            fontWeight: e.config.xaxis.title.style.fontWeight,
                                            foreColor: e.config.xaxis.title.style.color,
                                            cssClass: "apexcharts-xaxis-title-text " + e.config.xaxis.title.style.cssClass
                                        });
                                    a.add(s), t.add(a)
                                }
                            }
                        }, {
                            key: "yAxisTitleRotate",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new S(this.ctx),
                                    s = {
                                        width: 0,
                                        height: 0
                                    },
                                    n = {
                                        width: 0,
                                        height: 0
                                    },
                                    r = i.globals.dom.baseEl.querySelector(" .apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-texts-g"));
                                null !== r && (s = r.getBoundingClientRect());
                                var o = i.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(t, "'] .apexcharts-yaxis-title text"));
                                if (null !== o && (n = o.getBoundingClientRect()), null !== o) {
                                    var l = this.xPaddingForYAxisTitle(t, s, n, e);
                                    o.setAttribute("x", l.xPos - (e ? 10 : 0))
                                }
                                if (null !== o) {
                                    var c = a.rotateAroundCenter(o);
                                    o.setAttribute("transform", "rotate(".concat(e ? -1 * i.config.yaxis[t].title.rotate : i.config.yaxis[t].title.rotate, " ").concat(c.x, " ").concat(c.y, ")"))
                                }
                            }
                        }, {
                            key: "xPaddingForYAxisTitle",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = 0,
                                    r = 0,
                                    o = 10;
                                return void 0 === s.config.yaxis[t].title.text || t < 0 ? {
                                    xPos: r,
                                    padd: 0
                                } : (a ? (r = e.width + s.config.yaxis[t].title.offsetX + i.width / 2 + o / 2, 0 === (n += 1) && (r -= o / 2)) : (r = -1 * e.width + s.config.yaxis[t].title.offsetX + o / 2 + i.width / 2, s.globals.isBarHorizontal && (o = 25, r = -1 * e.width - s.config.yaxis[t].title.offsetX - o)), {
                                    xPos: r,
                                    padd: o
                                })
                            }
                        }, {
                            key: "setYAxisXPosition",
                            value: function(t, e) {
                                var i = this.w,
                                    a = 0,
                                    s = 0,
                                    n = 18,
                                    r = 1;
                                i.config.yaxis.length > 1 && (this.multipleYs = !0), i.config.yaxis.map((function(o, l) {
                                    var c = i.globals.ignoreYAxisIndexes.indexOf(l) > -1 || !o.show || o.floating || 0 === t[l].width,
                                        h = t[l].width + e[l].width;
                                    o.opposite ? i.globals.isBarHorizontal ? (s = i.globals.gridWidth + i.globals.translateX - 1, i.globals.translateYAxisX[l] = s - o.labels.offsetX) : (s = i.globals.gridWidth + i.globals.translateX + r, c || (r = r + h + 20), i.globals.translateYAxisX[l] = s - o.labels.offsetX + 20) : (a = i.globals.translateX - n, c || (n = n + h + 20), i.globals.translateYAxisX[l] = a + o.labels.offsetX)
                                }))
                            }
                        }, {
                            key: "setYAxisTextAlignments",
                            value: function() {
                                var t = this.w,
                                    e = t.globals.dom.baseEl.getElementsByClassName("apexcharts-yaxis");
                                (e = b.listToArray(e)).forEach((function(e, i) {
                                    var a = t.config.yaxis[i];
                                    if (a && void 0 !== a.labels.align) {
                                        var s = t.globals.dom.baseEl.querySelector(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-texts-g")),
                                            n = t.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxis[rel='".concat(i, "'] .apexcharts-yaxis-label"));
                                        n = b.listToArray(n);
                                        var r = s.getBoundingClientRect();
                                        "left" === a.labels.align ? (n.forEach((function(t, e) {
                                            t.setAttribute("text-anchor", "start")
                                        })), a.opposite || s.setAttribute("transform", "translate(-".concat(r.width, ", 0)"))) : "center" === a.labels.align ? (n.forEach((function(t, e) {
                                            t.setAttribute("text-anchor", "middle")
                                        })), s.setAttribute("transform", "translate(".concat(r.width / 2 * (a.opposite ? 1 : -1), ", 0)"))) : "right" === a.labels.align && (n.forEach((function(t, e) {
                                            t.setAttribute("text-anchor", "end")
                                        })), a.opposite && s.setAttribute("transform", "translate(".concat(r.width, ", 0)")))
                                    }
                                }))
                            }
                        }]), t
                    }(),
                    tt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.documentEvent = b.bind(this.documentEvent, this)
                        }
                        return c(t, [{
                            key: "addEventListener",
                            value: function(t, e) {
                                var i = this.w;
                                i.globals.events.hasOwnProperty(t) ? i.globals.events[t].push(e) : i.globals.events[t] = [e]
                            }
                        }, {
                            key: "removeEventListener",
                            value: function(t, e) {
                                var i = this.w;
                                if (i.globals.events.hasOwnProperty(t)) {
                                    var a = i.globals.events[t].indexOf(e); - 1 !== a && i.globals.events[t].splice(a, 1)
                                }
                            }
                        }, {
                            key: "fireEvent",
                            value: function(t, e) {
                                var i = this.w;
                                if (i.globals.events.hasOwnProperty(t)) {
                                    e && e.length || (e = []);
                                    for (var a = i.globals.events[t], s = a.length, n = 0; n < s; n++) a[n].apply(null, e)
                                }
                            }
                        }, {
                            key: "setupEventHandlers",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = this.ctx,
                                    a = e.globals.dom.baseEl.querySelector(e.globals.chartClass);
                                this.ctx.eventList.forEach((function(t) {
                                    a.addEventListener(t, (function(t) {
                                        var a = Object.assign({}, e, {
                                            seriesIndex: e.globals.capturedSeriesIndex,
                                            dataPointIndex: e.globals.capturedDataPointIndex
                                        });
                                        "mousemove" === t.type || "touchmove" === t.type ? "function" == typeof e.config.chart.events.mouseMove && e.config.chart.events.mouseMove(t, i, a) : "mouseleave" === t.type || "touchleave" === t.type ? "function" == typeof e.config.chart.events.mouseLeave && e.config.chart.events.mouseLeave(t, i, a) : ("mouseup" === t.type && 1 === t.which || "touchend" === t.type) && ("function" == typeof e.config.chart.events.click && e.config.chart.events.click(t, i, a), i.ctx.events.fireEvent("click", [t, i, a]))
                                    }), {
                                        capture: !1,
                                        passive: !0
                                    })
                                })), this.ctx.eventList.forEach((function(i) {
                                    e.globals.dom.baseEl.addEventListener(i, t.documentEvent, {
                                        passive: !0
                                    })
                                })), this.ctx.core.setupBrushHandler()
                            }
                        }, {
                            key: "documentEvent",
                            value: function(t) {
                                var e = this.w,
                                    i = t.target.className;
                                if ("click" === t.type) {
                                    var a = e.globals.dom.baseEl.querySelector(".apexcharts-menu");
                                    a && a.classList.contains("apexcharts-menu-open") && "apexcharts-menu-icon" !== i && a.classList.remove("apexcharts-menu-open")
                                }
                                e.globals.clientX = "touchmove" === t.type ? t.touches[0].clientX : t.clientX, e.globals.clientY = "touchmove" === t.type ? t.touches[0].clientY : t.clientY
                            }
                        }]), t
                    }(),
                    et = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "setCurrentLocaleValues",
                            value: function(t) {
                                var e = this.w.config.chart.locales;
                                window.Apex.chart && window.Apex.chart.locales && window.Apex.chart.locales.length > 0 && (e = this.w.config.chart.locales.concat(window.Apex.chart.locales));
                                var i = e.filter((function(e) {
                                    return e.name === t
                                }))[0];
                                if (!i) throw new Error("Wrong locale name provided. Please make sure you set the correct locale name in options");
                                var a = b.extend(P, i);
                                this.w.globals.locale = a.options
                            }
                        }]), t
                    }(),
                    it = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "drawAxis",
                            value: function(t, e) {
                                var i, a, s = this.w.globals,
                                    n = this.w.config,
                                    r = new q(this.ctx),
                                    o = new J(this.ctx);
                                s.axisCharts && "radar" !== t && (s.isBarHorizontal ? (a = o.drawYaxisInversed(0), i = r.drawXaxisInversed(0), s.dom.elGraphical.add(i), s.dom.elGraphical.add(a)) : (i = r.drawXaxis(), s.dom.elGraphical.add(i), n.yaxis.map((function(t, e) {
                                    -1 === s.ignoreYAxisIndexes.indexOf(e) && (a = o.drawYaxis(e), s.dom.Paper.add(a))
                                }))))
                            }
                        }]), t
                    }(),
                    at = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "drawXCrosshairs",
                            value: function() {
                                var t = this.w,
                                    e = new S(this.ctx),
                                    i = new w(this.ctx),
                                    a = t.config.xaxis.crosshairs.fill.gradient,
                                    s = t.config.xaxis.crosshairs.dropShadow,
                                    n = t.config.xaxis.crosshairs.fill.type,
                                    r = a.colorFrom,
                                    o = a.colorTo,
                                    l = a.opacityFrom,
                                    c = a.opacityTo,
                                    h = a.stops,
                                    d = s.enabled,
                                    u = s.left,
                                    p = s.top,
                                    g = s.blur,
                                    f = s.color,
                                    m = s.opacity,
                                    x = t.config.xaxis.crosshairs.fill.color;
                                if (t.config.xaxis.crosshairs.show) {
                                    "gradient" === n && (x = e.drawGradient("vertical", r, o, l, c, null, h, null));
                                    var v = e.drawRect();
                                    1 === t.config.xaxis.crosshairs.width && (v = e.drawLine());
                                    var y = t.globals.gridHeight;
                                    (!b.isNumber(y) || y < 0) && (y = 0);
                                    var C = t.config.xaxis.crosshairs.width;
                                    (!b.isNumber(C) || C < 0) && (C = 0), v.attr({
                                        class: "apexcharts-xcrosshairs",
                                        x: 0,
                                        y: 0,
                                        y2: y,
                                        width: C,
                                        height: y,
                                        fill: x,
                                        filter: "none",
                                        "fill-opacity": t.config.xaxis.crosshairs.opacity,
                                        stroke: t.config.xaxis.crosshairs.stroke.color,
                                        "stroke-width": t.config.xaxis.crosshairs.stroke.width,
                                        "stroke-dasharray": t.config.xaxis.crosshairs.stroke.dashArray
                                    }), d && (v = i.dropShadow(v, {
                                        left: u,
                                        top: p,
                                        blur: g,
                                        color: f,
                                        opacity: m
                                    })), t.globals.dom.elGraphical.add(v)
                                }
                            }
                        }, {
                            key: "drawYCrosshairs",
                            value: function() {
                                var t = this.w,
                                    e = new S(this.ctx),
                                    i = t.config.yaxis[0].crosshairs,
                                    a = t.globals.barPadForNumericAxis;
                                if (t.config.yaxis[0].crosshairs.show) {
                                    var s = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, i.stroke.color, i.stroke.dashArray, i.stroke.width);
                                    s.attr({
                                        class: "apexcharts-ycrosshairs"
                                    }), t.globals.dom.elGraphical.add(s)
                                }
                                var n = e.drawLine(-a, 0, t.globals.gridWidth + a, 0, i.stroke.color, 0, 0);
                                n.attr({
                                    class: "apexcharts-ycrosshairs-hidden"
                                }), t.globals.dom.elGraphical.add(n)
                            }
                        }]), t
                    }(),
                    st = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "checkResponsiveConfig",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = i.config;
                                if (0 !== a.responsive.length) {
                                    var s = a.responsive.slice();
                                    s.sort((function(t, e) {
                                        return t.breakpoint > e.breakpoint ? 1 : e.breakpoint > t.breakpoint ? -1 : 0
                                    })).reverse();
                                    var n = new W({}),
                                        r = function() {
                                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                                a = s[0].breakpoint,
                                                r = window.innerWidth > 0 ? window.innerWidth : screen.width;
                                            if (r > a) {
                                                var o = C.extendArrayProps(n, i.globals.initialConfig, i);
                                                t = b.extend(o, t), t = b.extend(i.config, t), e.overrideResponsiveOptions(t)
                                            } else
                                                for (var l = 0; l < s.length; l++) r < s[l].breakpoint && (t = C.extendArrayProps(n, s[l].options, i), t = b.extend(i.config, t), e.overrideResponsiveOptions(t))
                                        };
                                    if (t) {
                                        var o = C.extendArrayProps(n, t, i);
                                        o = b.extend(i.config, o), r(o = b.extend(o, t))
                                    } else r({})
                                }
                            }
                        }, {
                            key: "overrideResponsiveOptions",
                            value: function(t) {
                                var e = new W(t).init({
                                    responsiveOverride: !0
                                });
                                this.w.config = e
                            }
                        }]), t
                    }(),
                    nt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.colors = [], this.w = e.w;
                            var i = this.w;
                            this.isColorFn = !1, this.isHeatmapDistributed = "treemap" === i.config.chart.type && i.config.plotOptions.treemap.distributed || "heatmap" === i.config.chart.type && i.config.plotOptions.heatmap.distributed, this.isBarDistributed = i.config.plotOptions.bar.distributed && ("bar" === i.config.chart.type || "rangeBar" === i.config.chart.type)
                        }
                        return c(t, [{
                            key: "init",
                            value: function() {
                                this.setDefaultColors()
                            }
                        }, {
                            key: "setDefaultColors",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = new b;
                                if (e.globals.dom.elWrap.classList.add("apexcharts-theme-".concat(e.config.theme.mode)), void 0 === e.config.colors ? e.globals.colors = this.predefined() : (e.globals.colors = e.config.colors, Array.isArray(e.config.colors) && e.config.colors.length > 0 && "function" == typeof e.config.colors[0] && (e.globals.colors = e.config.series.map((function(i, a) {
                                        var s = e.config.colors[a];
                                        return s || (s = e.config.colors[0]), "function" == typeof s ? (t.isColorFn = !0, s({
                                            value: e.globals.axisCharts ? e.globals.series[a][0] ? e.globals.series[a][0] : 0 : e.globals.series[a],
                                            seriesIndex: a,
                                            dataPointIndex: a,
                                            w: e
                                        })) : s
                                    })))), e.globals.seriesColors.map((function(t, i) {
                                        t && (e.globals.colors[i] = t)
                                    })), e.config.theme.monochrome.enabled) {
                                    var a = [],
                                        s = e.globals.series.length;
                                    (this.isBarDistributed || this.isHeatmapDistributed) && (s = e.globals.series[0].length * e.globals.series.length);
                                    for (var n = e.config.theme.monochrome.color, r = 1 / (s / e.config.theme.monochrome.shadeIntensity), o = e.config.theme.monochrome.shadeTo, l = 0, c = 0; c < s; c++) {
                                        var h = void 0;
                                        "dark" === o ? (h = i.shadeColor(-1 * l, n), l += r) : (h = i.shadeColor(l, n), l += r), a.push(h)
                                    }
                                    e.globals.colors = a.slice()
                                }
                                var d = e.globals.colors.slice();
                                this.pushExtraColors(e.globals.colors), ["fill", "stroke"].forEach((function(i) {
                                    void 0 === e.config[i].colors ? e.globals[i].colors = t.isColorFn ? e.config.colors : d : e.globals[i].colors = e.config[i].colors.slice(), t.pushExtraColors(e.globals[i].colors)
                                })), void 0 === e.config.dataLabels.style.colors ? e.globals.dataLabels.style.colors = d : e.globals.dataLabels.style.colors = e.config.dataLabels.style.colors.slice(), this.pushExtraColors(e.globals.dataLabels.style.colors, 50), void 0 === e.config.plotOptions.radar.polygons.fill.colors ? e.globals.radarPolygons.fill.colors = ["dark" === e.config.theme.mode ? "#424242" : "none"] : e.globals.radarPolygons.fill.colors = e.config.plotOptions.radar.polygons.fill.colors.slice(), this.pushExtraColors(e.globals.radarPolygons.fill.colors, 20), void 0 === e.config.markers.colors ? e.globals.markers.colors = d : e.globals.markers.colors = e.config.markers.colors.slice(), this.pushExtraColors(e.globals.markers.colors)
                            }
                        }, {
                            key: "pushExtraColors",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                    a = this.w,
                                    s = e || a.globals.series.length;
                                if (null === i && (i = this.isBarDistributed || this.isHeatmapDistributed || "heatmap" === a.config.chart.type && a.config.plotOptions.heatmap.colorScale.inverse), i && a.globals.series.length && (s = a.globals.series[a.globals.maxValsInArrayIndex].length * a.globals.series.length), t.length < s)
                                    for (var n = s - t.length, r = 0; r < n; r++) t.push(t[r])
                            }
                        }, {
                            key: "updateThemeOptions",
                            value: function(t) {
                                t.chart = t.chart || {}, t.tooltip = t.tooltip || {};
                                var e = t.theme.mode || "light",
                                    i = t.theme.palette ? t.theme.palette : "dark" === e ? "palette4" : "palette1",
                                    a = t.chart.foreColor ? t.chart.foreColor : "dark" === e ? "#f6f7f8" : "#373d3f";
                                return t.tooltip.theme = e, t.chart.foreColor = a, t.theme.palette = i, t
                            }
                        }, {
                            key: "predefined",
                            value: function() {
                                switch (this.w.config.theme.palette) {
                                    case "palette1":
                                    default:
                                        this.colors = ["#008FFB", "#00E396", "#FEB019", "#FF4560", "#775DD0"];
                                        break;
                                    case "palette2":
                                        this.colors = ["#3f51b5", "#03a9f4", "#4caf50", "#f9ce1d", "#FF9800"];
                                        break;
                                    case "palette3":
                                        this.colors = ["#33b2df", "#546E7A", "#d4526e", "#13d8aa", "#A5978B"];
                                        break;
                                    case "palette4":
                                        this.colors = ["#4ecdc4", "#c7f464", "#81D4FA", "#fd6a6a", "#546E7A"];
                                        break;
                                    case "palette5":
                                        this.colors = ["#2b908f", "#f9a3a4", "#90ee7e", "#fa4443", "#69d2e7"];
                                        break;
                                    case "palette6":
                                        this.colors = ["#449DD1", "#F86624", "#EA3546", "#662E9B", "#C5D86D"];
                                        break;
                                    case "palette7":
                                        this.colors = ["#D7263D", "#1B998B", "#2E294E", "#F46036", "#E2C044"];
                                        break;
                                    case "palette8":
                                        this.colors = ["#662E9B", "#F86624", "#F9C80E", "#EA3546", "#43BCCD"];
                                        break;
                                    case "palette9":
                                        this.colors = ["#5C4742", "#A5978B", "#8D5B4C", "#5A2A27", "#C4BBAF"];
                                        break;
                                    case "palette10":
                                        this.colors = ["#A300D6", "#7D02EB", "#5653FE", "#2983FF", "#00B1F2"]
                                }
                                return this.colors
                            }
                        }]), t
                    }(),
                    rt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "draw",
                            value: function() {
                                this.drawTitleSubtitle("title"), this.drawTitleSubtitle("subtitle")
                            }
                        }, {
                            key: "drawTitleSubtitle",
                            value: function(t) {
                                var e = this.w,
                                    i = "title" === t ? e.config.title : e.config.subtitle,
                                    a = e.globals.svgWidth / 2,
                                    s = i.offsetY,
                                    n = "middle";
                                if ("left" === i.align ? (a = 10, n = "start") : "right" === i.align && (a = e.globals.svgWidth - 10, n = "end"), a += i.offsetX, s = s + parseInt(i.style.fontSize, 10) + i.margin / 2, void 0 !== i.text) {
                                    var r = new S(this.ctx).drawText({
                                        x: a,
                                        y: s,
                                        text: i.text,
                                        textAnchor: n,
                                        fontSize: i.style.fontSize,
                                        fontFamily: i.style.fontFamily,
                                        fontWeight: i.style.fontWeight,
                                        foreColor: i.style.color,
                                        opacity: 1
                                    });
                                    r.node.setAttribute("class", "apexcharts-".concat(t, "-text")), e.globals.dom.Paper.add(r)
                                }
                            }
                        }]), t
                    }(),
                    ot = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.dCtx = e
                        }
                        return c(t, [{
                            key: "getTitleSubtitleCoords",
                            value: function(t) {
                                var e = this.w,
                                    i = 0,
                                    a = 0,
                                    s = "title" === t ? e.config.title.floating : e.config.subtitle.floating,
                                    n = e.globals.dom.baseEl.querySelector(".apexcharts-".concat(t, "-text"));
                                if (null !== n && !s) {
                                    var r = n.getBoundingClientRect();
                                    i = r.width, a = e.globals.axisCharts ? r.height + 5 : r.height
                                }
                                return {
                                    width: i,
                                    height: a
                                }
                            }
                        }, {
                            key: "getLegendsRect",
                            value: function() {
                                var t = this.w,
                                    e = t.globals.dom.baseEl.querySelector(".apexcharts-legend");
                                t.config.legend.height || "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || (e.style.maxHeight = t.globals.svgHeight / 2 + "px");
                                var i = Object.assign({}, b.getBoundingClientRect(e));
                                return null !== e && !t.config.legend.floating && t.config.legend.show ? this.dCtx.lgRect = {
                                    x: i.x,
                                    y: i.y,
                                    height: i.height,
                                    width: 0 === i.height ? 0 : i.width
                                } : this.dCtx.lgRect = {
                                    x: 0,
                                    y: 0,
                                    height: 0,
                                    width: 0
                                }, "left" !== t.config.legend.position && "right" !== t.config.legend.position || 1.5 * this.dCtx.lgRect.width > t.globals.svgWidth && (this.dCtx.lgRect.width = t.globals.svgWidth / 1.5), this.dCtx.lgRect
                            }
                        }, {
                            key: "getLargestStringFromMultiArr",
                            value: function(t, e) {
                                var i = t;
                                if (this.w.globals.isMultiLineX) {
                                    var a = e.map((function(t, e) {
                                            return Array.isArray(t) ? t.length : 1
                                        })),
                                        s = Math.max.apply(Math, m(a));
                                    i = e[a.indexOf(s)]
                                }
                                return i
                            }
                        }]), t
                    }(),
                    lt = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.dCtx = e
                        }
                        return c(t, [{
                            key: "getxAxisLabelsCoords",
                            value: function() {
                                var t, e = this.w,
                                    i = e.globals.labels.slice();
                                if (e.config.xaxis.convertedCatToNumeric && 0 === i.length && (i = e.globals.categoryLabels), e.globals.timescaleLabels.length > 0) {
                                    var a = this.getxAxisTimeScaleLabelsCoords();
                                    t = {
                                        width: a.width,
                                        height: a.height
                                    }, e.globals.rotateXLabels = !1
                                } else {
                                    this.dCtx.lgWidthForSideLegends = "left" !== e.config.legend.position && "right" !== e.config.legend.position || e.config.legend.floating ? 0 : this.dCtx.lgRect.width;
                                    var s = e.globals.xLabelFormatter,
                                        n = b.getLargestStringFromArr(i),
                                        r = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, i);
                                    e.globals.isBarHorizontal && (r = n = e.globals.yAxisScale[0].result.reduce((function(t, e) {
                                        return t.length > e.length ? t : e
                                    }), 0));
                                    var o = new V(this.dCtx.ctx),
                                        l = n;
                                    n = o.xLabelFormat(s, n, l, {
                                        i: void 0,
                                        dateFormatter: new F(this.dCtx.ctx).formatDate,
                                        w: e
                                    }), r = o.xLabelFormat(s, r, l, {
                                        i: void 0,
                                        dateFormatter: new F(this.dCtx.ctx).formatDate,
                                        w: e
                                    }), (e.config.xaxis.convertedCatToNumeric && void 0 === n || "" === String(n).trim()) && (r = n = "1");
                                    var c = new S(this.dCtx.ctx),
                                        h = c.getTextRects(n, e.config.xaxis.labels.style.fontSize),
                                        d = h;
                                    if (n !== r && (d = c.getTextRects(r, e.config.xaxis.labels.style.fontSize)), (t = {
                                            width: h.width >= d.width ? h.width : d.width,
                                            height: h.height >= d.height ? h.height : d.height
                                        }).width * i.length > e.globals.svgWidth - this.dCtx.lgWidthForSideLegends - this.dCtx.yAxisWidth - this.dCtx.gridPad.left - this.dCtx.gridPad.right && 0 !== e.config.xaxis.labels.rotate || e.config.xaxis.labels.rotateAlways) {
                                        if (!e.globals.isBarHorizontal) {
                                            e.globals.rotateXLabels = !0;
                                            var u = function(t) {
                                                return c.getTextRects(t, e.config.xaxis.labels.style.fontSize, e.config.xaxis.labels.style.fontFamily, "rotate(".concat(e.config.xaxis.labels.rotate, " 0 0)"), !1)
                                            };
                                            h = u(n), n !== r && (d = u(r)), t.height = (h.height > d.height ? h.height : d.height) / 1.5, t.width = h.width > d.width ? h.width : d.width
                                        }
                                    } else e.globals.rotateXLabels = !1
                                }
                                return e.config.xaxis.labels.show || (t = {
                                    width: 0,
                                    height: 0
                                }), {
                                    width: t.width,
                                    height: t.height
                                }
                            }
                        }, {
                            key: "getxAxisGroupLabelsCoords",
                            value: function() {
                                var t, e = this.w;
                                if (!e.globals.hasGroups) return {
                                    width: 0,
                                    height: 0
                                };
                                var i, a = (null === (t = e.config.xaxis.group.style) || void 0 === t ? void 0 : t.fontSize) || e.config.xaxis.labels.style.fontSize,
                                    s = e.globals.groups.map((function(t) {
                                        return t.title
                                    })),
                                    n = b.getLargestStringFromArr(s),
                                    r = this.dCtx.dimHelpers.getLargestStringFromMultiArr(n, s),
                                    o = new S(this.dCtx.ctx),
                                    l = o.getTextRects(n, a),
                                    c = l;
                                return n !== r && (c = o.getTextRects(r, a)), i = {
                                    width: l.width >= c.width ? l.width : c.width,
                                    height: l.height >= c.height ? l.height : c.height
                                }, e.config.xaxis.labels.show || (i = {
                                    width: 0,
                                    height: 0
                                }), {
                                    width: i.width,
                                    height: i.height
                                }
                            }
                        }, {
                            key: "getxAxisTitleCoords",
                            value: function() {
                                var t = this.w,
                                    e = 0,
                                    i = 0;
                                if (void 0 !== t.config.xaxis.title.text) {
                                    var a = new S(this.dCtx.ctx).getTextRects(t.config.xaxis.title.text, t.config.xaxis.title.style.fontSize);
                                    e = a.width, i = a.height
                                }
                                return {
                                    width: e,
                                    height: i
                                }
                            }
                        }, {
                            key: "getxAxisTimeScaleLabelsCoords",
                            value: function() {
                                var t, e = this.w;
                                this.dCtx.timescaleLabels = e.globals.timescaleLabels.slice();
                                var i = this.dCtx.timescaleLabels.map((function(t) {
                                        return t.value
                                    })),
                                    a = i.reduce((function(t, e) {
                                        return void 0 === t ? (console.error("You have possibly supplied invalid Date format. Please supply a valid JavaScript Date"), 0) : t.length > e.length ? t : e
                                    }), 0);
                                return 1.05 * (t = new S(this.dCtx.ctx).getTextRects(a, e.config.xaxis.labels.style.fontSize)).width * i.length > e.globals.gridWidth && 0 !== e.config.xaxis.labels.rotate && (e.globals.overlappingXLabels = !0), t
                            }
                        }, {
                            key: "additionalPaddingXLabels",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = i.globals,
                                    s = i.config,
                                    n = s.xaxis.type,
                                    r = t.width;
                                a.skipLastTimelinelabel = !1, a.skipFirstTimelinelabel = !1;
                                var o = i.config.yaxis[0].opposite && i.globals.isBarHorizontal,
                                    l = function(t, o) {
                                        (function(t) {
                                            return -1 !== a.collapsedSeriesIndices.indexOf(t)
                                        })(o) || function(t) {
                                            if (e.dCtx.timescaleLabels && e.dCtx.timescaleLabels.length) {
                                                var o = e.dCtx.timescaleLabels[0],
                                                    l = e.dCtx.timescaleLabels[e.dCtx.timescaleLabels.length - 1].position + r / 1.75 - e.dCtx.yAxisWidthRight,
                                                    c = o.position - r / 1.75 + e.dCtx.yAxisWidthLeft,
                                                    h = "right" === i.config.legend.position && e.dCtx.lgRect.width > 0 ? e.dCtx.lgRect.width : 0;
                                                l > a.svgWidth - a.translateX - h && (a.skipLastTimelinelabel = !0), c < -(t.show && !t.floating || "bar" !== s.chart.type && "candlestick" !== s.chart.type && "rangeBar" !== s.chart.type && "boxPlot" !== s.chart.type ? 10 : r / 1.75) && (a.skipFirstTimelinelabel = !0)
                                            } else "datetime" === n ? e.dCtx.gridPad.right < r && !a.rotateXLabels && (a.skipLastTimelinelabel = !0) : "datetime" !== n && e.dCtx.gridPad.right < r / 2 - e.dCtx.yAxisWidthRight && !a.rotateXLabels && !i.config.xaxis.labels.trim && ("between" !== i.config.xaxis.tickPlacement || i.globals.isBarHorizontal) && (e.dCtx.xPadRight = r / 2 + 1)
                                        }(t)
                                    };
                                s.yaxis.forEach((function(t, i) {
                                    o ? (e.dCtx.gridPad.left < r && (e.dCtx.xPadLeft = r / 2 + 1), e.dCtx.xPadRight = r / 2 + 1) : l(t, i)
                                }))
                            }
                        }]), t
                    }(),
                    ct = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.dCtx = e
                        }
                        return c(t, [{
                            key: "getyAxisLabelsCoords",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = [],
                                    a = 10,
                                    s = new j(this.dCtx.ctx);
                                return e.config.yaxis.map((function(n, r) {
                                    var o = e.globals.yAxisScale[r],
                                        l = 0;
                                    if (!s.isYAxisHidden(r) && n.labels.show && void 0 !== n.labels.minWidth && (l = n.labels.minWidth), !s.isYAxisHidden(r) && n.labels.show && o.result.length) {
                                        var c = e.globals.yLabelFormatters[r],
                                            h = o.niceMin === Number.MIN_VALUE ? 0 : o.niceMin,
                                            d = String(h).length > String(o.niceMax).length ? h : o.niceMax,
                                            u = c(d, {
                                                seriesIndex: r,
                                                dataPointIndex: -1,
                                                w: e
                                            }),
                                            p = u;
                                        if (void 0 !== u && 0 !== u.length || (u = d), e.globals.isBarHorizontal) {
                                            a = 0;
                                            var g = e.globals.labels.slice();
                                            u = c(u = b.getLargestStringFromArr(g), {
                                                seriesIndex: r,
                                                dataPointIndex: -1,
                                                w: e
                                            }), p = t.dCtx.dimHelpers.getLargestStringFromMultiArr(u, g)
                                        }
                                        var f = new S(t.dCtx.ctx),
                                            m = "rotate(".concat(n.labels.rotate, " 0 0)"),
                                            x = f.getTextRects(u, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1),
                                            v = x;
                                        u !== p && (v = f.getTextRects(p, n.labels.style.fontSize, n.labels.style.fontFamily, m, !1)), i.push({
                                            width: (l > v.width || l > x.width ? l : v.width > x.width ? v.width : x.width) + a,
                                            height: v.height > x.height ? v.height : x.height
                                        })
                                    } else i.push({
                                        width: 0,
                                        height: 0
                                    })
                                })), i
                            }
                        }, {
                            key: "getyAxisTitleCoords",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = [];
                                return e.config.yaxis.map((function(e, a) {
                                    if (e.show && void 0 !== e.title.text) {
                                        var s = new S(t.dCtx.ctx),
                                            n = "rotate(".concat(e.title.rotate, " 0 0)"),
                                            r = s.getTextRects(e.title.text, e.title.style.fontSize, e.title.style.fontFamily, n, !1);
                                        i.push({
                                            width: r.width,
                                            height: r.height
                                        })
                                    } else i.push({
                                        width: 0,
                                        height: 0
                                    })
                                })), i
                            }
                        }, {
                            key: "getTotalYAxisWidth",
                            value: function() {
                                var t = this.w,
                                    e = 0,
                                    i = 0,
                                    a = 0,
                                    s = t.globals.yAxisScale.length > 1 ? 10 : 0,
                                    n = new j(this.dCtx.ctx),
                                    r = function(r, o) {
                                        var l = t.config.yaxis[o].floating,
                                            c = 0;
                                        r.width > 0 && !l ? (c = r.width + s, function(e) {
                                            return t.globals.ignoreYAxisIndexes.indexOf(e) > -1
                                        }(o) && (c = c - r.width - s)) : c = l || n.isYAxisHidden(o) ? 0 : 5, t.config.yaxis[o].opposite ? a += c : i += c, e += c
                                    };
                                return t.globals.yLabelsCoords.map((function(t, e) {
                                    r(t, e)
                                })), t.globals.yTitleCoords.map((function(t, e) {
                                    r(t, e)
                                })), t.globals.isBarHorizontal && !t.config.yaxis[0].floating && (e = t.globals.yLabelsCoords[0].width + t.globals.yTitleCoords[0].width + 15), this.dCtx.yAxisWidthLeft = i, this.dCtx.yAxisWidthRight = a, e
                            }
                        }]), t
                    }(),
                    ht = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.dCtx = e
                        }
                        return c(t, [{
                            key: "gridPadForColumnsInNumericAxis",
                            value: function(t) {
                                var e = this.w;
                                if (e.globals.noData || e.globals.allSeriesCollapsed) return 0;
                                var i = function(t) {
                                        return "bar" === t || "rangeBar" === t || "candlestick" === t || "boxPlot" === t
                                    },
                                    a = e.config.chart.type,
                                    s = 0,
                                    n = i(a) ? e.config.series.length : 1;
                                if (e.globals.comboBarCount > 0 && (n = e.globals.comboBarCount), e.globals.collapsedSeries.forEach((function(t) {
                                        i(t.type) && (n -= 1)
                                    })), e.config.chart.stacked && (n = 1), (i(a) || e.globals.comboBarCount > 0) && e.globals.isXNumeric && !e.globals.isBarHorizontal && n > 0) {
                                    var r, o, l = Math.abs(e.globals.initialMaxX - e.globals.initialMinX);
                                    l <= 3 && (l = e.globals.dataPoints), r = l / t, e.globals.minXDiff && e.globals.minXDiff / r > 0 && (o = e.globals.minXDiff / r), o > t / 2 && (o /= 2), (s = o / n * parseInt(e.config.plotOptions.bar.columnWidth, 10) / 100) < 1 && (s = 1), s = s / (n > 1 ? 1 : 1.5) + 5, e.globals.barPadForNumericAxis = s
                                }
                                return s
                            }
                        }, {
                            key: "gridPadFortitleSubtitle",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = e.globals,
                                    a = this.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 10;
                                ["title", "subtitle"].forEach((function(i) {
                                    void 0 !== e.config[i].text ? a += e.config[i].margin : a += t.dCtx.isSparkline || !e.globals.axisCharts ? 0 : 5
                                })), !e.config.legend.show || "bottom" !== e.config.legend.position || e.config.legend.floating || e.globals.axisCharts || (a += 10);
                                var s = this.dCtx.dimHelpers.getTitleSubtitleCoords("title"),
                                    n = this.dCtx.dimHelpers.getTitleSubtitleCoords("subtitle");
                                i.gridHeight = i.gridHeight - s.height - n.height - a, i.translateY = i.translateY + s.height + n.height + a
                            }
                        }, {
                            key: "setGridXPosForDualYAxis",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new j(this.dCtx.ctx);
                                i.config.yaxis.map((function(s, n) {
                                    -1 !== i.globals.ignoreYAxisIndexes.indexOf(n) || s.floating || a.isYAxisHidden(n) || (s.opposite && (i.globals.translateX = i.globals.translateX - (e[n].width + t[n].width) - parseInt(i.config.yaxis[n].labels.style.fontSize, 10) / 1.2 - 12), i.globals.translateX < 2 && (i.globals.translateX = 2))
                                }))
                            }
                        }]), t
                    }(),
                    dt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.lgRect = {}, this.yAxisWidth = 0, this.yAxisWidthLeft = 0, this.yAxisWidthRight = 0, this.xAxisHeight = 0, this.isSparkline = this.w.config.chart.sparkline.enabled, this.dimHelpers = new ot(this), this.dimYAxis = new ct(this), this.dimXAxis = new lt(this), this.dimGrid = new ht(this), this.lgWidthForSideLegends = 0, this.gridPad = this.w.config.grid.padding, this.xPadRight = 0, this.xPadLeft = 0
                        }
                        return c(t, [{
                            key: "plotCoords",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = e.globals;
                                this.lgRect = this.dimHelpers.getLegendsRect(), this.isSparkline && (e.config.markers.discrete.length > 0 || e.config.markers.size > 0) && Object.entries(this.gridPad).forEach((function(e) {
                                    var i = function(t, e) {
                                            return function(t) {
                                                if (Array.isArray(t)) return t
                                            }(t) || function(t, e) {
                                                var i = null == t ? null : "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
                                                if (null != i) {
                                                    var a, s, n = [],
                                                        r = !0,
                                                        o = !1;
                                                    try {
                                                        for (i = i.call(t); !(r = (a = i.next()).done) && (n.push(a.value), !e || n.length !== e); r = !0);
                                                    } catch (t) {
                                                        o = !0, s = t
                                                    } finally {
                                                        try {
                                                            r || null == i.return || i.return()
                                                        } finally {
                                                            if (o) throw s
                                                        }
                                                    }
                                                    return n
                                                }
                                            }(t, e) || x(t, e) || function() {
                                                throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
                                            }()
                                        }(e, 2),
                                        a = i[0],
                                        s = i[1];
                                    t.gridPad[a] = Math.max(s, t.w.globals.markers.largestSize / 1.5)
                                })), i.axisCharts ? this.setDimensionsForAxisCharts() : this.setDimensionsForNonAxisCharts(), this.dimGrid.gridPadFortitleSubtitle(), i.gridHeight = i.gridHeight - this.gridPad.top - this.gridPad.bottom, i.gridWidth = i.gridWidth - this.gridPad.left - this.gridPad.right - this.xPadRight - this.xPadLeft;
                                var a = this.dimGrid.gridPadForColumnsInNumericAxis(i.gridWidth);
                                i.gridWidth = i.gridWidth - 2 * a, i.translateX = i.translateX + this.gridPad.left + this.xPadLeft + (a > 0 ? a + 4 : 0), i.translateY = i.translateY + this.gridPad.top
                            }
                        }, {
                            key: "setDimensionsForAxisCharts",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = e.globals,
                                    a = this.dimYAxis.getyAxisLabelsCoords(),
                                    s = this.dimYAxis.getyAxisTitleCoords();
                                e.globals.yLabelsCoords = [], e.globals.yTitleCoords = [], e.config.yaxis.map((function(t, i) {
                                    e.globals.yLabelsCoords.push({
                                        width: a[i].width,
                                        index: i
                                    }), e.globals.yTitleCoords.push({
                                        width: s[i].width,
                                        index: i
                                    })
                                })), this.yAxisWidth = this.dimYAxis.getTotalYAxisWidth();
                                var n = this.dimXAxis.getxAxisLabelsCoords(),
                                    r = this.dimXAxis.getxAxisGroupLabelsCoords(),
                                    o = this.dimXAxis.getxAxisTitleCoords();
                                this.conditionalChecksForAxisCoords(n, o, r), i.translateXAxisY = e.globals.rotateXLabels ? this.xAxisHeight / 8 : -4, i.translateXAxisX = e.globals.rotateXLabels && e.globals.isXNumeric && e.config.xaxis.labels.rotate <= -45 ? -this.xAxisWidth / 4 : 0, e.globals.isBarHorizontal && (i.rotateXLabels = !1, i.translateXAxisY = parseInt(e.config.xaxis.labels.style.fontSize, 10) / 1.5 * -1), i.translateXAxisY = i.translateXAxisY + e.config.xaxis.labels.offsetY, i.translateXAxisX = i.translateXAxisX + e.config.xaxis.labels.offsetX;
                                var l = this.yAxisWidth,
                                    c = this.xAxisHeight;
                                i.xAxisLabelsHeight = this.xAxisHeight - o.height, i.xAxisGroupLabelsHeight = i.xAxisLabelsHeight - n.height, i.xAxisLabelsWidth = this.xAxisWidth, i.xAxisHeight = this.xAxisHeight;
                                var h = 10;
                                ("radar" === e.config.chart.type || this.isSparkline) && (l = 0, c = i.goldenPadding), this.isSparkline && (this.lgRect = {
                                    height: 0,
                                    width: 0
                                }), (this.isSparkline || "treemap" === e.config.chart.type) && (l = 0, c = 0, h = 0), this.isSparkline || this.dimXAxis.additionalPaddingXLabels(n);
                                var d = function() {
                                    i.translateX = l, i.gridHeight = i.svgHeight - t.lgRect.height - c - (t.isSparkline || "treemap" === e.config.chart.type ? 0 : e.globals.rotateXLabels ? 10 : 15), i.gridWidth = i.svgWidth - l
                                };
                                switch ("top" === e.config.xaxis.position && (h = i.xAxisHeight - e.config.xaxis.axisTicks.height - 5), e.config.legend.position) {
                                    case "bottom":
                                        i.translateY = h, d();
                                        break;
                                    case "top":
                                        i.translateY = this.lgRect.height + h, d();
                                        break;
                                    case "left":
                                        i.translateY = h, i.translateX = this.lgRect.width + l, i.gridHeight = i.svgHeight - c - 12, i.gridWidth = i.svgWidth - this.lgRect.width - l;
                                        break;
                                    case "right":
                                        i.translateY = h, i.translateX = l, i.gridHeight = i.svgHeight - c - 12, i.gridWidth = i.svgWidth - this.lgRect.width - l - 5;
                                        break;
                                    default:
                                        throw new Error("Legend position not supported")
                                }
                                this.dimGrid.setGridXPosForDualYAxis(s, a), new J(this.ctx).setYAxisXPosition(a, s)
                            }
                        }, {
                            key: "setDimensionsForNonAxisCharts",
                            value: function() {
                                var t = this.w,
                                    e = t.globals,
                                    i = t.config,
                                    a = 0;
                                t.config.legend.show && !t.config.legend.floating && (a = 20);
                                var s = "pie" === i.chart.type || "polarArea" === i.chart.type || "donut" === i.chart.type ? "pie" : "radialBar",
                                    n = i.plotOptions[s].offsetY,
                                    r = i.plotOptions[s].offsetX;
                                if (!i.legend.show || i.legend.floating) return e.gridHeight = e.svgHeight - i.grid.padding.left + i.grid.padding.right, e.gridWidth = e.gridHeight, e.translateY = n, void(e.translateX = r + (e.svgWidth - e.gridWidth) / 2);
                                switch (i.legend.position) {
                                    case "bottom":
                                        e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = n - 10, e.translateX = r + (e.svgWidth - e.gridWidth) / 2;
                                        break;
                                    case "top":
                                        e.gridHeight = e.svgHeight - this.lgRect.height - e.goldenPadding, e.gridWidth = e.svgWidth, e.translateY = this.lgRect.height + n + 10, e.translateX = r + (e.svgWidth - e.gridWidth) / 2;
                                        break;
                                    case "left":
                                        e.gridWidth = e.svgWidth - this.lgRect.width - a, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = n, e.translateX = r + this.lgRect.width + a;
                                        break;
                                    case "right":
                                        e.gridWidth = e.svgWidth - this.lgRect.width - a - 5, e.gridHeight = "auto" !== i.chart.height ? e.svgHeight : e.gridWidth, e.translateY = n, e.translateX = r + 10;
                                        break;
                                    default:
                                        throw new Error("Legend position not supported")
                                }
                            }
                        }, {
                            key: "conditionalChecksForAxisCoords",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = a.globals.hasGroups ? 2 : 1,
                                    n = i.height + t.height + e.height,
                                    r = a.globals.isMultiLineX ? 1.2 : a.globals.LINE_HEIGHT_RATIO,
                                    o = a.globals.rotateXLabels ? 22 : 10,
                                    l = a.globals.rotateXLabels && "bottom" === a.config.legend.position ? 10 : 0;
                                this.xAxisHeight = n * r + s * o + l, this.xAxisWidth = t.width, this.xAxisHeight - e.height > a.config.xaxis.labels.maxHeight && (this.xAxisHeight = a.config.xaxis.labels.maxHeight), a.config.xaxis.labels.minHeight && this.xAxisHeight < a.config.xaxis.labels.minHeight && (this.xAxisHeight = a.config.xaxis.labels.minHeight), a.config.xaxis.floating && (this.xAxisHeight = 0);
                                var c = 0,
                                    h = 0;
                                a.config.yaxis.forEach((function(t) {
                                    c += t.labels.minWidth, h += t.labels.maxWidth
                                })), this.yAxisWidth < c && (this.yAxisWidth = c), this.yAxisWidth > h && (this.yAxisWidth = h)
                            }
                        }]), t
                    }(),
                    ut = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.lgCtx = e
                        }
                        return c(t, [{
                            key: "getLegendStyles",
                            value: function() {
                                var t = document.createElement("style");
                                t.setAttribute("type", "text/css");
                                var e = document.createTextNode("\t\n    \t\n      .apexcharts-legend {\t\n        display: flex;\t\n        overflow: auto;\t\n        padding: 0 10px;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom, .apexcharts-legend.apx-legend-position-top {\t\n        flex-wrap: wrap\t\n      }\t\n      .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        flex-direction: column;\t\n        bottom: 0;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-left, .apexcharts-legend.apx-legend-position-top.apexcharts-align-left, .apexcharts-legend.apx-legend-position-right, .apexcharts-legend.apx-legend-position-left {\t\n        justify-content: flex-start;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-center, .apexcharts-legend.apx-legend-position-top.apexcharts-align-center {\t\n        justify-content: center;  \t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom.apexcharts-align-right, .apexcharts-legend.apx-legend-position-top.apexcharts-align-right {\t\n        justify-content: flex-end;\t\n      }\t\n      .apexcharts-legend-series {\t\n        cursor: pointer;\t\n        line-height: normal;\t\n      }\t\n      .apexcharts-legend.apx-legend-position-bottom .apexcharts-legend-series, .apexcharts-legend.apx-legend-position-top .apexcharts-legend-series{\t\n        display: flex;\t\n        align-items: center;\t\n      }\t\n      .apexcharts-legend-text {\t\n        position: relative;\t\n        font-size: 14px;\t\n      }\t\n      .apexcharts-legend-text *, .apexcharts-legend-marker * {\t\n        pointer-events: none;\t\n      }\t\n      .apexcharts-legend-marker {\t\n        position: relative;\t\n        display: inline-block;\t\n        cursor: pointer;\t\n        margin-right: 3px;\t\n        border-style: solid;\n      }\t\n      \t\n      .apexcharts-legend.apexcharts-align-right .apexcharts-legend-series, .apexcharts-legend.apexcharts-align-left .apexcharts-legend-series{\t\n        display: inline-block;\t\n      }\t\n      .apexcharts-legend-series.apexcharts-no-click {\t\n        cursor: auto;\t\n      }\t\n      .apexcharts-legend .apexcharts-hidden-zero-series, .apexcharts-legend .apexcharts-hidden-null-series {\t\n        display: none !important;\t\n      }\t\n      .apexcharts-inactive-legend {\t\n        opacity: 0.45;\t\n      }");
                                return t.appendChild(e), t
                            }
                        }, {
                            key: "getLegendBBox",
                            value: function() {
                                var t = this.w.globals.dom.baseEl.querySelector(".apexcharts-legend").getBoundingClientRect(),
                                    e = t.width;
                                return {
                                    clwh: t.height,
                                    clww: e
                                }
                            }
                        }, {
                            key: "appendToForeignObject",
                            value: function() {
                                var t = this.w.globals;
                                t.dom.elLegendForeign = document.createElementNS(t.SVGNS, "foreignObject");
                                var e = t.dom.elLegendForeign;
                                e.setAttribute("x", 0), e.setAttribute("y", 0), e.setAttribute("width", t.svgWidth), e.setAttribute("height", t.svgHeight), t.dom.elLegendWrap.setAttribute("xmlns", "http://www.w3.org/1999/xhtml"), e.appendChild(t.dom.elLegendWrap), e.appendChild(this.getLegendStyles()), t.dom.Paper.node.insertBefore(e, t.dom.elGraphical.node)
                            }
                        }, {
                            key: "toggleDataSeries",
                            value: function(t, e) {
                                var i = this,
                                    a = this.w;
                                if (a.globals.axisCharts || "radialBar" === a.config.chart.type) {
                                    a.globals.resized = !0;
                                    var s = null,
                                        n = null;
                                    a.globals.risingSeries = [], a.globals.axisCharts ? (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(t, "']")), n = parseInt(s.getAttribute("data:realIndex"), 10)) : (s = a.globals.dom.baseEl.querySelector(".apexcharts-series[rel='".concat(t + 1, "']")), n = parseInt(s.getAttribute("rel"), 10) - 1), e ? [{
                                        cs: a.globals.collapsedSeries,
                                        csi: a.globals.collapsedSeriesIndices
                                    }, {
                                        cs: a.globals.ancillaryCollapsedSeries,
                                        csi: a.globals.ancillaryCollapsedSeriesIndices
                                    }].forEach((function(t) {
                                        i.riseCollapsedSeries(t.cs, t.csi, n)
                                    })) : this.hideSeries({
                                        seriesEl: s,
                                        realIndex: n
                                    })
                                } else {
                                    var r = a.globals.dom.Paper.select(" .apexcharts-series[rel='".concat(t + 1, "'] path")),
                                        o = a.config.chart.type;
                                    if ("pie" === o || "polarArea" === o || "donut" === o) {
                                        var l = a.config.plotOptions.pie.donut.labels;
                                        new S(this.lgCtx.ctx).pathMouseDown(r.members[0], null), this.lgCtx.ctx.pie.printDataLabelsInner(r.members[0].node, l)
                                    }
                                    r.fire("click")
                                }
                            }
                        }, {
                            key: "hideSeries",
                            value: function(t) {
                                var e = t.seriesEl,
                                    i = t.realIndex,
                                    a = this.w,
                                    s = b.clone(a.config.series);
                                if (a.globals.axisCharts) {
                                    var n = !1;
                                    if (a.config.yaxis[i] && a.config.yaxis[i].show && a.config.yaxis[i].showAlways && (n = !0, a.globals.ancillaryCollapsedSeriesIndices.indexOf(i) < 0 && (a.globals.ancillaryCollapsedSeries.push({
                                            index: i,
                                            data: s[i].data.slice(),
                                            type: e.parentNode.className.baseVal.split("-")[1]
                                        }), a.globals.ancillaryCollapsedSeriesIndices.push(i))), !n) {
                                        a.globals.collapsedSeries.push({
                                            index: i,
                                            data: s[i].data.slice(),
                                            type: e.parentNode.className.baseVal.split("-")[1]
                                        }), a.globals.collapsedSeriesIndices.push(i);
                                        var r = a.globals.risingSeries.indexOf(i);
                                        a.globals.risingSeries.splice(r, 1)
                                    }
                                } else a.globals.collapsedSeries.push({
                                    index: i,
                                    data: s[i]
                                }), a.globals.collapsedSeriesIndices.push(i);
                                for (var o = e.childNodes, l = 0; l < o.length; l++) o[l].classList.contains("apexcharts-series-markers-wrap") && (o[l].classList.contains("apexcharts-hide") ? o[l].classList.remove("apexcharts-hide") : o[l].classList.add("apexcharts-hide"));
                                a.globals.allSeriesCollapsed = a.globals.collapsedSeries.length === a.config.series.length, s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled)
                            }
                        }, {
                            key: "riseCollapsedSeries",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = b.clone(a.config.series);
                                if (t.length > 0) {
                                    for (var n = 0; n < t.length; n++) t[n].index === i && (a.globals.axisCharts ? (s[i].data = t[n].data.slice(), t.splice(n, 1), e.splice(n, 1), a.globals.risingSeries.push(i)) : (s[i] = t[n].data, t.splice(n, 1), e.splice(n, 1), a.globals.risingSeries.push(i)));
                                    s = this._getSeriesBasedOnCollapsedState(s), this.lgCtx.ctx.updateHelpers._updateSeries(s, a.config.chart.animations.dynamicAnimation.enabled)
                                }
                            }
                        }, {
                            key: "_getSeriesBasedOnCollapsedState",
                            value: function(t) {
                                var e = this.w;
                                return e.globals.axisCharts ? t.forEach((function(i, a) {
                                    e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a].data = [])
                                })) : t.forEach((function(i, a) {
                                    e.globals.collapsedSeriesIndices.indexOf(a) > -1 && (t[a] = 0)
                                })), t
                            }
                        }]), t
                    }(),
                    pt = function() {
                        function t(e, i) {
                            o(this, t), this.ctx = e, this.w = e.w, this.onLegendClick = this.onLegendClick.bind(this), this.onLegendHovered = this.onLegendHovered.bind(this), this.isBarsDistributed = "bar" === this.w.config.chart.type && this.w.config.plotOptions.bar.distributed && 1 === this.w.config.series.length, this.legendHelpers = new ut(this)
                        }
                        return c(t, [{
                            key: "init",
                            value: function() {
                                var t = this.w,
                                    e = t.globals,
                                    i = t.config;
                                if ((i.legend.showForSingleSeries && 1 === e.series.length || this.isBarsDistributed || e.series.length > 1 || !e.axisCharts) && i.legend.show) {
                                    for (; e.dom.elLegendWrap.firstChild;) e.dom.elLegendWrap.removeChild(e.dom.elLegendWrap.firstChild);
                                    this.drawLegends(), b.isIE11() ? document.getElementsByTagName("head")[0].appendChild(this.legendHelpers.getLegendStyles()) : this.legendHelpers.appendToForeignObject(), "bottom" === i.legend.position || "top" === i.legend.position ? this.legendAlignHorizontal() : "right" !== i.legend.position && "left" !== i.legend.position || this.legendAlignVertical()
                                }
                            }
                        }, {
                            key: "drawLegends",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = e.config.legend.fontFamily,
                                    a = e.globals.seriesNames,
                                    s = e.globals.colors.slice();
                                if ("heatmap" === e.config.chart.type) {
                                    var n = e.config.plotOptions.heatmap.colorScale.ranges;
                                    a = n.map((function(t) {
                                        return t.name ? t.name : t.from + " - " + t.to
                                    })), s = n.map((function(t) {
                                        return t.color
                                    }))
                                } else this.isBarsDistributed && (a = e.globals.labels.slice());
                                e.config.legend.customLegendItems.length && (a = e.config.legend.customLegendItems);
                                for (var r = e.globals.legendFormatter, o = e.config.legend.inverseOrder, l = o ? a.length - 1 : 0; o ? l >= 0 : l <= a.length - 1; o ? l-- : l++) {
                                    var c = r(a[l], {
                                            seriesIndex: l,
                                            w: e
                                        }),
                                        h = !1,
                                        d = !1;
                                    if (e.globals.collapsedSeries.length > 0)
                                        for (var u = 0; u < e.globals.collapsedSeries.length; u++) e.globals.collapsedSeries[u].index === l && (h = !0);
                                    if (e.globals.ancillaryCollapsedSeriesIndices.length > 0)
                                        for (var p = 0; p < e.globals.ancillaryCollapsedSeriesIndices.length; p++) e.globals.ancillaryCollapsedSeriesIndices[p] === l && (d = !0);
                                    var g = document.createElement("span");
                                    g.classList.add("apexcharts-legend-marker");
                                    var f = e.config.legend.markers.offsetX,
                                        m = e.config.legend.markers.offsetY,
                                        x = e.config.legend.markers.height,
                                        v = e.config.legend.markers.width,
                                        y = e.config.legend.markers.strokeWidth,
                                        w = e.config.legend.markers.strokeColor,
                                        k = e.config.legend.markers.radius,
                                        A = g.style;
                                    A.background = s[l], A.color = s[l], A.setProperty("background", s[l], "important"), e.config.legend.markers.fillColors && e.config.legend.markers.fillColors[l] && (A.background = e.config.legend.markers.fillColors[l]), void 0 !== e.globals.seriesColors[l] && (A.background = e.globals.seriesColors[l], A.color = e.globals.seriesColors[l]), A.height = Array.isArray(x) ? parseFloat(x[l]) + "px" : parseFloat(x) + "px", A.width = Array.isArray(v) ? parseFloat(v[l]) + "px" : parseFloat(v) + "px", A.left = (Array.isArray(f) ? parseFloat(f[l]) : parseFloat(f)) + "px", A.top = (Array.isArray(m) ? parseFloat(m[l]) : parseFloat(m)) + "px", A.borderWidth = Array.isArray(y) ? y[l] : y, A.borderColor = Array.isArray(w) ? w[l] : w, A.borderRadius = Array.isArray(k) ? parseFloat(k[l]) + "px" : parseFloat(k) + "px", e.config.legend.markers.customHTML && (Array.isArray(e.config.legend.markers.customHTML) ? e.config.legend.markers.customHTML[l] && (g.innerHTML = e.config.legend.markers.customHTML[l]()) : g.innerHTML = e.config.legend.markers.customHTML()), S.setAttrs(g, {
                                        rel: l + 1,
                                        "data:collapsed": h || d
                                    }), (h || d) && g.classList.add("apexcharts-inactive-legend");
                                    var E = document.createElement("div"),
                                        T = document.createElement("span");
                                    T.classList.add("apexcharts-legend-text"), T.innerHTML = Array.isArray(c) ? c.join(" ") : c;
                                    var P = e.config.legend.labels.useSeriesColors ? e.globals.colors[l] : e.config.legend.labels.colors;
                                    P || (P = e.config.chart.foreColor), T.style.color = P, T.style.fontSize = parseFloat(e.config.legend.fontSize) + "px", T.style.fontWeight = e.config.legend.fontWeight, T.style.fontFamily = i || e.config.chart.fontFamily, S.setAttrs(T, {
                                        rel: l + 1,
                                        i: l,
                                        "data:default-text": encodeURIComponent(c),
                                        "data:collapsed": h || d
                                    }), E.appendChild(g), E.appendChild(T);
                                    var M = new C(this.ctx);
                                    e.config.legend.showForZeroSeries || 0 === M.getSeriesTotalByIndex(l) && M.seriesHaveSameValues(l) && !M.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && E.classList.add("apexcharts-hidden-zero-series"), e.config.legend.showForNullSeries || M.isSeriesNull(l) && -1 === e.globals.collapsedSeriesIndices.indexOf(l) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(l) && E.classList.add("apexcharts-hidden-null-series"), e.globals.dom.elLegendWrap.appendChild(E), e.globals.dom.elLegendWrap.classList.add("apexcharts-align-".concat(e.config.legend.horizontalAlign)), e.globals.dom.elLegendWrap.classList.add("apx-legend-position-" + e.config.legend.position), E.classList.add("apexcharts-legend-series"), E.style.margin = "".concat(e.config.legend.itemMargin.vertical, "px ").concat(e.config.legend.itemMargin.horizontal, "px"), e.globals.dom.elLegendWrap.style.width = e.config.legend.width ? e.config.legend.width + "px" : "", e.globals.dom.elLegendWrap.style.height = e.config.legend.height ? e.config.legend.height + "px" : "", S.setAttrs(E, {
                                        rel: l + 1,
                                        seriesName: b.escapeString(a[l]),
                                        "data:collapsed": h || d
                                    }), (h || d) && E.classList.add("apexcharts-inactive-legend"), e.config.legend.onItemClick.toggleDataSeries || E.classList.add("apexcharts-no-click")
                                }
                                e.globals.dom.elWrap.addEventListener("click", t.onLegendClick, !0), e.config.legend.onItemHover.highlightDataSeries && 0 === e.config.legend.customLegendItems.length && (e.globals.dom.elWrap.addEventListener("mousemove", t.onLegendHovered, !0), e.globals.dom.elWrap.addEventListener("mouseout", t.onLegendHovered, !0))
                            }
                        }, {
                            key: "setLegendWrapXY",
                            value: function(t, e) {
                                var i = this.w,
                                    a = i.globals.dom.baseEl.querySelector(".apexcharts-legend"),
                                    s = a.getBoundingClientRect(),
                                    n = 0,
                                    r = 0;
                                if ("bottom" === i.config.legend.position) r += i.globals.svgHeight - s.height / 2;
                                else if ("top" === i.config.legend.position) {
                                    var o = new dt(this.ctx),
                                        l = o.dimHelpers.getTitleSubtitleCoords("title").height,
                                        c = o.dimHelpers.getTitleSubtitleCoords("subtitle").height;
                                    r = r + (l > 0 ? l - 10 : 0) + (c > 0 ? c - 10 : 0)
                                }
                                a.style.position = "absolute", n = n + t + i.config.legend.offsetX, r = r + e + i.config.legend.offsetY, a.style.left = n + "px", a.style.top = r + "px", "bottom" === i.config.legend.position ? (a.style.top = "auto", a.style.bottom = 5 - i.config.legend.offsetY + "px") : "right" === i.config.legend.position && (a.style.left = "auto", a.style.right = 25 + i.config.legend.offsetX + "px"), ["width", "height"].forEach((function(t) {
                                    a.style[t] && (a.style[t] = parseInt(i.config.legend[t], 10) + "px")
                                }))
                            }
                        }, {
                            key: "legendAlignHorizontal",
                            value: function() {
                                var t = this.w;
                                t.globals.dom.baseEl.querySelector(".apexcharts-legend").style.right = 0;
                                var e = this.legendHelpers.getLegendBBox(),
                                    i = new dt(this.ctx),
                                    a = i.dimHelpers.getTitleSubtitleCoords("title"),
                                    s = i.dimHelpers.getTitleSubtitleCoords("subtitle"),
                                    n = 0;
                                "bottom" === t.config.legend.position ? n = -e.clwh / 1.8 : "top" === t.config.legend.position && (n = a.height + s.height + t.config.title.margin + t.config.subtitle.margin - 10), this.setLegendWrapXY(20, n)
                            }
                        }, {
                            key: "legendAlignVertical",
                            value: function() {
                                var t = this.w,
                                    e = this.legendHelpers.getLegendBBox(),
                                    i = 0;
                                "left" === t.config.legend.position && (i = 20), "right" === t.config.legend.position && (i = t.globals.svgWidth - e.clww - 10), this.setLegendWrapXY(i, 20)
                            }
                        }, {
                            key: "onLegendHovered",
                            value: function(t) {
                                var e = this.w,
                                    i = t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker");
                                if ("heatmap" === e.config.chart.type || this.isBarsDistributed) {
                                    if (i) {
                                        var a = parseInt(t.target.getAttribute("rel"), 10) - 1;
                                        this.ctx.events.fireEvent("legendHover", [this.ctx, a, this.w]), new O(this.ctx).highlightRangeInSeries(t, t.target)
                                    }
                                } else !t.target.classList.contains("apexcharts-inactive-legend") && i && new O(this.ctx).toggleSeriesOnHover(t, t.target)
                            }
                        }, {
                            key: "onLegendClick",
                            value: function(t) {
                                var e = this.w;
                                if (!e.config.legend.customLegendItems.length && (t.target.classList.contains("apexcharts-legend-text") || t.target.classList.contains("apexcharts-legend-marker"))) {
                                    var i = parseInt(t.target.getAttribute("rel"), 10) - 1,
                                        a = "true" === t.target.getAttribute("data:collapsed"),
                                        s = this.w.config.chart.events.legendClick;
                                    "function" == typeof s && s(this.ctx, i, this.w), this.ctx.events.fireEvent("legendClick", [this.ctx, i, this.w]);
                                    var n = this.w.config.legend.markers.onClick;
                                    "function" == typeof n && t.target.classList.contains("apexcharts-legend-marker") && (n(this.ctx, i, this.w), this.ctx.events.fireEvent("legendMarkerClick", [this.ctx, i, this.w])), "treemap" !== e.config.chart.type && "heatmap" !== e.config.chart.type && !this.isBarsDistributed && e.config.legend.onItemClick.toggleDataSeries && this.legendHelpers.toggleDataSeries(i, a)
                                }
                            }
                        }]), t
                    }(),
                    gt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var i = this.w;
                            this.ev = this.w.config.chart.events, this.selectedClass = "apexcharts-selected", this.localeValues = this.w.globals.locale.toolbar, this.minX = i.globals.minX, this.maxX = i.globals.maxX
                        }
                        return c(t, [{
                            key: "createToolbar",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = function() {
                                        return document.createElement("div")
                                    },
                                    a = i();
                                if (a.setAttribute("class", "apexcharts-toolbar"), a.style.top = e.config.chart.toolbar.offsetY + "px", a.style.right = 3 - e.config.chart.toolbar.offsetX + "px", e.globals.dom.elWrap.appendChild(a), this.elZoom = i(), this.elZoomIn = i(), this.elZoomOut = i(), this.elPan = i(), this.elSelection = i(), this.elZoomReset = i(), this.elMenuIcon = i(), this.elMenu = i(), this.elCustomIcons = [], this.t = e.config.chart.toolbar.tools, Array.isArray(this.t.customIcons))
                                    for (var s = 0; s < this.t.customIcons.length; s++) this.elCustomIcons.push(i());
                                var n = [],
                                    r = function(i, a, s) {
                                        var r = i.toLowerCase();
                                        t.t[r] && e.config.chart.zoom.enabled && n.push({
                                            el: a,
                                            icon: "string" == typeof t.t[r] ? t.t[r] : s,
                                            title: t.localeValues[i],
                                            class: "apexcharts-".concat(r, "-icon")
                                        })
                                    };
                                r("zoomIn", this.elZoomIn, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n'), r("zoomOut", this.elZoomOut, '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/>\n</svg>\n');
                                var o = function(i) {
                                    t.t[i] && e.config.chart[i].enabled && n.push({
                                        el: "zoom" === i ? t.elZoom : t.elSelection,
                                        icon: "string" == typeof t.t[i] ? t.t[i] : "zoom" === i ? '<svg xmlns="http://www.w3.org/2000/svg" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/>\n    <path d="M0 0h24v24H0V0z" fill="none"/>\n    <path d="M12 10h-2v2H9v-2H7V9h2V7h1v2h2v1z"/>\n</svg>' : '<svg fill="#6E8192" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M0 0h24v24H0z" fill="none"/>\n    <path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2z"/>\n</svg>',
                                        title: t.localeValues["zoom" === i ? "selectionZoom" : "selection"],
                                        class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-".concat(i, "-icon")
                                    })
                                };
                                o("zoom"), o("selection"), this.t.pan && e.config.chart.zoom.enabled && n.push({
                                    el: this.elPan,
                                    icon: "string" == typeof this.t.pan ? this.t.pan : '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" fill="#000000" height="24" viewBox="0 0 24 24" width="24">\n    <defs>\n        <path d="M0 0h24v24H0z" id="a"/>\n    </defs>\n    <clipPath id="b">\n        <use overflow="visible" xlink:href="#a"/>\n    </clipPath>\n    <path clip-path="url(#b)" d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"/>\n</svg>',
                                    title: this.localeValues.pan,
                                    class: e.globals.isTouchDevice ? "apexcharts-element-hidden" : "apexcharts-pan-icon"
                                }), r("reset", this.elZoomReset, '<svg fill="#000000" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg">\n    <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>\n    <path d="M0 0h24v24H0z" fill="none"/>\n</svg>'), this.t.download && n.push({
                                    el: this.elMenuIcon,
                                    icon: "string" == typeof this.t.download ? this.t.download : '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0V0z"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg>',
                                    title: this.localeValues.menu,
                                    class: "apexcharts-menu-icon"
                                });
                                for (var l = 0; l < this.elCustomIcons.length; l++) n.push({
                                    el: this.elCustomIcons[l],
                                    icon: this.t.customIcons[l].icon,
                                    title: this.t.customIcons[l].title,
                                    index: this.t.customIcons[l].index,
                                    class: "apexcharts-toolbar-custom-icon " + this.t.customIcons[l].class
                                });
                                n.forEach((function(t, e) {
                                    t.index && b.moveIndexInArray(n, e, t.index)
                                }));
                                for (var c = 0; c < n.length; c++) S.setAttrs(n[c].el, {
                                    class: n[c].class,
                                    title: n[c].title
                                }), n[c].el.innerHTML = n[c].icon, a.appendChild(n[c].el);
                                this._createHamburgerMenu(a), e.globals.zoomEnabled ? this.elZoom.classList.add(this.selectedClass) : e.globals.panEnabled ? this.elPan.classList.add(this.selectedClass) : e.globals.selectionEnabled && this.elSelection.classList.add(this.selectedClass), this.addToolbarEventListeners()
                            }
                        }, {
                            key: "_createHamburgerMenu",
                            value: function(t) {
                                this.elMenuItems = [], t.appendChild(this.elMenu), S.setAttrs(this.elMenu, {
                                    class: "apexcharts-menu"
                                });
                                var e = [{
                                    name: "exportSVG",
                                    title: this.localeValues.exportToSVG
                                }, {
                                    name: "exportPNG",
                                    title: this.localeValues.exportToPNG
                                }, {
                                    name: "exportCSV",
                                    title: this.localeValues.exportToCSV
                                }];
                                this.w.globals.allSeriesHasEqualX || e.splice(2, 1);
                                for (var i = 0; i < e.length; i++) this.elMenuItems.push(document.createElement("div")), this.elMenuItems[i].innerHTML = e[i].title, S.setAttrs(this.elMenuItems[i], {
                                    class: "apexcharts-menu-item ".concat(e[i].name),
                                    title: e[i].title
                                }), this.elMenu.appendChild(this.elMenuItems[i])
                            }
                        }, {
                            key: "addToolbarEventListeners",
                            value: function() {
                                var t = this;
                                this.elZoomReset.addEventListener("click", this.handleZoomReset.bind(this)), this.elSelection.addEventListener("click", this.toggleZoomSelection.bind(this, "selection")), this.elZoom.addEventListener("click", this.toggleZoomSelection.bind(this, "zoom")), this.elZoomIn.addEventListener("click", this.handleZoomIn.bind(this)), this.elZoomOut.addEventListener("click", this.handleZoomOut.bind(this)), this.elPan.addEventListener("click", this.togglePanning.bind(this)), this.elMenuIcon.addEventListener("click", this.toggleMenu.bind(this)), this.elMenuItems.forEach((function(e) {
                                    e.classList.contains("exportSVG") ? e.addEventListener("click", t.handleDownload.bind(t, "svg")) : e.classList.contains("exportPNG") ? e.addEventListener("click", t.handleDownload.bind(t, "png")) : e.classList.contains("exportCSV") && e.addEventListener("click", t.handleDownload.bind(t, "csv"))
                                }));
                                for (var e = 0; e < this.t.customIcons.length; e++) this.elCustomIcons[e].addEventListener("click", this.t.customIcons[e].click.bind(this, this.ctx, this.ctx.w))
                            }
                        }, {
                            key: "toggleZoomSelection",
                            value: function(t) {
                                this.ctx.getSyncedCharts().forEach((function(e) {
                                    e.ctx.toolbar.toggleOtherControls();
                                    var i = "selection" === t ? e.ctx.toolbar.elSelection : e.ctx.toolbar.elZoom,
                                        a = "selection" === t ? "selectionEnabled" : "zoomEnabled";
                                    e.w.globals[a] = !e.w.globals[a], i.classList.contains(e.ctx.toolbar.selectedClass) ? i.classList.remove(e.ctx.toolbar.selectedClass) : i.classList.add(e.ctx.toolbar.selectedClass)
                                }))
                            }
                        }, {
                            key: "getToolbarIconsReference",
                            value: function() {
                                var t = this.w;
                                this.elZoom || (this.elZoom = t.globals.dom.baseEl.querySelector(".apexcharts-zoom-icon")), this.elPan || (this.elPan = t.globals.dom.baseEl.querySelector(".apexcharts-pan-icon")), this.elSelection || (this.elSelection = t.globals.dom.baseEl.querySelector(".apexcharts-selection-icon"))
                            }
                        }, {
                            key: "enableZoomPanFromToolbar",
                            value: function(t) {
                                this.toggleOtherControls(), "pan" === t ? this.w.globals.panEnabled = !0 : this.w.globals.zoomEnabled = !0;
                                var e = "pan" === t ? this.elPan : this.elZoom,
                                    i = "pan" === t ? this.elZoom : this.elPan;
                                e && e.classList.add(this.selectedClass), i && i.classList.remove(this.selectedClass)
                            }
                        }, {
                            key: "togglePanning",
                            value: function() {
                                this.ctx.getSyncedCharts().forEach((function(t) {
                                    t.ctx.toolbar.toggleOtherControls(), t.w.globals.panEnabled = !t.w.globals.panEnabled, t.ctx.toolbar.elPan.classList.contains(t.ctx.toolbar.selectedClass) ? t.ctx.toolbar.elPan.classList.remove(t.ctx.toolbar.selectedClass) : t.ctx.toolbar.elPan.classList.add(t.ctx.toolbar.selectedClass)
                                }))
                            }
                        }, {
                            key: "toggleOtherControls",
                            value: function() {
                                var t = this,
                                    e = this.w;
                                e.globals.panEnabled = !1, e.globals.zoomEnabled = !1, e.globals.selectionEnabled = !1, this.getToolbarIconsReference(), [this.elPan, this.elSelection, this.elZoom].forEach((function(e) {
                                    e && e.classList.remove(t.selectedClass)
                                }))
                            }
                        }, {
                            key: "handleZoomIn",
                            value: function() {
                                var t = this.w;
                                t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY);
                                var e = (this.minX + this.maxX) / 2,
                                    i = (this.minX + e) / 2,
                                    a = (this.maxX + e) / 2,
                                    s = this._getNewMinXMaxX(i, a);
                                t.globals.disableZoomIn || this.zoomUpdateOptions(s.minX, s.maxX)
                            }
                        }, {
                            key: "handleZoomOut",
                            value: function() {
                                var t = this.w;
                                if (t.globals.isRangeBar && (this.minX = t.globals.minY, this.maxX = t.globals.maxY), !("datetime" === t.config.xaxis.type && new Date(this.minX).getUTCFullYear() < 1e3)) {
                                    var e = (this.minX + this.maxX) / 2,
                                        i = this.minX - (e - this.minX),
                                        a = this.maxX - (e - this.maxX),
                                        s = this._getNewMinXMaxX(i, a);
                                    t.globals.disableZoomOut || this.zoomUpdateOptions(s.minX, s.maxX)
                                }
                            }
                        }, {
                            key: "_getNewMinXMaxX",
                            value: function(t, e) {
                                var i = this.w.config.xaxis.convertedCatToNumeric;
                                return {
                                    minX: i ? Math.floor(t) : t,
                                    maxX: i ? Math.floor(e) : e
                                }
                            }
                        }, {
                            key: "zoomUpdateOptions",
                            value: function(t, e) {
                                var i = this.w;
                                if (void 0 !== t || void 0 !== e) {
                                    if (!(i.config.xaxis.convertedCatToNumeric && (t < 1 && (t = 1, e = i.globals.dataPoints), e - t < 2))) {
                                        var a = {
                                                min: t,
                                                max: e
                                            },
                                            s = this.getBeforeZoomRange(a);
                                        s && (a = s.xaxis);
                                        var n = {
                                                xaxis: a
                                            },
                                            r = b.clone(i.globals.initialConfig.yaxis);
                                        i.config.chart.zoom.autoScaleYaxis && (r = new K(this.ctx).autoScaleY(this.ctx, r, {
                                            xaxis: a
                                        })), i.config.chart.group || (n.yaxis = r), this.w.globals.zoomed = !0, this.ctx.updateHelpers._updateOptions(n, !1, this.w.config.chart.animations.dynamicAnimation.enabled), this.zoomCallback(a, r)
                                    }
                                } else this.handleZoomReset()
                            }
                        }, {
                            key: "zoomCallback",
                            value: function(t, e) {
                                "function" == typeof this.ev.zoomed && this.ev.zoomed(this.ctx, {
                                    xaxis: t,
                                    yaxis: e
                                })
                            }
                        }, {
                            key: "getBeforeZoomRange",
                            value: function(t, e) {
                                var i = null;
                                return "function" == typeof this.ev.beforeZoom && (i = this.ev.beforeZoom(this, {
                                    xaxis: t,
                                    yaxis: e
                                })), i
                            }
                        }, {
                            key: "toggleMenu",
                            value: function() {
                                var t = this;
                                window.setTimeout((function() {
                                    t.elMenu.classList.contains("apexcharts-menu-open") ? t.elMenu.classList.remove("apexcharts-menu-open") : t.elMenu.classList.add("apexcharts-menu-open")
                                }), 0)
                            }
                        }, {
                            key: "handleDownload",
                            value: function(t) {
                                var e = this.w,
                                    i = new U(this.ctx);
                                switch (t) {
                                    case "svg":
                                        i.exportToSVG(this.ctx);
                                        break;
                                    case "png":
                                        i.exportToPng(this.ctx);
                                        break;
                                    case "csv":
                                        i.exportToCSV({
                                            series: e.config.series,
                                            columnDelimiter: e.config.chart.toolbar.export.csv.columnDelimiter
                                        })
                                }
                            }
                        }, {
                            key: "handleZoomReset",
                            value: function(t) {
                                this.ctx.getSyncedCharts().forEach((function(t) {
                                    var e = t.w;
                                    if (e.globals.lastXAxis.min = void 0, e.globals.lastXAxis.max = void 0, t.updateHelpers.revertDefaultAxisMinMax(), "function" == typeof e.config.chart.events.beforeResetZoom) {
                                        var i = e.config.chart.events.beforeResetZoom(t, e);
                                        i && t.updateHelpers.revertDefaultAxisMinMax(i)
                                    }
                                    "function" == typeof e.config.chart.events.zoomed && t.ctx.toolbar.zoomCallback({
                                        min: e.config.xaxis.min,
                                        max: e.config.xaxis.max
                                    }), e.globals.zoomed = !1;
                                    var a = t.ctx.series.emptyCollapsedSeries(b.clone(e.globals.initialSeries));
                                    t.updateHelpers._updateSeries(a, e.config.chart.animations.dynamicAnimation.enabled)
                                }))
                            }
                        }, {
                            key: "destroy",
                            value: function() {
                                this.elZoom = null, this.elZoomIn = null, this.elZoomOut = null, this.elPan = null, this.elSelection = null, this.elZoomReset = null, this.elMenuIcon = null
                            }
                        }]), t
                    }(),
                    ft = function(t) {
                        d(i, gt);
                        var e = f(i);

                        function i(t) {
                            var a;
                            return o(this, i), (a = e.call(this, t)).ctx = t, a.w = t.w, a.dragged = !1, a.graphics = new S(a.ctx), a.eventList = ["mousedown", "mouseleave", "mousemove", "touchstart", "touchmove", "mouseup", "touchend"], a.clientX = 0, a.clientY = 0, a.startX = 0, a.endX = 0, a.dragX = 0, a.startY = 0, a.endY = 0, a.dragY = 0, a.moveDirection = "none", a
                        }
                        return c(i, [{
                            key: "init",
                            value: function(t) {
                                var e = this,
                                    i = t.xyRatios,
                                    a = this.w,
                                    s = this;
                                this.xyRatios = i, this.zoomRect = this.graphics.drawRect(0, 0, 0, 0), this.selectionRect = this.graphics.drawRect(0, 0, 0, 0), this.gridRect = a.globals.dom.baseEl.querySelector(".apexcharts-grid"), this.zoomRect.node.classList.add("apexcharts-zoom-rect"), this.selectionRect.node.classList.add("apexcharts-selection-rect"), a.globals.dom.elGraphical.add(this.zoomRect), a.globals.dom.elGraphical.add(this.selectionRect), "x" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                                    minX: 0,
                                    minY: 0,
                                    maxX: a.globals.gridWidth,
                                    maxY: a.globals.gridHeight
                                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : "y" === a.config.chart.selection.type ? this.slDraggableRect = this.selectionRect.draggable({
                                    minX: 0,
                                    maxX: a.globals.gridWidth
                                }).on("dragmove", this.selectionDragging.bind(this, "dragging")) : this.slDraggableRect = this.selectionRect.draggable().on("dragmove", this.selectionDragging.bind(this, "dragging")), this.preselectedSelection(), this.hoverArea = a.globals.dom.baseEl.querySelector("".concat(a.globals.chartClass, " .apexcharts-svg")), this.hoverArea.classList.add("apexcharts-zoomable"), this.eventList.forEach((function(t) {
                                    e.hoverArea.addEventListener(t, s.svgMouseEvents.bind(s, i), {
                                        capture: !1,
                                        passive: !0
                                    })
                                }))
                            }
                        }, {
                            key: "destroy",
                            value: function() {
                                this.slDraggableRect && (this.slDraggableRect.draggable(!1), this.slDraggableRect.off(), this.selectionRect.off()), this.selectionRect = null, this.zoomRect = null, this.gridRect = null
                            }
                        }, {
                            key: "svgMouseEvents",
                            value: function(t, e) {
                                var i = this.w,
                                    a = this,
                                    s = this.ctx.toolbar,
                                    n = i.globals.zoomEnabled ? i.config.chart.zoom.type : i.config.chart.selection.type,
                                    r = i.config.chart.toolbar.autoSelected;
                                if (e.shiftKey ? (this.shiftWasPressed = !0, s.enableZoomPanFromToolbar("pan" === r ? "zoom" : "pan")) : this.shiftWasPressed && (s.enableZoomPanFromToolbar(r), this.shiftWasPressed = !1), e.target) {
                                    var o, l = e.target.classList;
                                    if (e.target.parentNode && null !== e.target.parentNode && (o = e.target.parentNode.classList), !(l.contains("apexcharts-selection-rect") || l.contains("apexcharts-legend-marker") || l.contains("apexcharts-legend-text") || o && o.contains("apexcharts-toolbar"))) {
                                        if (a.clientX = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientX : "touchend" === e.type ? e.changedTouches[0].clientX : e.clientX, a.clientY = "touchmove" === e.type || "touchstart" === e.type ? e.touches[0].clientY : "touchend" === e.type ? e.changedTouches[0].clientY : e.clientY, "mousedown" === e.type && 1 === e.which) {
                                            var c = a.gridRect.getBoundingClientRect();
                                            a.startX = a.clientX - c.left, a.startY = a.clientY - c.top, a.dragged = !1, a.w.globals.mousedown = !0
                                        }
                                        if (("mousemove" === e.type && 1 === e.which || "touchmove" === e.type) && (a.dragged = !0, i.globals.panEnabled ? (i.globals.selection = null, a.w.globals.mousedown && a.panDragging({
                                                context: a,
                                                zoomtype: n,
                                                xyRatios: t
                                            })) : (a.w.globals.mousedown && i.globals.zoomEnabled || a.w.globals.mousedown && i.globals.selectionEnabled) && (a.selection = a.selectionDrawing({
                                                context: a,
                                                zoomtype: n
                                            }))), "mouseup" === e.type || "touchend" === e.type || "mouseleave" === e.type) {
                                            var h = a.gridRect.getBoundingClientRect();
                                            a.w.globals.mousedown && (a.endX = a.clientX - h.left, a.endY = a.clientY - h.top, a.dragX = Math.abs(a.endX - a.startX), a.dragY = Math.abs(a.endY - a.startY), (i.globals.zoomEnabled || i.globals.selectionEnabled) && a.selectionDrawn({
                                                context: a,
                                                zoomtype: n
                                            }), i.globals.panEnabled && i.config.xaxis.convertedCatToNumeric && a.delayedPanScrolled()), i.globals.zoomEnabled && a.hideSelectionRect(this.selectionRect), a.dragged = !1, a.w.globals.mousedown = !1
                                        }
                                        this.makeSelectionRectDraggable()
                                    }
                                }
                            }
                        }, {
                            key: "makeSelectionRectDraggable",
                            value: function() {
                                var t = this.w;
                                if (this.selectionRect) {
                                    var e = this.selectionRect.node.getBoundingClientRect();
                                    e.width > 0 && e.height > 0 && this.slDraggableRect.selectize({
                                        points: "l, r",
                                        pointSize: 8,
                                        pointType: "rect"
                                    }).resize({
                                        constraint: {
                                            minX: 0,
                                            minY: 0,
                                            maxX: t.globals.gridWidth,
                                            maxY: t.globals.gridHeight
                                        }
                                    }).on("resizing", this.selectionDragging.bind(this, "resizing"))
                                }
                            }
                        }, {
                            key: "preselectedSelection",
                            value: function() {
                                var t = this.w,
                                    e = this.xyRatios;
                                if (!t.globals.zoomEnabled)
                                    if (void 0 !== t.globals.selection && null !== t.globals.selection) this.drawSelectionRect(t.globals.selection);
                                    else if (void 0 !== t.config.chart.selection.xaxis.min && void 0 !== t.config.chart.selection.xaxis.max) {
                                    var i = (t.config.chart.selection.xaxis.min - t.globals.minX) / e.xRatio,
                                        a = {
                                            x: i,
                                            y: 0,
                                            width: t.globals.gridWidth - (t.globals.maxX - t.config.chart.selection.xaxis.max) / e.xRatio - i,
                                            height: t.globals.gridHeight,
                                            translateX: 0,
                                            translateY: 0,
                                            selectionEnabled: !0
                                        };
                                    this.drawSelectionRect(a), this.makeSelectionRectDraggable(), "function" == typeof t.config.chart.events.selection && t.config.chart.events.selection(this.ctx, {
                                        xaxis: {
                                            min: t.config.chart.selection.xaxis.min,
                                            max: t.config.chart.selection.xaxis.max
                                        },
                                        yaxis: {}
                                    })
                                }
                            }
                        }, {
                            key: "drawSelectionRect",
                            value: function(t) {
                                var e = t.x,
                                    i = t.y,
                                    a = t.width,
                                    s = t.height,
                                    n = t.translateX,
                                    r = void 0 === n ? 0 : n,
                                    o = t.translateY,
                                    l = void 0 === o ? 0 : o,
                                    c = this.w,
                                    h = this.zoomRect,
                                    d = this.selectionRect;
                                if (this.dragged || null !== c.globals.selection) {
                                    var u = {
                                        transform: "translate(" + r + ", " + l + ")"
                                    };
                                    c.globals.zoomEnabled && this.dragged && (a < 0 && (a = 1), h.attr({
                                        x: e,
                                        y: i,
                                        width: a,
                                        height: s,
                                        fill: c.config.chart.zoom.zoomedArea.fill.color,
                                        "fill-opacity": c.config.chart.zoom.zoomedArea.fill.opacity,
                                        stroke: c.config.chart.zoom.zoomedArea.stroke.color,
                                        "stroke-width": c.config.chart.zoom.zoomedArea.stroke.width,
                                        "stroke-opacity": c.config.chart.zoom.zoomedArea.stroke.opacity
                                    }), S.setAttrs(h.node, u)), c.globals.selectionEnabled && (d.attr({
                                        x: e,
                                        y: i,
                                        width: a > 0 ? a : 0,
                                        height: s > 0 ? s : 0,
                                        fill: c.config.chart.selection.fill.color,
                                        "fill-opacity": c.config.chart.selection.fill.opacity,
                                        stroke: c.config.chart.selection.stroke.color,
                                        "stroke-width": c.config.chart.selection.stroke.width,
                                        "stroke-dasharray": c.config.chart.selection.stroke.dashArray,
                                        "stroke-opacity": c.config.chart.selection.stroke.opacity
                                    }), S.setAttrs(d.node, u))
                                }
                            }
                        }, {
                            key: "hideSelectionRect",
                            value: function(t) {
                                t && t.attr({
                                    x: 0,
                                    y: 0,
                                    width: 0,
                                    height: 0
                                })
                            }
                        }, {
                            key: "selectionDrawing",
                            value: function(t) {
                                var e, i = t.context,
                                    a = t.zoomtype,
                                    s = this.w,
                                    n = i,
                                    r = this.gridRect.getBoundingClientRect(),
                                    o = n.startX - 1,
                                    l = n.startY,
                                    c = !1,
                                    h = !1,
                                    d = n.clientX - r.left - o,
                                    u = n.clientY - r.top - l;
                                return Math.abs(d + o) > s.globals.gridWidth ? d = s.globals.gridWidth - o : n.clientX - r.left < 0 && (d = o), o > n.clientX - r.left && (c = !0, d = Math.abs(d)), l > n.clientY - r.top && (h = !0, u = Math.abs(u)), e = "x" === a ? {
                                    x: c ? o - d : o,
                                    y: 0,
                                    width: d,
                                    height: s.globals.gridHeight
                                } : "y" === a ? {
                                    x: 0,
                                    y: h ? l - u : l,
                                    width: s.globals.gridWidth,
                                    height: u
                                } : {
                                    x: c ? o - d : o,
                                    y: h ? l - u : l,
                                    width: d,
                                    height: u
                                }, n.drawSelectionRect(e), n.selectionDragging("resizing"), e
                            }
                        }, {
                            key: "selectionDragging",
                            value: function(t, e) {
                                var i = this,
                                    a = this.w,
                                    s = this.xyRatios,
                                    n = this.selectionRect,
                                    r = 0;
                                "resizing" === t && (r = 30);
                                var o = function(t) {
                                        return parseFloat(n.node.getAttribute(t))
                                    },
                                    l = {
                                        x: o("x"),
                                        y: o("y"),
                                        width: o("width"),
                                        height: o("height")
                                    };
                                a.globals.selection = l, "function" == typeof a.config.chart.events.selection && a.globals.selectionEnabled && (clearTimeout(this.w.globals.selectionResizeTimer), this.w.globals.selectionResizeTimer = window.setTimeout((function() {
                                    var t = i.gridRect.getBoundingClientRect(),
                                        e = n.node.getBoundingClientRect(),
                                        r = {
                                            xaxis: {
                                                min: a.globals.xAxisScale.niceMin + (e.left - t.left) * s.xRatio,
                                                max: a.globals.xAxisScale.niceMin + (e.right - t.left) * s.xRatio
                                            },
                                            yaxis: {
                                                min: a.globals.yAxisScale[0].niceMin + (t.bottom - e.bottom) * s.yRatio[0],
                                                max: a.globals.yAxisScale[0].niceMax - (e.top - t.top) * s.yRatio[0]
                                            }
                                        };
                                    a.config.chart.events.selection(i.ctx, r), a.config.chart.brush.enabled && void 0 !== a.config.chart.events.brushScrolled && a.config.chart.events.brushScrolled(i.ctx, r)
                                }), r))
                            }
                        }, {
                            key: "selectionDrawn",
                            value: function(t) {
                                var e = t.context,
                                    i = t.zoomtype,
                                    a = this.w,
                                    s = e,
                                    n = this.xyRatios,
                                    r = this.ctx.toolbar;
                                if (s.startX > s.endX) {
                                    var o = s.startX;
                                    s.startX = s.endX, s.endX = o
                                }
                                if (s.startY > s.endY) {
                                    var l = s.startY;
                                    s.startY = s.endY, s.endY = l
                                }
                                var c = void 0,
                                    h = void 0;
                                a.globals.isRangeBar ? (c = a.globals.yAxisScale[0].niceMin + s.startX * n.invertedYRatio, h = a.globals.yAxisScale[0].niceMin + s.endX * n.invertedYRatio) : (c = a.globals.xAxisScale.niceMin + s.startX * n.xRatio, h = a.globals.xAxisScale.niceMin + s.endX * n.xRatio);
                                var d = [],
                                    u = [];
                                if (a.config.yaxis.forEach((function(t, e) {
                                        d.push(a.globals.yAxisScale[e].niceMax - n.yRatio[e] * s.startY), u.push(a.globals.yAxisScale[e].niceMax - n.yRatio[e] * s.endY)
                                    })), s.dragged && (s.dragX > 10 || s.dragY > 10) && c !== h)
                                    if (a.globals.zoomEnabled) {
                                        var p = b.clone(a.globals.initialConfig.yaxis),
                                            g = b.clone(a.globals.initialConfig.xaxis);
                                        if (a.globals.zoomed = !0, a.config.xaxis.convertedCatToNumeric && (c = Math.floor(c), h = Math.floor(h), c < 1 && (c = 1, h = a.globals.dataPoints), h - c < 2 && (h = c + 1)), "xy" !== i && "x" !== i || (g = {
                                                min: c,
                                                max: h
                                            }), "xy" !== i && "y" !== i || p.forEach((function(t, e) {
                                                p[e].min = u[e], p[e].max = d[e]
                                            })), a.config.chart.zoom.autoScaleYaxis) {
                                            var f = new K(s.ctx);
                                            p = f.autoScaleY(s.ctx, p, {
                                                xaxis: g
                                            })
                                        }
                                        if (r) {
                                            var m = r.getBeforeZoomRange(g, p);
                                            m && (g = m.xaxis ? m.xaxis : g, p = m.yaxis ? m.yaxis : p)
                                        }
                                        var x = {
                                            xaxis: g
                                        };
                                        a.config.chart.group || (x.yaxis = p), s.ctx.updateHelpers._updateOptions(x, !1, s.w.config.chart.animations.dynamicAnimation.enabled), "function" == typeof a.config.chart.events.zoomed && r.zoomCallback(g, p)
                                    } else if (a.globals.selectionEnabled) {
                                    var v, y = null;
                                    v = {
                                        min: c,
                                        max: h
                                    }, "xy" !== i && "y" !== i || (y = b.clone(a.config.yaxis)).forEach((function(t, e) {
                                        y[e].min = u[e], y[e].max = d[e]
                                    })), a.globals.selection = s.selection, "function" == typeof a.config.chart.events.selection && a.config.chart.events.selection(s.ctx, {
                                        xaxis: v,
                                        yaxis: y
                                    })
                                }
                            }
                        }, {
                            key: "panDragging",
                            value: function(t) {
                                var e = t.context,
                                    i = this.w,
                                    a = e;
                                if (void 0 !== i.globals.lastClientPosition.x) {
                                    var s = i.globals.lastClientPosition.x - a.clientX,
                                        n = i.globals.lastClientPosition.y - a.clientY;
                                    Math.abs(s) > Math.abs(n) && s > 0 ? this.moveDirection = "left" : Math.abs(s) > Math.abs(n) && s < 0 ? this.moveDirection = "right" : Math.abs(n) > Math.abs(s) && n > 0 ? this.moveDirection = "up" : Math.abs(n) > Math.abs(s) && n < 0 && (this.moveDirection = "down")
                                }
                                i.globals.lastClientPosition = {
                                    x: a.clientX,
                                    y: a.clientY
                                };
                                var r = i.globals.isRangeBar ? i.globals.minY : i.globals.minX,
                                    o = i.globals.isRangeBar ? i.globals.maxY : i.globals.maxX;
                                i.config.xaxis.convertedCatToNumeric || a.panScrolled(r, o)
                            }
                        }, {
                            key: "delayedPanScrolled",
                            value: function() {
                                var t = this.w,
                                    e = t.globals.minX,
                                    i = t.globals.maxX,
                                    a = (t.globals.maxX - t.globals.minX) / 2;
                                "left" === this.moveDirection ? (e = t.globals.minX + a, i = t.globals.maxX + a) : "right" === this.moveDirection && (e = t.globals.minX - a, i = t.globals.maxX - a), e = Math.floor(e), i = Math.floor(i), this.updateScrolledChart({
                                    xaxis: {
                                        min: e,
                                        max: i
                                    }
                                }, e, i)
                            }
                        }, {
                            key: "panScrolled",
                            value: function(t, e) {
                                var i = this.w,
                                    a = this.xyRatios,
                                    s = b.clone(i.globals.initialConfig.yaxis),
                                    n = a.xRatio,
                                    r = i.globals.minX,
                                    o = i.globals.maxX;
                                i.globals.isRangeBar && (n = a.invertedYRatio, r = i.globals.minY, o = i.globals.maxY), "left" === this.moveDirection ? (t = r + i.globals.gridWidth / 15 * n, e = o + i.globals.gridWidth / 15 * n) : "right" === this.moveDirection && (t = r - i.globals.gridWidth / 15 * n, e = o - i.globals.gridWidth / 15 * n), i.globals.isRangeBar || (t < i.globals.initialMinX || e > i.globals.initialMaxX) && (t = r, e = o);
                                var l = {
                                    min: t,
                                    max: e
                                };
                                i.config.chart.zoom.autoScaleYaxis && (s = new K(this.ctx).autoScaleY(this.ctx, s, {
                                    xaxis: l
                                }));
                                var c = {
                                    xaxis: {
                                        min: t,
                                        max: e
                                    }
                                };
                                i.config.chart.group || (c.yaxis = s), this.updateScrolledChart(c, t, e)
                            }
                        }, {
                            key: "updateScrolledChart",
                            value: function(t, e, i) {
                                var a = this.w;
                                this.ctx.updateHelpers._updateOptions(t, !1, !1), "function" == typeof a.config.chart.events.scrolled && a.config.chart.events.scrolled(this.ctx, {
                                    xaxis: {
                                        min: e,
                                        max: i
                                    }
                                })
                            }
                        }]), i
                    }(),
                    mt = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx
                        }
                        return c(t, [{
                            key: "getNearestValues",
                            value: function(t) {
                                var e = t.hoverArea,
                                    i = t.elGrid,
                                    a = t.clientX,
                                    s = t.clientY,
                                    n = this.w,
                                    r = i.getBoundingClientRect(),
                                    o = r.width,
                                    l = r.height,
                                    c = o / (n.globals.dataPoints - 1),
                                    h = l / n.globals.dataPoints,
                                    d = this.hasBars();
                                !n.globals.comboCharts && !d || n.config.xaxis.convertedCatToNumeric || (c = o / n.globals.dataPoints);
                                var u = a - r.left - n.globals.barPadForNumericAxis,
                                    p = s - r.top;
                                u < 0 || p < 0 || u > o || p > l ? (e.classList.remove("hovering-zoom"), e.classList.remove("hovering-pan")) : n.globals.zoomEnabled ? (e.classList.remove("hovering-pan"), e.classList.add("hovering-zoom")) : n.globals.panEnabled && (e.classList.remove("hovering-zoom"), e.classList.add("hovering-pan"));
                                var g = Math.round(u / c),
                                    f = Math.floor(p / h);
                                d && !n.config.xaxis.convertedCatToNumeric && (g = Math.ceil(u / c), g -= 1);
                                var m = null,
                                    x = null,
                                    v = [],
                                    y = [];
                                if (n.globals.seriesXvalues.forEach((function(t) {
                                        v.push([t[0] + 1e-6].concat(t))
                                    })), n.globals.seriesYvalues.forEach((function(t) {
                                        y.push([t[0] + 1e-6].concat(t))
                                    })), v = v.map((function(t) {
                                        return t.filter((function(t) {
                                            return b.isNumber(t)
                                        }))
                                    })), y = y.map((function(t) {
                                        return t.filter((function(t) {
                                            return b.isNumber(t)
                                        }))
                                    })), n.globals.isXNumeric) {
                                    var w = this.ttCtx.getElGrid().getBoundingClientRect(),
                                        S = u * (w.width / o),
                                        C = p * (w.height / l);
                                    m = (x = this.closestInMultiArray(S, C, v, y)).index, g = x.j, null !== m && (v = n.globals.seriesXvalues[m], g = (x = this.closestInArray(S, v)).index)
                                }
                                return n.globals.capturedSeriesIndex = null === m ? -1 : m, (!g || g < 1) && (g = 0), n.globals.isBarHorizontal ? n.globals.capturedDataPointIndex = f : n.globals.capturedDataPointIndex = g, {
                                    capturedSeries: m,
                                    j: n.globals.isBarHorizontal ? f : g,
                                    hoverX: u,
                                    hoverY: p
                                }
                            }
                        }, {
                            key: "closestInMultiArray",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = 0,
                                    r = null,
                                    o = -1;
                                s.globals.series.length > 1 ? n = this.getFirstActiveXArray(i) : r = 0;
                                var l = i[n][0],
                                    c = Math.abs(t - l);
                                if (i.forEach((function(e) {
                                        e.forEach((function(e, i) {
                                            var a = Math.abs(t - e);
                                            a < c && (c = a, o = i)
                                        }))
                                    })), -1 !== o) {
                                    var h = a[n][o],
                                        d = Math.abs(e - h);
                                    r = n, a.forEach((function(t, i) {
                                        var a = Math.abs(e - t[o]);
                                        a < d && (d = a, r = i)
                                    }))
                                }
                                return {
                                    index: r,
                                    j: o
                                }
                            }
                        }, {
                            key: "getFirstActiveXArray",
                            value: function(t) {
                                for (var e = this.w, i = 0, a = t.map((function(t, e) {
                                        return t.length > 0 ? e : -1
                                    })), s = 0; s < a.length; s++)
                                    if (-1 !== a[s] && -1 === e.globals.collapsedSeriesIndices.indexOf(s) && -1 === e.globals.ancillaryCollapsedSeriesIndices.indexOf(s)) {
                                        i = a[s];
                                        break
                                    }
                                return i
                            }
                        }, {
                            key: "closestInArray",
                            value: function(t, e) {
                                for (var i = e[0], a = null, s = Math.abs(t - i), n = 0; n < e.length; n++) {
                                    var r = Math.abs(t - e[n]);
                                    r < s && (s = r, a = n)
                                }
                                return {
                                    index: a
                                }
                            }
                        }, {
                            key: "isXoverlap",
                            value: function(t) {
                                var e = [],
                                    i = this.w.globals.seriesX.filter((function(t) {
                                        return void 0 !== t[0]
                                    }));
                                if (i.length > 0)
                                    for (var a = 0; a < i.length - 1; a++) void 0 !== i[a][t] && void 0 !== i[a + 1][t] && i[a][t] !== i[a + 1][t] && e.push("unEqual");
                                return 0 === e.length
                            }
                        }, {
                            key: "isInitialSeriesSameLen",
                            value: function() {
                                for (var t = !0, e = this.w.globals.initialSeries, i = 0; i < e.length - 1; i++)
                                    if (e[i].data.length !== e[i + 1].data.length) {
                                        t = !1;
                                        break
                                    }
                                return t
                            }
                        }, {
                            key: "getBarsHeight",
                            value: function(t) {
                                return m(t).reduce((function(t, e) {
                                    return t + e.getBBox().height
                                }), 0)
                            }
                        }, {
                            key: "getElMarkers",
                            value: function() {
                                return this.w.globals.dom.baseEl.querySelectorAll(" .apexcharts-series-markers")
                            }
                        }, {
                            key: "getAllMarkers",
                            value: function() {
                                var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers-wrap");
                                (t = m(t)).sort((function(t, e) {
                                    var i = Number(t.getAttribute("data:realIndex")),
                                        a = Number(e.getAttribute("data:realIndex"));
                                    return a < i ? 1 : a > i ? -1 : 0
                                }));
                                var e = [];
                                return t.forEach((function(t) {
                                    e.push(t.querySelector(".apexcharts-marker"))
                                })), e
                            }
                        }, {
                            key: "hasMarkers",
                            value: function() {
                                return this.getElMarkers().length > 0
                            }
                        }, {
                            key: "getElBars",
                            value: function() {
                                return this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-bar-series,  .apexcharts-candlestick-series, .apexcharts-boxPlot-series, .apexcharts-rangebar-series")
                            }
                        }, {
                            key: "hasBars",
                            value: function() {
                                return this.getElBars().length > 0
                            }
                        }, {
                            key: "getHoverMarkerSize",
                            value: function(t) {
                                var e = this.w,
                                    i = e.config.markers.hover.size;
                                return void 0 === i && (i = e.globals.markers.size[t] + e.config.markers.hover.sizeOffset), i
                            }
                        }, {
                            key: "toggleAllTooltipSeriesGroups",
                            value: function(t) {
                                var e = this.w,
                                    i = this.ttCtx;
                                0 === i.allTooltipSeriesGroups.length && (i.allTooltipSeriesGroups = e.globals.dom.baseEl.querySelectorAll(".apexcharts-tooltip-series-group"));
                                for (var a = i.allTooltipSeriesGroups, s = 0; s < a.length; s++) "enable" === t ? (a[s].classList.add("apexcharts-active"), a[s].style.display = e.config.tooltip.items.display) : (a[s].classList.remove("apexcharts-active"), a[s].style.display = "none")
                            }
                        }]), t
                    }(),
                    xt = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.ctx = e.ctx, this.ttCtx = e, this.tooltipUtil = new mt(e)
                        }
                        return c(t, [{
                            key: "drawSeriesTexts",
                            value: function(t) {
                                var e = t.shared,
                                    i = void 0 === e || e,
                                    a = t.ttItems,
                                    s = t.i,
                                    n = void 0 === s ? 0 : s,
                                    r = t.j,
                                    o = void 0 === r ? null : r,
                                    l = t.y1,
                                    c = t.y2,
                                    h = t.e,
                                    d = this.w;
                                void 0 !== d.config.tooltip.custom ? this.handleCustomTooltip({
                                    i: n,
                                    j: o,
                                    y1: l,
                                    y2: c,
                                    w: d
                                }) : this.toggleActiveInactiveSeries(i);
                                var u = this.getValuesToPrint({
                                    i: n,
                                    j: o
                                });
                                this.printLabels({
                                    i: n,
                                    j: o,
                                    values: u,
                                    ttItems: a,
                                    shared: i,
                                    e: h
                                });
                                var p = this.ttCtx.getElTooltip();
                                this.ttCtx.tooltipRect.ttWidth = p.getBoundingClientRect().width, this.ttCtx.tooltipRect.ttHeight = p.getBoundingClientRect().height
                            }
                        }, {
                            key: "printLabels",
                            value: function(t) {
                                var e, i = this,
                                    a = t.i,
                                    s = t.j,
                                    r = t.values,
                                    o = t.ttItems,
                                    l = t.shared,
                                    c = t.e,
                                    h = this.w,
                                    d = [],
                                    u = function(t) {
                                        return h.globals.seriesGoals[t] && h.globals.seriesGoals[t][s] && Array.isArray(h.globals.seriesGoals[t][s])
                                    },
                                    p = r.xVal,
                                    g = r.zVal,
                                    f = r.xAxisTTVal,
                                    m = "",
                                    x = h.globals.colors[a];
                                null !== s && h.config.plotOptions.bar.distributed && (x = h.globals.colors[s]);
                                for (var v = function(t, r) {
                                        var v = i.getFormatters(a);
                                        m = i.getSeriesName({
                                            fn: v.yLbTitleFormatter,
                                            index: a,
                                            seriesIndex: a,
                                            j: s
                                        }), "treemap" === h.config.chart.type && (m = v.yLbTitleFormatter(String(h.config.series[a].data[s].x), {
                                            series: h.globals.series,
                                            seriesIndex: a,
                                            dataPointIndex: s,
                                            w: h
                                        }));
                                        var b = h.config.tooltip.inverseOrder ? r : t;
                                        if (h.globals.axisCharts) {
                                            var y = function(t) {
                                                return v.yLbFormatter(h.globals.series[t][s], {
                                                    series: h.globals.series,
                                                    seriesIndex: t,
                                                    dataPointIndex: s,
                                                    w: h
                                                })
                                            };
                                            if (l) v = i.getFormatters(b), m = i.getSeriesName({
                                                fn: v.yLbTitleFormatter,
                                                index: b,
                                                seriesIndex: a,
                                                j: s
                                            }), x = h.globals.colors[b], e = y(b), u(b) && (d = h.globals.seriesGoals[b][s].map((function(t) {
                                                return {
                                                    attrs: t,
                                                    val: v.yLbFormatter(t.value, {
                                                        seriesIndex: b,
                                                        dataPointIndex: s,
                                                        w: h
                                                    })
                                                }
                                            })));
                                            else {
                                                var w, S = null == c || null === (w = c.target) || void 0 === w ? void 0 : w.getAttribute("fill");
                                                S && (x = -1 !== S.indexOf("url") ? document.querySelector(S.substr(4).slice(0, -1)).childNodes[0].getAttribute("stroke") : S), e = y(a), u(a) && Array.isArray(h.globals.seriesGoals[a][s]) && (d = h.globals.seriesGoals[a][s].map((function(t) {
                                                    return {
                                                        attrs: t,
                                                        val: v.yLbFormatter(t.value, {
                                                            seriesIndex: a,
                                                            dataPointIndex: s,
                                                            w: h
                                                        })
                                                    }
                                                })))
                                            }
                                        }
                                        null === s && (e = v.yLbFormatter(h.globals.series[a], n(n({}, h), {}, {
                                            seriesIndex: a,
                                            dataPointIndex: a
                                        }))), i.DOMHandling({
                                            i: a,
                                            t: b,
                                            j: s,
                                            ttItems: o,
                                            values: {
                                                val: e,
                                                goalVals: d,
                                                xVal: p,
                                                xAxisTTVal: f,
                                                zVal: g
                                            },
                                            seriesName: m,
                                            shared: l,
                                            pColor: x
                                        })
                                    }, b = 0, y = h.globals.series.length - 1; b < h.globals.series.length; b++, y--) v(b, y)
                            }
                        }, {
                            key: "getFormatters",
                            value: function(t) {
                                var e, i = this.w,
                                    a = i.globals.yLabelFormatters[t];
                                return void 0 !== i.globals.ttVal ? Array.isArray(i.globals.ttVal) ? (a = i.globals.ttVal[t] && i.globals.ttVal[t].formatter, e = i.globals.ttVal[t] && i.globals.ttVal[t].title && i.globals.ttVal[t].title.formatter) : (a = i.globals.ttVal.formatter, "function" == typeof i.globals.ttVal.title.formatter && (e = i.globals.ttVal.title.formatter)) : e = i.config.tooltip.y.title.formatter, "function" != typeof a && (a = i.globals.yLabelFormatters[0] ? i.globals.yLabelFormatters[0] : function(t) {
                                    return t
                                }), "function" != typeof e && (e = function(t) {
                                    return t
                                }), {
                                    yLbFormatter: a,
                                    yLbTitleFormatter: e
                                }
                            }
                        }, {
                            key: "getSeriesName",
                            value: function(t) {
                                var e = t.fn,
                                    i = t.index,
                                    a = t.seriesIndex,
                                    s = t.j,
                                    n = this.w;
                                return e(String(n.globals.seriesNames[i]), {
                                    series: n.globals.series,
                                    seriesIndex: a,
                                    dataPointIndex: s,
                                    w: n
                                })
                            }
                        }, {
                            key: "DOMHandling",
                            value: function(t) {
                                t.i;
                                var e = t.t,
                                    i = t.j,
                                    a = t.ttItems,
                                    s = t.values,
                                    n = t.seriesName,
                                    r = t.shared,
                                    o = t.pColor,
                                    l = this.w,
                                    c = this.ttCtx,
                                    h = s.val,
                                    d = s.goalVals,
                                    u = s.xVal,
                                    p = s.xAxisTTVal,
                                    g = s.zVal,
                                    f = null;
                                f = a[e].children, l.config.tooltip.fillSeriesColor && (a[e].style.backgroundColor = o, f[0].style.display = "none"), c.showTooltipTitle && (null === c.tooltipTitle && (c.tooltipTitle = l.globals.dom.baseEl.querySelector(".apexcharts-tooltip-title")), c.tooltipTitle.innerHTML = u), c.isXAxisTooltipEnabled && (c.xaxisTooltipText.innerHTML = "" !== p ? p : u);
                                var m = a[e].querySelector(".apexcharts-tooltip-text-y-label");
                                m && (m.innerHTML = n || "");
                                var x = a[e].querySelector(".apexcharts-tooltip-text-y-value");
                                x && (x.innerHTML = void 0 !== h ? h : ""), f[0] && f[0].classList.contains("apexcharts-tooltip-marker") && (l.config.tooltip.marker.fillColors && Array.isArray(l.config.tooltip.marker.fillColors) && (o = l.config.tooltip.marker.fillColors[e]), f[0].style.backgroundColor = o), l.config.tooltip.marker.show || (f[0].style.display = "none");
                                var v = a[e].querySelector(".apexcharts-tooltip-text-goals-label"),
                                    b = a[e].querySelector(".apexcharts-tooltip-text-goals-value");
                                if (d.length && l.globals.seriesGoals[e]) {
                                    var y = function() {
                                        var t = "<div >",
                                            e = "<div>";
                                        d.forEach((function(i, a) {
                                            t += ' <div style="display: flex"><span class="apexcharts-tooltip-marker" style="background-color: '.concat(i.attrs.strokeColor, '; height: 3px; border-radius: 0; top: 5px;"></span> ').concat(i.attrs.name, "</div>"), e += "<div>".concat(i.val, "</div>")
                                        })), v.innerHTML = t + "</div>", b.innerHTML = e + "</div>"
                                    };
                                    r ? l.globals.seriesGoals[e][i] && Array.isArray(l.globals.seriesGoals[e][i]) ? y() : (v.innerHTML = "", b.innerHTML = "") : y()
                                } else v.innerHTML = "", b.innerHTML = "";
                                null !== g && (a[e].querySelector(".apexcharts-tooltip-text-z-label").innerHTML = l.config.tooltip.z.title, a[e].querySelector(".apexcharts-tooltip-text-z-value").innerHTML = void 0 !== g ? g : ""), r && f[0] && (null == h || l.globals.ancillaryCollapsedSeriesIndices.indexOf(e) > -1 || l.globals.collapsedSeriesIndices.indexOf(e) > -1 ? f[0].parentNode.style.display = "none" : f[0].parentNode.style.display = l.config.tooltip.items.display)
                            }
                        }, {
                            key: "toggleActiveInactiveSeries",
                            value: function(t) {
                                var e = this.w;
                                if (t) this.tooltipUtil.toggleAllTooltipSeriesGroups("enable");
                                else {
                                    this.tooltipUtil.toggleAllTooltipSeriesGroups("disable");
                                    var i = e.globals.dom.baseEl.querySelector(".apexcharts-tooltip-series-group");
                                    i && (i.classList.add("apexcharts-active"), i.style.display = e.config.tooltip.items.display)
                                }
                            }
                        }, {
                            key: "getValuesToPrint",
                            value: function(t) {
                                var e = t.i,
                                    i = t.j,
                                    a = this.w,
                                    s = this.ctx.series.filteredSeriesX(),
                                    n = "",
                                    r = "",
                                    o = null,
                                    l = null,
                                    c = {
                                        series: a.globals.series,
                                        seriesIndex: e,
                                        dataPointIndex: i,
                                        w: a
                                    },
                                    h = a.globals.ttZFormatter;
                                null === i ? l = a.globals.series[e] : a.globals.isXNumeric && "treemap" !== a.config.chart.type ? (n = s[e][i], 0 === s[e].length && (n = s[this.tooltipUtil.getFirstActiveXArray(s)][i])) : n = void 0 !== a.globals.labels[i] ? a.globals.labels[i] : "";
                                var d = n;
                                return n = a.globals.isXNumeric && "datetime" === a.config.xaxis.type ? new V(this.ctx).xLabelFormat(a.globals.ttKeyFormatter, d, d, {
                                    i: void 0,
                                    dateFormatter: new F(this.ctx).formatDate,
                                    w: this.w
                                }) : a.globals.isBarHorizontal ? a.globals.yLabelFormatters[0](d, c) : a.globals.xLabelFormatter(d, c), void 0 !== a.config.tooltip.x.formatter && (n = a.globals.ttKeyFormatter(d, c)), a.globals.seriesZ.length > 0 && a.globals.seriesZ[e].length > 0 && (o = h(a.globals.seriesZ[e][i], a)), r = "function" == typeof a.config.xaxis.tooltip.formatter ? a.globals.xaxisTooltipFormatter(d, c) : n, {
                                    val: Array.isArray(l) ? l.join(" ") : l,
                                    xVal: Array.isArray(n) ? n.join(" ") : n,
                                    xAxisTTVal: Array.isArray(r) ? r.join(" ") : r,
                                    zVal: o
                                }
                            }
                        }, {
                            key: "handleCustomTooltip",
                            value: function(t) {
                                var e = t.i,
                                    i = t.j,
                                    a = t.y1,
                                    s = t.y2,
                                    n = t.w,
                                    r = this.ttCtx.getElTooltip(),
                                    o = n.config.tooltip.custom;
                                Array.isArray(o) && o[e] && (o = o[e]), r.innerHTML = o({
                                    ctx: this.ctx,
                                    series: n.globals.series,
                                    seriesIndex: e,
                                    dataPointIndex: i,
                                    y1: a,
                                    y2: s,
                                    w: n
                                })
                            }
                        }]), t
                    }(),
                    vt = function() {
                        function t(e) {
                            o(this, t), this.ttCtx = e, this.ctx = e.ctx, this.w = e.w
                        }
                        return c(t, [{
                            key: "moveXCrosshairs",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
                                    i = this.ttCtx,
                                    a = this.w,
                                    s = i.getElXCrosshairs(),
                                    n = t - i.xcrosshairsWidth / 2,
                                    r = a.globals.labels.slice().length;
                                if (null !== e && (n = a.globals.gridWidth / r * e), null === s || a.globals.isBarHorizontal || (s.setAttribute("x", n), s.setAttribute("x1", n), s.setAttribute("x2", n), s.setAttribute("y2", a.globals.gridHeight), s.classList.add("apexcharts-active")), n < 0 && (n = 0), n > a.globals.gridWidth && (n = a.globals.gridWidth), i.isXAxisTooltipEnabled) {
                                    var o = n;
                                    "tickWidth" !== a.config.xaxis.crosshairs.width && "barWidth" !== a.config.xaxis.crosshairs.width || (o = n + i.xcrosshairsWidth / 2), this.moveXAxisTooltip(o)
                                }
                            }
                        }, {
                            key: "moveYCrosshairs",
                            value: function(t) {
                                var e = this.ttCtx;
                                null !== e.ycrosshairs && S.setAttrs(e.ycrosshairs, {
                                    y1: t,
                                    y2: t
                                }), null !== e.ycrosshairsHidden && S.setAttrs(e.ycrosshairsHidden, {
                                    y1: t,
                                    y2: t
                                })
                            }
                        }, {
                            key: "moveXAxisTooltip",
                            value: function(t) {
                                var e = this.w,
                                    i = this.ttCtx;
                                if (null !== i.xaxisTooltip && 0 !== i.xcrosshairsWidth) {
                                    i.xaxisTooltip.classList.add("apexcharts-active");
                                    var a, s = i.xaxisOffY + e.config.xaxis.tooltip.offsetY + e.globals.translateY + 1 + e.config.xaxis.offsetY;
                                    if (t -= i.xaxisTooltip.getBoundingClientRect().width / 2, !isNaN(t)) t += e.globals.translateX, a = new S(this.ctx).getTextRects(i.xaxisTooltipText.innerHTML), i.xaxisTooltipText.style.minWidth = a.width + "px", i.xaxisTooltip.style.left = t + "px", i.xaxisTooltip.style.top = s + "px"
                                }
                            }
                        }, {
                            key: "moveYAxisTooltip",
                            value: function(t) {
                                var e = this.w,
                                    i = this.ttCtx;
                                null === i.yaxisTTEls && (i.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                                var a = parseInt(i.ycrosshairsHidden.getAttribute("y1"), 10),
                                    s = e.globals.translateY + a,
                                    n = i.yaxisTTEls[t].getBoundingClientRect().height,
                                    r = e.globals.translateYAxisX[t] - 2;
                                e.config.yaxis[t].opposite && (r -= 26), s -= n / 2, -1 === e.globals.ignoreYAxisIndexes.indexOf(t) ? (i.yaxisTTEls[t].classList.add("apexcharts-active"), i.yaxisTTEls[t].style.top = s + "px", i.yaxisTTEls[t].style.left = r + e.config.yaxis[t].tooltip.offsetX + "px") : i.yaxisTTEls[t].classList.remove("apexcharts-active")
                            }
                        }, {
                            key: "moveTooltip",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                    a = this.w,
                                    s = this.ttCtx,
                                    n = s.getElTooltip(),
                                    r = s.tooltipRect,
                                    o = null !== i ? parseFloat(i) : 1,
                                    l = parseFloat(t) + o + 5,
                                    c = parseFloat(e) + o / 2;
                                if (l > a.globals.gridWidth / 2 && (l = l - r.ttWidth - o - 10), l > a.globals.gridWidth - r.ttWidth - 10 && (l = a.globals.gridWidth - r.ttWidth), l < -20 && (l = -20), a.config.tooltip.followCursor) {
                                    var h = s.getElGrid(),
                                        d = h.getBoundingClientRect();
                                    c = s.e.clientY + a.globals.translateY - d.top - r.ttHeight / 2
                                } else a.globals.isBarHorizontal || (r.ttHeight / 2 + c > a.globals.gridHeight && (c = a.globals.gridHeight - r.ttHeight + a.globals.translateY), c < 0 && (c = 0));
                                isNaN(l) || (l += a.globals.translateX, n.style.left = l + "px", n.style.top = c + "px")
                            }
                        }, {
                            key: "moveMarkers",
                            value: function(t, e) {
                                var i = this.w,
                                    a = this.ttCtx;
                                if (i.globals.markers.size[t] > 0)
                                    for (var s = i.globals.dom.baseEl.querySelectorAll(" .apexcharts-series[data\\:realIndex='".concat(t, "'] .apexcharts-marker")), n = 0; n < s.length; n++) parseInt(s[n].getAttribute("rel"), 10) === e && (a.marker.resetPointsSize(), a.marker.enlargeCurrentPoint(e, s[n]));
                                else a.marker.resetPointsSize(), this.moveDynamicPointOnHover(e, t)
                            }
                        }, {
                            key: "moveDynamicPointOnHover",
                            value: function(t, e) {
                                var i, a, s = this.w,
                                    n = this.ttCtx,
                                    r = s.globals.pointsArray,
                                    o = n.tooltipUtil.getHoverMarkerSize(e),
                                    l = s.config.series[e].type;
                                if (!l || "column" !== l && "candlestick" !== l && "boxPlot" !== l) {
                                    i = r[e][t][0], a = r[e][t][1] ? r[e][t][1] : 0;
                                    var c = s.globals.dom.baseEl.querySelector(".apexcharts-series[data\\:realIndex='".concat(e, "'] .apexcharts-series-markers circle"));
                                    c && a < s.globals.gridHeight && a > 0 && (c.setAttribute("r", o), c.setAttribute("cx", i), c.setAttribute("cy", a)), this.moveXCrosshairs(i), n.fixedTooltip || this.moveTooltip(i, a, o)
                                }
                            }
                        }, {
                            key: "moveDynamicPointsOnHover",
                            value: function(t) {
                                var e, i = this.ttCtx,
                                    a = i.w,
                                    s = 0,
                                    n = 0,
                                    r = a.globals.pointsArray;
                                e = new O(this.ctx).getActiveConfigSeriesIndex(!0);
                                var o = i.tooltipUtil.getHoverMarkerSize(e);
                                r[e] && (s = r[e][t][0], n = r[e][t][1]);
                                var l = i.tooltipUtil.getAllMarkers();
                                if (null !== l)
                                    for (var c = 0; c < a.globals.series.length; c++) {
                                        var h = r[c];
                                        if (a.globals.comboCharts && void 0 === h && l.splice(c, 0, null), h && h.length) {
                                            var d = r[c][t][1];
                                            l[c].setAttribute("cx", s), null !== d && !isNaN(d) && d < a.globals.gridHeight + o && d + o > 0 ? (l[c] && l[c].setAttribute("r", o), l[c] && l[c].setAttribute("cy", d)) : l[c] && l[c].setAttribute("r", 0)
                                        }
                                    }
                                if (this.moveXCrosshairs(s), !i.fixedTooltip) {
                                    var u = n || a.globals.gridHeight;
                                    this.moveTooltip(s, u, o)
                                }
                            }
                        }, {
                            key: "moveStickyTooltipOverBars",
                            value: function(t) {
                                var e = this.w,
                                    i = this.ttCtx,
                                    a = e.globals.columnSeries ? e.globals.columnSeries.length : e.globals.series.length,
                                    s = a >= 2 && a % 2 == 0 ? Math.floor(a / 2) : Math.floor(a / 2) + 1;
                                e.globals.isBarHorizontal && (s = new O(this.ctx).getActiveConfigSeriesIndex(!1, "desc") + 1);
                                var n = e.globals.dom.baseEl.querySelector(".apexcharts-bar-series .apexcharts-series[rel='".concat(s, "'] path[j='").concat(t, "'], .apexcharts-candlestick-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "'], .apexcharts-boxPlot-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "'], .apexcharts-rangebar-series .apexcharts-series[rel='").concat(s, "'] path[j='").concat(t, "']")),
                                    r = n ? parseFloat(n.getAttribute("cx")) : 0,
                                    o = n ? parseFloat(n.getAttribute("cy")) : 0,
                                    l = n ? parseFloat(n.getAttribute("barWidth")) : 0,
                                    c = n ? parseFloat(n.getAttribute("barHeight")) : 0,
                                    h = i.getElGrid().getBoundingClientRect(),
                                    d = n.classList.contains("apexcharts-candlestick-area") || n.classList.contains("apexcharts-boxPlot-area");
                                if (e.globals.isXNumeric ? (n && !d && (r -= a % 2 != 0 ? l / 2 : 0), n && d && e.globals.comboCharts && (r -= l / 2)) : e.globals.isBarHorizontal || (r = i.xAxisTicksPositions[t - 1] + i.dataPointsDividedWidth / 2, isNaN(r) && (r = i.xAxisTicksPositions[t] - i.dataPointsDividedWidth / 2)), e.globals.isBarHorizontal ? (o > e.globals.gridHeight / 2 && (o -= i.tooltipRect.ttHeight), (o = o + e.config.grid.padding.top + c / 3) + c > e.globals.gridHeight && (o = e.globals.gridHeight - c)) : e.config.tooltip.followCursor ? o = i.e.clientY - h.top - i.tooltipRect.ttHeight / 2 : o + i.tooltipRect.ttHeight + 15 > e.globals.gridHeight && (o = e.globals.gridHeight), o < -10 && (o = -10), e.globals.isBarHorizontal || this.moveXCrosshairs(r), !i.fixedTooltip) {
                                    var u = o || e.globals.gridHeight;
                                    this.moveTooltip(r, u)
                                }
                            }
                        }]), t
                    }(),
                    bt = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.ttCtx = e, this.ctx = e.ctx, this.tooltipPosition = new vt(e)
                        }
                        return c(t, [{
                            key: "drawDynamicPoints",
                            value: function() {
                                var t = this.w,
                                    e = new S(this.ctx),
                                    i = new _(this.ctx),
                                    a = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                                a = m(a), t.config.chart.stacked && a.sort((function(t, e) {
                                    return parseFloat(t.getAttribute("data:realIndex")) - parseFloat(e.getAttribute("data:realIndex"))
                                }));
                                for (var s = 0; s < a.length; s++) {
                                    var n = a[s].querySelector(".apexcharts-series-markers-wrap");
                                    if (null !== n) {
                                        var r = void 0,
                                            o = "apexcharts-marker w".concat((Math.random() + 1).toString(36).substring(4));
                                        "line" !== t.config.chart.type && "area" !== t.config.chart.type || t.globals.comboCharts || t.config.tooltip.intersect || (o += " no-pointer-events");
                                        var l = i.getMarkerConfig({
                                            cssClass: o,
                                            seriesIndex: Number(n.getAttribute("data:realIndex"))
                                        });
                                        (r = e.drawMarker(0, 0, l)).node.setAttribute("default-marker-size", 0);
                                        var c = document.createElementNS(t.globals.SVGNS, "g");
                                        c.classList.add("apexcharts-series-markers"), c.appendChild(r.node), n.appendChild(c)
                                    }
                                }
                            }
                        }, {
                            key: "enlargeCurrentPoint",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
                                    a = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
                                    s = this.w;
                                "bubble" !== s.config.chart.type && this.newPointSize(t, e);
                                var n = e.getAttribute("cx"),
                                    r = e.getAttribute("cy");
                                if (null !== i && null !== a && (n = i, r = a), this.tooltipPosition.moveXCrosshairs(n), !this.fixedTooltip) {
                                    if ("radar" === s.config.chart.type) {
                                        var o = this.ttCtx.getElGrid(),
                                            l = o.getBoundingClientRect();
                                        n = this.ttCtx.e.clientX - l.left
                                    }
                                    this.tooltipPosition.moveTooltip(n, r, s.config.markers.hover.size)
                                }
                            }
                        }, {
                            key: "enlargePoints",
                            value: function(t) {
                                for (var e = this.w, i = this, a = this.ttCtx, s = t, n = e.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), r = e.config.markers.hover.size, o = 0; o < n.length; o++) {
                                    var l = n[o].getAttribute("rel"),
                                        c = n[o].getAttribute("index");
                                    if (void 0 === r && (r = e.globals.markers.size[c] + e.config.markers.hover.sizeOffset), s === parseInt(l, 10)) {
                                        i.newPointSize(s, n[o]);
                                        var h = n[o].getAttribute("cx"),
                                            d = n[o].getAttribute("cy");
                                        i.tooltipPosition.moveXCrosshairs(h), a.fixedTooltip || i.tooltipPosition.moveTooltip(h, d, r)
                                    } else i.oldPointSize(n[o])
                                }
                            }
                        }, {
                            key: "newPointSize",
                            value: function(t, e) {
                                var i = this.w,
                                    a = i.config.markers.hover.size,
                                    s = 0 === t ? e.parentNode.firstChild : e.parentNode.lastChild;
                                if ("0" !== s.getAttribute("default-marker-size")) {
                                    var n = parseInt(s.getAttribute("index"), 10);
                                    void 0 === a && (a = i.globals.markers.size[n] + i.config.markers.hover.sizeOffset), a < 0 && (a = 0), s.setAttribute("r", a)
                                }
                            }
                        }, {
                            key: "oldPointSize",
                            value: function(t) {
                                var e = parseFloat(t.getAttribute("default-marker-size"));
                                t.setAttribute("r", e)
                            }
                        }, {
                            key: "resetPointsSize",
                            value: function() {
                                for (var t = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series:not(.apexcharts-series-collapsed) .apexcharts-marker"), e = 0; e < t.length; e++) {
                                    var i = parseFloat(t[e].getAttribute("default-marker-size"));
                                    b.isNumber(i) && i >= 0 ? t[e].setAttribute("r", i) : t[e].setAttribute("r", 0)
                                }
                            }
                        }]), t
                    }(),
                    yt = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.ttCtx = e
                        }
                        return c(t, [{
                            key: "getAttr",
                            value: function(t, e) {
                                return parseFloat(t.target.getAttribute(e))
                            }
                        }, {
                            key: "handleHeatTreeTooltip",
                            value: function(t) {
                                var e = t.e,
                                    i = t.opt,
                                    a = t.x,
                                    s = t.y,
                                    n = t.type,
                                    r = this.ttCtx,
                                    o = this.w;
                                if (e.target.classList.contains("apexcharts-".concat(n, "-rect"))) {
                                    var l = this.getAttr(e, "i"),
                                        c = this.getAttr(e, "j"),
                                        h = this.getAttr(e, "cx"),
                                        d = this.getAttr(e, "cy"),
                                        u = this.getAttr(e, "width"),
                                        p = this.getAttr(e, "height");
                                    if (r.tooltipLabels.drawSeriesTexts({
                                            ttItems: i.ttItems,
                                            i: l,
                                            j: c,
                                            shared: !1,
                                            e
                                        }), o.globals.capturedSeriesIndex = l, o.globals.capturedDataPointIndex = c, a = h + r.tooltipRect.ttWidth / 2 + u, s = d + r.tooltipRect.ttHeight / 2 - p / 2, r.tooltipPosition.moveXCrosshairs(h + u / 2), a > o.globals.gridWidth / 2 && (a = h - r.tooltipRect.ttWidth / 2 + u), r.w.config.tooltip.followCursor) {
                                        var g = o.globals.dom.elWrap.getBoundingClientRect();
                                        a = o.globals.clientX - g.left - (a > o.globals.gridWidth / 2 ? r.tooltipRect.ttWidth : 0), s = o.globals.clientY - g.top - (s > o.globals.gridHeight / 2 ? r.tooltipRect.ttHeight : 0)
                                    }
                                }
                                return {
                                    x: a,
                                    y: s
                                }
                            }
                        }, {
                            key: "handleMarkerTooltip",
                            value: function(t) {
                                var e, i, a = t.e,
                                    s = t.opt,
                                    n = t.x,
                                    r = t.y,
                                    o = this.w,
                                    l = this.ttCtx;
                                if (a.target.classList.contains("apexcharts-marker")) {
                                    var c = parseInt(s.paths.getAttribute("cx"), 10),
                                        h = parseInt(s.paths.getAttribute("cy"), 10),
                                        d = parseFloat(s.paths.getAttribute("val"));
                                    if (i = parseInt(s.paths.getAttribute("rel"), 10), e = parseInt(s.paths.parentNode.parentNode.parentNode.getAttribute("rel"), 10) - 1, l.intersect) {
                                        var u = b.findAncestor(s.paths, "apexcharts-series");
                                        u && (e = parseInt(u.getAttribute("data:realIndex"), 10))
                                    }
                                    if (l.tooltipLabels.drawSeriesTexts({
                                            ttItems: s.ttItems,
                                            i: e,
                                            j: i,
                                            shared: !l.showOnIntersect && o.config.tooltip.shared,
                                            e: a
                                        }), "mouseup" === a.type && l.markerClick(a, e, i), o.globals.capturedSeriesIndex = e, o.globals.capturedDataPointIndex = i, n = c, r = h + o.globals.translateY - 1.4 * l.tooltipRect.ttHeight, l.w.config.tooltip.followCursor) {
                                        var p = l.getElGrid().getBoundingClientRect();
                                        r = l.e.clientY + o.globals.translateY - p.top
                                    }
                                    d < 0 && (r = h), l.marker.enlargeCurrentPoint(i, s.paths, n, r)
                                }
                                return {
                                    x: n,
                                    y: r
                                }
                            }
                        }, {
                            key: "handleBarTooltip",
                            value: function(t) {
                                var e, i, a = t.e,
                                    s = t.opt,
                                    n = this.w,
                                    r = this.ttCtx,
                                    o = r.getElTooltip(),
                                    l = 0,
                                    c = 0,
                                    h = 0,
                                    d = this.getBarTooltipXY({
                                        e: a,
                                        opt: s
                                    });
                                e = d.i;
                                var u = d.barHeight,
                                    p = d.j;
                                n.globals.capturedSeriesIndex = e, n.globals.capturedDataPointIndex = p, n.globals.isBarHorizontal && r.tooltipUtil.hasBars() || !n.config.tooltip.shared ? (c = d.x, h = d.y, i = Array.isArray(n.config.stroke.width) ? n.config.stroke.width[e] : n.config.stroke.width, l = c) : n.globals.comboCharts || n.config.tooltip.shared || (l /= 2), isNaN(h) ? h = n.globals.svgHeight - r.tooltipRect.ttHeight : h < 0 && (h = 0);
                                var g = parseInt(s.paths.parentNode.getAttribute("data:realIndex"), 10),
                                    f = n.globals.isMultipleYAxis ? n.config.yaxis[g] && n.config.yaxis[g].reversed : n.config.yaxis[0].reversed;
                                if (c + r.tooltipRect.ttWidth > n.globals.gridWidth && !f ? c -= r.tooltipRect.ttWidth : c < 0 && (c = 0), r.w.config.tooltip.followCursor) {
                                    var m = r.getElGrid().getBoundingClientRect();
                                    h = r.e.clientY - m.top
                                }
                                null === r.tooltip && (r.tooltip = n.globals.dom.baseEl.querySelector(".apexcharts-tooltip")), n.config.tooltip.shared || (n.globals.comboBarCount > 0 ? r.tooltipPosition.moveXCrosshairs(l + i / 2) : r.tooltipPosition.moveXCrosshairs(l)), !r.fixedTooltip && (!n.config.tooltip.shared || n.globals.isBarHorizontal && r.tooltipUtil.hasBars()) && (f && (c -= r.tooltipRect.ttWidth) < 0 && (c = 0), !f || n.globals.isBarHorizontal && r.tooltipUtil.hasBars() || (h = h + u - 2 * (n.globals.series[e][p] < 0 ? u : 0)), r.tooltipRect.ttHeight + h > n.globals.gridHeight ? h = n.globals.gridHeight - r.tooltipRect.ttHeight + n.globals.translateY : (h = h + n.globals.translateY - r.tooltipRect.ttHeight / 2) < 0 && (h = 0), o.style.left = c + n.globals.translateX + "px", o.style.top = h + "px")
                            }
                        }, {
                            key: "getBarTooltipXY",
                            value: function(t) {
                                var e = t.e,
                                    i = t.opt,
                                    a = this.w,
                                    s = null,
                                    n = this.ttCtx,
                                    r = 0,
                                    o = 0,
                                    l = 0,
                                    c = 0,
                                    h = 0,
                                    d = e.target.classList;
                                if (d.contains("apexcharts-bar-area") || d.contains("apexcharts-candlestick-area") || d.contains("apexcharts-boxPlot-area") || d.contains("apexcharts-rangebar-area")) {
                                    var u = e.target,
                                        p = u.getBoundingClientRect(),
                                        g = i.elGrid.getBoundingClientRect(),
                                        f = p.height;
                                    h = p.height;
                                    var m = p.width,
                                        x = parseInt(u.getAttribute("cx"), 10),
                                        v = parseInt(u.getAttribute("cy"), 10);
                                    c = parseFloat(u.getAttribute("barWidth"));
                                    var b = "touchmove" === e.type ? e.touches[0].clientX : e.clientX;
                                    s = parseInt(u.getAttribute("j"), 10), r = parseInt(u.parentNode.getAttribute("rel"), 10) - 1;
                                    var y = u.getAttribute("data-range-y1"),
                                        w = u.getAttribute("data-range-y2");
                                    a.globals.comboCharts && (r = parseInt(u.parentNode.getAttribute("data:realIndex"), 10)), n.tooltipLabels.drawSeriesTexts({
                                        ttItems: i.ttItems,
                                        i: r,
                                        j: s,
                                        y1: y ? parseInt(y, 10) : null,
                                        y2: w ? parseInt(w, 10) : null,
                                        shared: !n.showOnIntersect && a.config.tooltip.shared,
                                        e
                                    }), a.config.tooltip.followCursor ? a.globals.isBarHorizontal ? (o = b - g.left + 15, l = v - n.dataPointsDividedHeight + f / 2 - n.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? x - m / 2 : x - n.dataPointsDividedWidth + m / 2, l = e.clientY - g.top - n.tooltipRect.ttHeight / 2 - 15) : a.globals.isBarHorizontal ? ((o = x) < n.xyRatios.baseLineInvertedY && (o = x - n.tooltipRect.ttWidth), l = v - n.dataPointsDividedHeight + f / 2 - n.tooltipRect.ttHeight / 2) : (o = a.globals.isXNumeric ? x - m / 2 : x - n.dataPointsDividedWidth + m / 2, l = v)
                                }
                                return {
                                    x: o,
                                    y: l,
                                    barHeight: h,
                                    barWidth: c,
                                    i: r,
                                    j: s
                                }
                            }
                        }]), t
                    }(),
                    wt = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.ttCtx = e
                        }
                        return c(t, [{
                            key: "drawXaxisTooltip",
                            value: function() {
                                var t = this.w,
                                    e = this.ttCtx,
                                    i = "bottom" === t.config.xaxis.position;
                                e.xaxisOffY = i ? t.globals.gridHeight + 1 : -t.globals.xAxisHeight - t.config.xaxis.axisTicks.height + 3;
                                var a = i ? "apexcharts-xaxistooltip apexcharts-xaxistooltip-bottom" : "apexcharts-xaxistooltip apexcharts-xaxistooltip-top",
                                    s = t.globals.dom.elWrap;
                                e.isXAxisTooltipEnabled && null === t.globals.dom.baseEl.querySelector(".apexcharts-xaxistooltip") && (e.xaxisTooltip = document.createElement("div"), e.xaxisTooltip.setAttribute("class", a + " apexcharts-theme-" + t.config.tooltip.theme), s.appendChild(e.xaxisTooltip), e.xaxisTooltipText = document.createElement("div"), e.xaxisTooltipText.classList.add("apexcharts-xaxistooltip-text"), e.xaxisTooltipText.style.fontFamily = t.config.xaxis.tooltip.style.fontFamily || t.config.chart.fontFamily, e.xaxisTooltipText.style.fontSize = t.config.xaxis.tooltip.style.fontSize, e.xaxisTooltip.appendChild(e.xaxisTooltipText))
                            }
                        }, {
                            key: "drawYaxisTooltip",
                            value: function() {
                                for (var t = this.w, e = this.ttCtx, i = function(i) {
                                        var a = t.config.yaxis[i].opposite || t.config.yaxis[i].crosshairs.opposite;
                                        e.yaxisOffX = a ? t.globals.gridWidth + 1 : 1;
                                        var s = "apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i, a ? " apexcharts-yaxistooltip-right" : " apexcharts-yaxistooltip-left");
                                        t.globals.yAxisSameScaleIndices.map((function(e, a) {
                                            e.map((function(e, a) {
                                                a === i && (s += t.config.yaxis[a].show ? " " : " apexcharts-yaxistooltip-hidden")
                                            }))
                                        }));
                                        var n = t.globals.dom.elWrap;
                                        null === t.globals.dom.baseEl.querySelector(".apexcharts-yaxistooltip apexcharts-yaxistooltip-".concat(i)) && (e.yaxisTooltip = document.createElement("div"), e.yaxisTooltip.setAttribute("class", s + " apexcharts-theme-" + t.config.tooltip.theme), n.appendChild(e.yaxisTooltip), 0 === i && (e.yaxisTooltipText = []), e.yaxisTooltipText[i] = document.createElement("div"), e.yaxisTooltipText[i].classList.add("apexcharts-yaxistooltip-text"), e.yaxisTooltip.appendChild(e.yaxisTooltipText[i]))
                                    }, a = 0; a < t.config.yaxis.length; a++) i(a)
                            }
                        }, {
                            key: "setXCrosshairWidth",
                            value: function() {
                                var t = this.w,
                                    e = this.ttCtx,
                                    i = e.getElXCrosshairs();
                                if (e.xcrosshairsWidth = parseInt(t.config.xaxis.crosshairs.width, 10), t.globals.comboCharts) {
                                    var a = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                                    if (null !== a && "barWidth" === t.config.xaxis.crosshairs.width) {
                                        var s = parseFloat(a.getAttribute("barWidth"));
                                        e.xcrosshairsWidth = s
                                    } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
                                        var n = t.globals.labels.length;
                                        e.xcrosshairsWidth = t.globals.gridWidth / n
                                    }
                                } else if ("tickWidth" === t.config.xaxis.crosshairs.width) {
                                    var r = t.globals.labels.length;
                                    e.xcrosshairsWidth = t.globals.gridWidth / r
                                } else if ("barWidth" === t.config.xaxis.crosshairs.width) {
                                    var o = t.globals.dom.baseEl.querySelector(".apexcharts-bar-area");
                                    if (null !== o) {
                                        var l = parseFloat(o.getAttribute("barWidth"));
                                        e.xcrosshairsWidth = l
                                    } else e.xcrosshairsWidth = 1
                                }
                                t.globals.isBarHorizontal && (e.xcrosshairsWidth = 0), null !== i && e.xcrosshairsWidth > 0 && i.setAttribute("width", e.xcrosshairsWidth)
                            }
                        }, {
                            key: "handleYCrosshair",
                            value: function() {
                                var t = this.w,
                                    e = this.ttCtx;
                                e.ycrosshairs = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs"), e.ycrosshairsHidden = t.globals.dom.baseEl.querySelector(".apexcharts-ycrosshairs-hidden")
                            }
                        }, {
                            key: "drawYaxisTooltipText",
                            value: function(t, e, i) {
                                var a = this.ttCtx,
                                    s = this.w,
                                    n = s.globals.yLabelFormatters[t];
                                if (a.yaxisTooltips[t]) {
                                    var r = a.getElGrid().getBoundingClientRect(),
                                        o = (e - r.top) * i.yRatio[t],
                                        l = s.globals.maxYArr[t] - s.globals.minYArr[t],
                                        c = s.globals.minYArr[t] + (l - o);
                                    a.tooltipPosition.moveYCrosshairs(e - r.top), a.yaxisTooltipText[t].innerHTML = n(c), a.tooltipPosition.moveYAxisTooltip(t)
                                }
                            }
                        }]), t
                    }(),
                    St = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var i = this.w;
                            this.tConfig = i.config.tooltip, this.tooltipUtil = new mt(this), this.tooltipLabels = new xt(this), this.tooltipPosition = new vt(this), this.marker = new bt(this), this.intersect = new yt(this), this.axesTooltip = new wt(this), this.showOnIntersect = this.tConfig.intersect, this.showTooltipTitle = this.tConfig.x.show, this.fixedTooltip = this.tConfig.fixed.enabled, this.xaxisTooltip = null, this.yaxisTTEls = null, this.isBarShared = !i.globals.isBarHorizontal && this.tConfig.shared, this.lastHoverTime = Date.now()
                        }
                        return c(t, [{
                            key: "getElTooltip",
                            value: function(t) {
                                return t || (t = this), t.w.globals.dom.baseEl ? t.w.globals.dom.baseEl.querySelector(".apexcharts-tooltip") : null
                            }
                        }, {
                            key: "getElXCrosshairs",
                            value: function() {
                                return this.w.globals.dom.baseEl.querySelector(".apexcharts-xcrosshairs")
                            }
                        }, {
                            key: "getElGrid",
                            value: function() {
                                return this.w.globals.dom.baseEl.querySelector(".apexcharts-grid")
                            }
                        }, {
                            key: "drawTooltip",
                            value: function(t) {
                                var e = this.w;
                                this.xyRatios = t, this.isXAxisTooltipEnabled = e.config.xaxis.tooltip.enabled && e.globals.axisCharts, this.yaxisTooltips = e.config.yaxis.map((function(t, i) {
                                    return !!(t.show && t.tooltip.enabled && e.globals.axisCharts)
                                })), this.allTooltipSeriesGroups = [], e.globals.axisCharts || (this.showTooltipTitle = !1);
                                var i = document.createElement("div");
                                if (i.classList.add("apexcharts-tooltip"), e.config.tooltip.cssClass && i.classList.add(e.config.tooltip.cssClass), i.classList.add("apexcharts-theme-".concat(this.tConfig.theme)), e.globals.dom.elWrap.appendChild(i), e.globals.axisCharts) {
                                    this.axesTooltip.drawXaxisTooltip(), this.axesTooltip.drawYaxisTooltip(), this.axesTooltip.setXCrosshairWidth(), this.axesTooltip.handleYCrosshair();
                                    var a = new q(this.ctx);
                                    this.xAxisTicksPositions = a.getXAxisTicksPositions()
                                }
                                if (!e.globals.comboCharts && !this.tConfig.intersect && "rangeBar" !== e.config.chart.type || this.tConfig.shared || (this.showOnIntersect = !0), 0 !== e.config.markers.size && 0 !== e.globals.markers.largestSize || this.marker.drawDynamicPoints(this), e.globals.collapsedSeries.length !== e.globals.series.length) {
                                    this.dataPointsDividedHeight = e.globals.gridHeight / e.globals.dataPoints, this.dataPointsDividedWidth = e.globals.gridWidth / e.globals.dataPoints, this.showTooltipTitle && (this.tooltipTitle = document.createElement("div"), this.tooltipTitle.classList.add("apexcharts-tooltip-title"), this.tooltipTitle.style.fontFamily = this.tConfig.style.fontFamily || e.config.chart.fontFamily, this.tooltipTitle.style.fontSize = this.tConfig.style.fontSize, i.appendChild(this.tooltipTitle));
                                    var s = e.globals.series.length;
                                    (e.globals.xyCharts || e.globals.comboCharts) && this.tConfig.shared && (s = this.showOnIntersect ? 1 : e.globals.series.length), this.legendLabels = e.globals.dom.baseEl.querySelectorAll(".apexcharts-legend-text"), this.ttItems = this.createTTElements(s), this.addSVGEvents()
                                }
                            }
                        }, {
                            key: "createTTElements",
                            value: function(t) {
                                for (var e = this, i = this.w, a = [], s = this.getElTooltip(), n = function(n) {
                                        var r = document.createElement("div");
                                        r.classList.add("apexcharts-tooltip-series-group"), r.style.order = i.config.tooltip.inverseOrder ? t - n : n + 1, e.tConfig.shared && e.tConfig.enabledOnSeries && Array.isArray(e.tConfig.enabledOnSeries) && e.tConfig.enabledOnSeries.indexOf(n) < 0 && r.classList.add("apexcharts-tooltip-series-group-hidden");
                                        var o = document.createElement("span");
                                        o.classList.add("apexcharts-tooltip-marker"), o.style.backgroundColor = i.globals.colors[n], r.appendChild(o);
                                        var l = document.createElement("div");
                                        l.classList.add("apexcharts-tooltip-text"), l.style.fontFamily = e.tConfig.style.fontFamily || i.config.chart.fontFamily, l.style.fontSize = e.tConfig.style.fontSize, ["y", "goals", "z"].forEach((function(t) {
                                            var e = document.createElement("div");
                                            e.classList.add("apexcharts-tooltip-".concat(t, "-group"));
                                            var i = document.createElement("span");
                                            i.classList.add("apexcharts-tooltip-text-".concat(t, "-label")), e.appendChild(i);
                                            var a = document.createElement("span");
                                            a.classList.add("apexcharts-tooltip-text-".concat(t, "-value")), e.appendChild(a), l.appendChild(e)
                                        })), r.appendChild(l), s.appendChild(r), a.push(r)
                                    }, r = 0; r < t; r++) n(r);
                                return a
                            }
                        }, {
                            key: "addSVGEvents",
                            value: function() {
                                var t = this.w,
                                    e = t.config.chart.type,
                                    i = this.getElTooltip(),
                                    a = !("bar" !== e && "candlestick" !== e && "boxPlot" !== e && "rangeBar" !== e),
                                    s = "area" === e || "line" === e || "scatter" === e || "bubble" === e || "radar" === e,
                                    n = t.globals.dom.Paper.node,
                                    r = this.getElGrid();
                                r && (this.seriesBound = r.getBoundingClientRect());
                                var o, l = [],
                                    c = [],
                                    h = {
                                        hoverArea: n,
                                        elGrid: r,
                                        tooltipEl: i,
                                        tooltipY: l,
                                        tooltipX: c,
                                        ttItems: this.ttItems
                                    };
                                if (t.globals.axisCharts && (s ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series[data\\:longestSeries='true'] .apexcharts-marker") : a ? o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-bar-area, .apexcharts-series .apexcharts-candlestick-area, .apexcharts-series .apexcharts-boxPlot-area, .apexcharts-series .apexcharts-rangebar-area") : "heatmap" !== e && "treemap" !== e || (o = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series .apexcharts-heatmap, .apexcharts-series .apexcharts-treemap")), o && o.length))
                                    for (var d = 0; d < o.length; d++) l.push(o[d].getAttribute("cy")), c.push(o[d].getAttribute("cx"));
                                if (t.globals.xyCharts && !this.showOnIntersect || t.globals.comboCharts && !this.showOnIntersect || a && this.tooltipUtil.hasBars() && this.tConfig.shared) this.addPathsEventListeners([n], h);
                                else if (a && !t.globals.comboCharts || s && this.showOnIntersect) this.addDatapointEventsListeners(h);
                                else if (!t.globals.axisCharts || "heatmap" === e || "treemap" === e) {
                                    var u = t.globals.dom.baseEl.querySelectorAll(".apexcharts-series");
                                    this.addPathsEventListeners(u, h)
                                }
                                if (this.showOnIntersect) {
                                    var p = t.globals.dom.baseEl.querySelectorAll(".apexcharts-line-series .apexcharts-marker, .apexcharts-area-series .apexcharts-marker");
                                    p.length > 0 && this.addPathsEventListeners(p, h), this.tooltipUtil.hasBars() && !this.tConfig.shared && this.addDatapointEventsListeners(h)
                                }
                            }
                        }, {
                            key: "drawFixedTooltipRect",
                            value: function() {
                                var t = this.w,
                                    e = this.getElTooltip(),
                                    i = e.getBoundingClientRect(),
                                    a = i.width + 10,
                                    s = i.height + 10,
                                    n = this.tConfig.fixed.offsetX,
                                    r = this.tConfig.fixed.offsetY,
                                    o = this.tConfig.fixed.position.toLowerCase();
                                return o.indexOf("right") > -1 && (n = n + t.globals.svgWidth - a + 10), o.indexOf("bottom") > -1 && (r = r + t.globals.svgHeight - s - 10), e.style.left = n + "px", e.style.top = r + "px", {
                                    x: n,
                                    y: r,
                                    ttWidth: a,
                                    ttHeight: s
                                }
                            }
                        }, {
                            key: "addDatapointEventsListeners",
                            value: function(t) {
                                var e = this.w.globals.dom.baseEl.querySelectorAll(".apexcharts-series-markers .apexcharts-marker, .apexcharts-bar-area, .apexcharts-candlestick-area, .apexcharts-boxPlot-area, .apexcharts-rangebar-area");
                                this.addPathsEventListeners(e, t)
                            }
                        }, {
                            key: "addPathsEventListeners",
                            value: function(t, e) {
                                for (var i = this, a = function(a) {
                                        var s = {
                                            paths: t[a],
                                            tooltipEl: e.tooltipEl,
                                            tooltipY: e.tooltipY,
                                            tooltipX: e.tooltipX,
                                            elGrid: e.elGrid,
                                            hoverArea: e.hoverArea,
                                            ttItems: e.ttItems
                                        };
                                        ["mousemove", "mouseup", "touchmove", "mouseout", "touchend"].map((function(e) {
                                            return t[a].addEventListener(e, i.onSeriesHover.bind(i, s), {
                                                capture: !1,
                                                passive: !0
                                            })
                                        }))
                                    }, s = 0; s < t.length; s++) a(s)
                            }
                        }, {
                            key: "onSeriesHover",
                            value: function(t, e) {
                                var i = this,
                                    a = Date.now() - this.lastHoverTime;
                                a >= 100 ? this.seriesHover(t, e) : (clearTimeout(this.seriesHoverTimeout), this.seriesHoverTimeout = setTimeout((function() {
                                    i.seriesHover(t, e)
                                }), 100 - a))
                            }
                        }, {
                            key: "seriesHover",
                            value: function(t, e) {
                                var i = this;
                                this.lastHoverTime = Date.now();
                                var a = [],
                                    s = this.w;
                                s.config.chart.group && (a = this.ctx.getGroupedCharts()), s.globals.axisCharts && (s.globals.minX === -1 / 0 && s.globals.maxX === 1 / 0 || 0 === s.globals.dataPoints) || (a.length ? a.forEach((function(a) {
                                    var s = i.getElTooltip(a),
                                        n = {
                                            paths: t.paths,
                                            tooltipEl: s,
                                            tooltipY: t.tooltipY,
                                            tooltipX: t.tooltipX,
                                            elGrid: t.elGrid,
                                            hoverArea: t.hoverArea,
                                            ttItems: a.w.globals.tooltip.ttItems
                                        };
                                    a.w.globals.minX === i.w.globals.minX && a.w.globals.maxX === i.w.globals.maxX && a.w.globals.tooltip.seriesHoverByContext({
                                        chartCtx: a,
                                        ttCtx: a.w.globals.tooltip,
                                        opt: n,
                                        e
                                    })
                                })) : this.seriesHoverByContext({
                                    chartCtx: this.ctx,
                                    ttCtx: this.w.globals.tooltip,
                                    opt: t,
                                    e
                                }))
                            }
                        }, {
                            key: "seriesHoverByContext",
                            value: function(t) {
                                var e = t.chartCtx,
                                    i = t.ttCtx,
                                    a = t.opt,
                                    s = t.e,
                                    n = e.w,
                                    r = this.getElTooltip();
                                r && (i.tooltipRect = {
                                    x: 0,
                                    y: 0,
                                    ttWidth: r.getBoundingClientRect().width,
                                    ttHeight: r.getBoundingClientRect().height
                                }, i.e = s, !i.tooltipUtil.hasBars() || n.globals.comboCharts || i.isBarShared || this.tConfig.onDatasetHover.highlightDataSeries && new O(e).toggleSeriesOnHover(s, s.target.parentNode), i.fixedTooltip && i.drawFixedTooltipRect(), n.globals.axisCharts ? i.axisChartsTooltips({
                                    e: s,
                                    opt: a,
                                    tooltipRect: i.tooltipRect
                                }) : i.nonAxisChartsTooltips({
                                    e: s,
                                    opt: a,
                                    tooltipRect: i.tooltipRect
                                }))
                            }
                        }, {
                            key: "axisChartsTooltips",
                            value: function(t) {
                                var e, i, a = t.e,
                                    s = t.opt,
                                    n = this.w,
                                    r = s.elGrid.getBoundingClientRect(),
                                    o = "touchmove" === a.type ? a.touches[0].clientX : a.clientX,
                                    l = "touchmove" === a.type ? a.touches[0].clientY : a.clientY;
                                if (this.clientY = l, this.clientX = o, n.globals.capturedSeriesIndex = -1, n.globals.capturedDataPointIndex = -1, l < r.top || l > r.top + r.height) this.handleMouseOut(s);
                                else {
                                    if (Array.isArray(this.tConfig.enabledOnSeries) && !n.config.tooltip.shared) {
                                        var c = parseInt(s.paths.getAttribute("index"), 10);
                                        if (this.tConfig.enabledOnSeries.indexOf(c) < 0) return void this.handleMouseOut(s)
                                    }
                                    var h = this.getElTooltip(),
                                        d = this.getElXCrosshairs(),
                                        u = n.globals.xyCharts || "bar" === n.config.chart.type && !n.globals.isBarHorizontal && this.tooltipUtil.hasBars() && this.tConfig.shared || n.globals.comboCharts && this.tooltipUtil.hasBars();
                                    if ("mousemove" === a.type || "touchmove" === a.type || "mouseup" === a.type) {
                                        if (n.globals.collapsedSeries.length + n.globals.ancillaryCollapsedSeries.length === n.globals.series.length) return;
                                        null !== d && d.classList.add("apexcharts-active");
                                        var p = this.yaxisTooltips.filter((function(t) {
                                            return !0 === t
                                        }));
                                        if (null !== this.ycrosshairs && p.length && this.ycrosshairs.classList.add("apexcharts-active"), u && !this.showOnIntersect) this.handleStickyTooltip(a, o, l, s);
                                        else if ("heatmap" === n.config.chart.type || "treemap" === n.config.chart.type) {
                                            var g = this.intersect.handleHeatTreeTooltip({
                                                e: a,
                                                opt: s,
                                                x: e,
                                                y: i,
                                                type: n.config.chart.type
                                            });
                                            e = g.x, i = g.y, h.style.left = e + "px", h.style.top = i + "px"
                                        } else this.tooltipUtil.hasBars() && this.intersect.handleBarTooltip({
                                            e: a,
                                            opt: s
                                        }), this.tooltipUtil.hasMarkers() && this.intersect.handleMarkerTooltip({
                                            e: a,
                                            opt: s,
                                            x: e,
                                            y: i
                                        });
                                        if (this.yaxisTooltips.length)
                                            for (var f = 0; f < n.config.yaxis.length; f++) this.axesTooltip.drawYaxisTooltipText(f, l, this.xyRatios);
                                        s.tooltipEl.classList.add("apexcharts-active")
                                    } else "mouseout" !== a.type && "touchend" !== a.type || this.handleMouseOut(s)
                                }
                            }
                        }, {
                            key: "nonAxisChartsTooltips",
                            value: function(t) {
                                var e = t.e,
                                    i = t.opt,
                                    a = t.tooltipRect,
                                    s = this.w,
                                    n = i.paths.getAttribute("rel"),
                                    r = this.getElTooltip(),
                                    o = s.globals.dom.elWrap.getBoundingClientRect();
                                if ("mousemove" === e.type || "touchmove" === e.type) {
                                    r.classList.add("apexcharts-active"), this.tooltipLabels.drawSeriesTexts({
                                        ttItems: i.ttItems,
                                        i: parseInt(n, 10) - 1,
                                        shared: !1
                                    });
                                    var l = s.globals.clientX - o.left - a.ttWidth / 2,
                                        c = s.globals.clientY - o.top - a.ttHeight - 10;
                                    if (r.style.left = l + "px", r.style.top = c + "px", s.config.legend.tooltipHoverFormatter) {
                                        var h = n - 1,
                                            d = (0, s.config.legend.tooltipHoverFormatter)(this.legendLabels[h].getAttribute("data:default-text"), {
                                                seriesIndex: h,
                                                dataPointIndex: h,
                                                w: s
                                            });
                                        this.legendLabels[h].innerHTML = d
                                    }
                                } else "mouseout" !== e.type && "touchend" !== e.type || (r.classList.remove("apexcharts-active"), s.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t) {
                                    var e = t.getAttribute("data:default-text");
                                    t.innerHTML = decodeURIComponent(e)
                                })))
                            }
                        }, {
                            key: "handleStickyTooltip",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = this.tooltipUtil.getNearestValues({
                                        context: this,
                                        hoverArea: a.hoverArea,
                                        elGrid: a.elGrid,
                                        clientX: e,
                                        clientY: i
                                    }),
                                    r = n.j,
                                    o = n.capturedSeries,
                                    l = a.elGrid.getBoundingClientRect();
                                n.hoverX < 0 || n.hoverX > l.width ? this.handleMouseOut(a) : null !== o ? this.handleStickyCapturedSeries(t, o, a, r) : (this.tooltipUtil.isXoverlap(r) || s.globals.isBarHorizontal) && this.create(t, this, 0, r, a.ttItems)
                            }
                        }, {
                            key: "handleStickyCapturedSeries",
                            value: function(t, e, i, a) {
                                var s = this.w;
                                this.tConfig.shared || null !== s.globals.series[e][a] ? void 0 !== s.globals.series[e][a] ? this.tConfig.shared && this.tooltipUtil.isXoverlap(a) && this.tooltipUtil.isInitialSeriesSameLen() ? this.create(t, this, e, a, i.ttItems) : this.create(t, this, e, a, i.ttItems, !1) : this.tooltipUtil.isXoverlap(a) && this.create(t, this, 0, a, i.ttItems) : this.handleMouseOut(i)
                            }
                        }, {
                            key: "deactivateHoverFilter",
                            value: function() {
                                for (var t = this.w, e = new S(this.ctx), i = t.globals.dom.Paper.select(".apexcharts-bar-area"), a = 0; a < i.length; a++) e.pathMouseLeave(i[a])
                            }
                        }, {
                            key: "handleMouseOut",
                            value: function(t) {
                                var e = this.w,
                                    i = this.getElXCrosshairs();
                                if (t.tooltipEl.classList.remove("apexcharts-active"), this.deactivateHoverFilter(), "bubble" !== e.config.chart.type && this.marker.resetPointsSize(), null !== i && i.classList.remove("apexcharts-active"), null !== this.ycrosshairs && this.ycrosshairs.classList.remove("apexcharts-active"), this.isXAxisTooltipEnabled && this.xaxisTooltip.classList.remove("apexcharts-active"), this.yaxisTooltips.length) {
                                    null === this.yaxisTTEls && (this.yaxisTTEls = e.globals.dom.baseEl.querySelectorAll(".apexcharts-yaxistooltip"));
                                    for (var a = 0; a < this.yaxisTTEls.length; a++) this.yaxisTTEls[a].classList.remove("apexcharts-active")
                                }
                                e.config.legend.tooltipHoverFormatter && this.legendLabels.forEach((function(t) {
                                    var e = t.getAttribute("data:default-text");
                                    t.innerHTML = decodeURIComponent(e)
                                }))
                            }
                        }, {
                            key: "markerClick",
                            value: function(t, e, i) {
                                var a = this.w;
                                "function" == typeof a.config.chart.events.markerClick && a.config.chart.events.markerClick(t, this.ctx, {
                                    seriesIndex: e,
                                    dataPointIndex: i,
                                    w: a
                                }), this.ctx.events.fireEvent("markerClick", [t, this.ctx, {
                                    seriesIndex: e,
                                    dataPointIndex: i,
                                    w: a
                                }])
                            }
                        }, {
                            key: "create",
                            value: function(t, e, i, a, s) {
                                var n = arguments.length > 5 && void 0 !== arguments[5] ? arguments[5] : null,
                                    r = this.w,
                                    o = e;
                                "mouseup" === t.type && this.markerClick(t, i, a), null === n && (n = this.tConfig.shared);
                                var l = this.tooltipUtil.hasMarkers(),
                                    c = this.tooltipUtil.getElBars();
                                if (r.config.legend.tooltipHoverFormatter) {
                                    var h = r.config.legend.tooltipHoverFormatter,
                                        d = Array.from(this.legendLabels);
                                    d.forEach((function(t) {
                                        var e = t.getAttribute("data:default-text");
                                        t.innerHTML = decodeURIComponent(e)
                                    }));
                                    for (var u = 0; u < d.length; u++) {
                                        var p = d[u],
                                            g = parseInt(p.getAttribute("i"), 10),
                                            f = decodeURIComponent(p.getAttribute("data:default-text")),
                                            m = h(f, {
                                                seriesIndex: n ? g : i,
                                                dataPointIndex: a,
                                                w: r
                                            });
                                        if (n) p.innerHTML = r.globals.collapsedSeriesIndices.indexOf(g) < 0 ? m : f;
                                        else if (p.innerHTML = g === i ? m : f, i === g) break
                                    }
                                }
                                if (n) {
                                    if (o.tooltipLabels.drawSeriesTexts({
                                            ttItems: s,
                                            i,
                                            j: a,
                                            shared: !this.showOnIntersect && this.tConfig.shared
                                        }), l && (r.globals.markers.largestSize > 0 ? o.marker.enlargePoints(a) : o.tooltipPosition.moveDynamicPointsOnHover(a)), this.tooltipUtil.hasBars() && (this.barSeriesHeight = this.tooltipUtil.getBarsHeight(c), this.barSeriesHeight > 0)) {
                                        var x = new S(this.ctx),
                                            v = r.globals.dom.Paper.select(".apexcharts-bar-area[j='".concat(a, "']"));
                                        this.deactivateHoverFilter(), this.tooltipPosition.moveStickyTooltipOverBars(a);
                                        for (var b = 0; b < v.length; b++) x.pathMouseEnter(v[b])
                                    }
                                } else o.tooltipLabels.drawSeriesTexts({
                                    shared: !1,
                                    ttItems: s,
                                    i,
                                    j: a
                                }), this.tooltipUtil.hasBars() && o.tooltipPosition.moveStickyTooltipOverBars(a), l && o.tooltipPosition.moveMarkers(i, a)
                            }
                        }]), t
                    }(),
                    Ct = function(t) {
                        d(i, Y);
                        var e = f(i);

                        function i() {
                            return o(this, i), e.apply(this, arguments)
                        }
                        return c(i, [{
                            key: "draw",
                            value: function(t, e) {
                                var i = this,
                                    a = this.w;
                                this.graphics = new S(this.ctx), this.bar = new Y(this.ctx, this.xyRatios);
                                var s = new C(this.ctx, a);
                                t = s.getLogSeries(t), this.yRatio = s.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t), "100%" === a.config.chart.stackType && (t = a.globals.seriesPercent.slice()), this.series = t, this.totalItems = 0, this.prevY = [], this.prevX = [], this.prevYF = [], this.prevXF = [], this.prevYVal = [], this.prevXVal = [], this.xArrj = [], this.xArrjF = [], this.xArrjVal = [], this.yArrj = [], this.yArrjF = [], this.yArrjVal = [];
                                for (var r = 0; r < t.length; r++) t[r].length > 0 && (this.totalItems += t[r].length);
                                for (var o = this.graphics.group({
                                        class: "apexcharts-bar-series apexcharts-plot-series"
                                    }), l = 0, c = 0, h = function(s, r) {
                                        var h = void 0,
                                            d = void 0,
                                            u = void 0,
                                            p = void 0,
                                            g = [],
                                            f = [],
                                            m = a.globals.comboCharts ? e[s] : s;
                                        i.yRatio.length > 1 && (i.yaxisIndex = m), i.isReversed = a.config.yaxis[i.yaxisIndex] && a.config.yaxis[i.yaxisIndex].reversed;
                                        var x = i.graphics.group({
                                            class: "apexcharts-series",
                                            seriesName: b.escapeString(a.globals.seriesNames[m]),
                                            rel: s + 1,
                                            "data:realIndex": m
                                        });
                                        i.ctx.series.addCollapsedClassToSeries(x, m);
                                        var v = i.graphics.group({
                                                class: "apexcharts-datalabels",
                                                "data:realIndex": m
                                            }),
                                            y = 0,
                                            w = 0,
                                            S = i.initialPositions(l, c, h, d, u, p);
                                        c = S.y, y = S.barHeight, d = S.yDivision, p = S.zeroW, l = S.x, w = S.barWidth, h = S.xDivision, u = S.zeroH, i.yArrj = [], i.yArrjF = [], i.yArrjVal = [], i.xArrj = [], i.xArrjF = [], i.xArrjVal = [], 1 === i.prevY.length && i.prevY[0].every((function(t) {
                                            return isNaN(t)
                                        })) && (i.prevY[0] = i.prevY[0].map((function(t) {
                                            return u
                                        })), i.prevYF[0] = i.prevYF[0].map((function(t) {
                                            return 0
                                        })));
                                        for (var C = 0; C < a.globals.dataPoints; C++) {
                                            var k = i.barHelpers.getStrokeWidth(s, C, m),
                                                A = {
                                                    indexes: {
                                                        i: s,
                                                        j: C,
                                                        realIndex: m,
                                                        bc: r
                                                    },
                                                    strokeWidth: k,
                                                    x: l,
                                                    y: c,
                                                    elSeries: x
                                                },
                                                E = null;
                                            i.isHorizontal ? (E = i.drawStackedBarPaths(n(n({}, A), {}, {
                                                zeroW: p,
                                                barHeight: y,
                                                yDivision: d
                                            })), w = i.series[s][C] / i.invertedYRatio) : (E = i.drawStackedColumnPaths(n(n({}, A), {}, {
                                                xDivision: h,
                                                barWidth: w,
                                                zeroH: u
                                            })), y = i.series[s][C] / i.yRatio[i.yaxisIndex]), c = E.y, l = E.x, g.push(l), f.push(c);
                                            var T = i.barHelpers.getPathFillColor(t, s, C, m);
                                            x = i.renderSeries({
                                                realIndex: m,
                                                pathFill: T,
                                                j: C,
                                                i: s,
                                                pathFrom: E.pathFrom,
                                                pathTo: E.pathTo,
                                                strokeWidth: k,
                                                elSeries: x,
                                                x: l,
                                                y: c,
                                                series: t,
                                                barHeight: y,
                                                barWidth: w,
                                                elDataLabelsWrap: v,
                                                type: "bar",
                                                visibleSeries: 0
                                            })
                                        }
                                        a.globals.seriesXvalues[m] = g, a.globals.seriesYvalues[m] = f, i.prevY.push(i.yArrj), i.prevYF.push(i.yArrjF), i.prevYVal.push(i.yArrjVal), i.prevX.push(i.xArrj), i.prevXF.push(i.xArrjF), i.prevXVal.push(i.xArrjVal), o.add(x)
                                    }, d = 0, u = 0; d < t.length; d++, u++) h(d, u);
                                return o
                            }
                        }, {
                            key: "initialPositions",
                            value: function(t, e, i, a, s, n) {
                                var r, o, l = this.w;
                                return this.isHorizontal ? (r = (r = a = l.globals.gridHeight / l.globals.dataPoints) * parseInt(l.config.plotOptions.bar.barHeight, 10) / 100, n = this.baseLineInvertedY + l.globals.padHorizontal + (this.isReversed ? l.globals.gridWidth : 0) - (this.isReversed ? 2 * this.baseLineInvertedY : 0), e = (a - r) / 2) : (o = i = l.globals.gridWidth / l.globals.dataPoints, o = l.globals.isXNumeric && l.globals.dataPoints > 1 ? (i = l.globals.minXDiff / this.xRatio) * parseInt(this.barOptions.columnWidth, 10) / 100 : o * parseInt(l.config.plotOptions.bar.columnWidth, 10) / 100, s = this.baseLineY[this.yaxisIndex] + (this.isReversed ? l.globals.gridHeight : 0) - (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), t = l.globals.padHorizontal + (i - o) / 2), {
                                    x: t,
                                    y: e,
                                    yDivision: a,
                                    xDivision: i,
                                    barHeight: r,
                                    barWidth: o,
                                    zeroH: s,
                                    zeroW: n
                                }
                            }
                        }, {
                            key: "drawStackedBarPaths",
                            value: function(t) {
                                for (var e, i = t.indexes, a = t.barHeight, s = t.strokeWidth, n = t.zeroW, r = t.x, o = t.y, l = t.yDivision, c = t.elSeries, h = this.w, d = o, u = i.i, p = i.j, g = 0, f = 0; f < this.prevXF.length; f++) g += this.prevXF[f][p];
                                if (u > 0) {
                                    var m = n;
                                    this.prevXVal[u - 1][p] < 0 ? m = this.series[u][p] >= 0 ? this.prevX[u - 1][p] + g - 2 * (this.isReversed ? g : 0) : this.prevX[u - 1][p] : this.prevXVal[u - 1][p] >= 0 && (m = this.series[u][p] >= 0 ? this.prevX[u - 1][p] : this.prevX[u - 1][p] - g + 2 * (this.isReversed ? g : 0)), e = m
                                } else e = n;
                                r = null === this.series[u][p] ? e : e + this.series[u][p] / this.invertedYRatio - 2 * (this.isReversed ? this.series[u][p] / this.invertedYRatio : 0);
                                var x = this.barHelpers.getBarpaths({
                                    barYPosition: d,
                                    barHeight: a,
                                    x1: e,
                                    x2: r,
                                    strokeWidth: s,
                                    series: this.series,
                                    realIndex: i.realIndex,
                                    i: u,
                                    j: p,
                                    w: h
                                });
                                return this.barHelpers.barBackground({
                                    j: p,
                                    i: u,
                                    y1: d,
                                    y2: a,
                                    elSeries: c
                                }), o += l, {
                                    pathTo: x.pathTo,
                                    pathFrom: x.pathFrom,
                                    x: r,
                                    y: o
                                }
                            }
                        }, {
                            key: "drawStackedColumnPaths",
                            value: function(t) {
                                var e = t.indexes,
                                    i = t.x,
                                    a = t.y,
                                    s = t.xDivision,
                                    n = t.barWidth,
                                    r = t.zeroH;
                                t.strokeWidth;
                                var o = t.elSeries,
                                    l = this.w,
                                    c = e.i,
                                    h = e.j,
                                    d = e.bc;
                                if (l.globals.isXNumeric) {
                                    var u = l.globals.seriesX[c][h];
                                    u || (u = 0), i = (u - l.globals.minX) / this.xRatio - n / 2
                                }
                                for (var p, g = i, f = 0, m = 0; m < this.prevYF.length; m++) f += isNaN(this.prevYF[m][h]) ? 0 : this.prevYF[m][h];
                                if (c > 0 && !l.globals.isXNumeric || c > 0 && l.globals.isXNumeric && l.globals.seriesX[c - 1][h] === l.globals.seriesX[c][h]) {
                                    var x, v, b = Math.min(this.yRatio.length + 1, c + 1);
                                    if (void 0 !== this.prevY[c - 1])
                                        for (var y = 1; y < b; y++)
                                            if (!isNaN(this.prevY[c - y][h])) {
                                                v = this.prevY[c - y][h];
                                                break
                                            }
                                    for (var w = 1; w < b; w++) {
                                        if (this.prevYVal[c - w][h] < 0) {
                                            x = this.series[c][h] >= 0 ? v - f + 2 * (this.isReversed ? f : 0) : v;
                                            break
                                        }
                                        if (this.prevYVal[c - w][h] >= 0) {
                                            x = this.series[c][h] >= 0 ? v : v + f - 2 * (this.isReversed ? f : 0);
                                            break
                                        }
                                    }
                                    void 0 === x && (x = l.globals.gridHeight), p = this.prevYF[0].every((function(t) {
                                        return 0 === t
                                    })) && this.prevYF.slice(1, c).every((function(t) {
                                        return t.every((function(t) {
                                            return isNaN(t)
                                        }))
                                    })) ? l.globals.gridHeight - r : x
                                } else p = l.globals.gridHeight - r;
                                a = p - this.series[c][h] / this.yRatio[this.yaxisIndex] + 2 * (this.isReversed ? this.series[c][h] / this.yRatio[this.yaxisIndex] : 0);
                                var S = this.barHelpers.getColumnPaths({
                                    barXPosition: g,
                                    barWidth: n,
                                    y1: p,
                                    y2: a,
                                    yRatio: this.yRatio[this.yaxisIndex],
                                    strokeWidth: this.strokeWidth,
                                    series: this.series,
                                    realIndex: e.realIndex,
                                    i: c,
                                    j: h,
                                    w: l
                                });
                                return this.barHelpers.barBackground({
                                    bc: d,
                                    j: h,
                                    i: c,
                                    x1: g,
                                    x2: n,
                                    elSeries: o
                                }), i += s, {
                                    pathTo: S.pathTo,
                                    pathFrom: S.pathFrom,
                                    x: l.globals.isXNumeric ? i - s : i,
                                    y: a
                                }
                            }
                        }]), i
                    }(),
                    kt = function(t) {
                        d(i, Y);
                        var e = f(i);

                        function i() {
                            return o(this, i), e.apply(this, arguments)
                        }
                        return c(i, [{
                            key: "draw",
                            value: function(t, e) {
                                var i = this,
                                    a = this.w,
                                    s = new S(this.ctx),
                                    r = new I(this.ctx);
                                this.candlestickOptions = this.w.config.plotOptions.candlestick, this.boxOptions = this.w.config.plotOptions.boxPlot, this.isHorizontal = a.config.plotOptions.bar.horizontal;
                                var o = new C(this.ctx, a);
                                t = o.getLogSeries(t), this.series = t, this.yRatio = o.getLogYRatios(this.yRatio), this.barHelpers.initVariables(t);
                                for (var l = s.group({
                                        class: "apexcharts-".concat(a.config.chart.type, "-series apexcharts-plot-series")
                                    }), c = function(o) {
                                        i.isBoxPlot = "boxPlot" === a.config.chart.type || "boxPlot" === a.config.series[o].type;
                                        var c, h, d, u, p, g, f = void 0,
                                            m = void 0,
                                            x = [],
                                            v = [],
                                            y = a.globals.comboCharts ? e[o] : o,
                                            w = s.group({
                                                class: "apexcharts-series",
                                                seriesName: b.escapeString(a.globals.seriesNames[y]),
                                                rel: o + 1,
                                                "data:realIndex": y
                                            });
                                        i.ctx.series.addCollapsedClassToSeries(w, y), t[o].length > 0 && (i.visibleI = i.visibleI + 1), i.yRatio.length > 1 && (i.yaxisIndex = y);
                                        var S = i.barHelpers.initialPositions();
                                        m = S.y, p = S.barHeight, h = S.yDivision, u = S.zeroW, f = S.x, g = S.barWidth, c = S.xDivision, d = S.zeroH, v.push(f + g / 2);
                                        for (var C = s.group({
                                                class: "apexcharts-datalabels",
                                                "data:realIndex": y
                                            }), k = function(e) {
                                                var s = i.barHelpers.getStrokeWidth(o, e, y),
                                                    l = null,
                                                    b = {
                                                        indexes: {
                                                            i: o,
                                                            j: e,
                                                            realIndex: y
                                                        },
                                                        x: f,
                                                        y: m,
                                                        strokeWidth: s,
                                                        elSeries: w
                                                    };
                                                l = i.isHorizontal ? i.drawHorizontalBoxPaths(n(n({}, b), {}, {
                                                    yDivision: h,
                                                    barHeight: p,
                                                    zeroW: u
                                                })) : i.drawVerticalBoxPaths(n(n({}, b), {}, {
                                                    xDivision: c,
                                                    barWidth: g,
                                                    zeroH: d
                                                })), m = l.y, f = l.x, e > 0 && v.push(f + g / 2), x.push(m), l.pathTo.forEach((function(n, c) {
                                                    var h = !i.isBoxPlot && i.candlestickOptions.wick.useFillColor ? l.color[c] : a.globals.stroke.colors[o],
                                                        d = r.fillPath({
                                                            seriesNumber: y,
                                                            dataPointIndex: e,
                                                            color: l.color[c],
                                                            value: t[o][e]
                                                        });
                                                    i.renderSeries({
                                                        realIndex: y,
                                                        pathFill: d,
                                                        lineFill: h,
                                                        j: e,
                                                        i: o,
                                                        pathFrom: l.pathFrom,
                                                        pathTo: n,
                                                        strokeWidth: s,
                                                        elSeries: w,
                                                        x: f,
                                                        y: m,
                                                        series: t,
                                                        barHeight: p,
                                                        barWidth: g,
                                                        elDataLabelsWrap: C,
                                                        visibleSeries: i.visibleI,
                                                        type: a.config.chart.type
                                                    })
                                                }))
                                            }, A = 0; A < a.globals.dataPoints; A++) k(A);
                                        a.globals.seriesXvalues[y] = v, a.globals.seriesYvalues[y] = x, l.add(w)
                                    }, h = 0; h < t.length; h++) c(h);
                                return l
                            }
                        }, {
                            key: "drawVerticalBoxPaths",
                            value: function(t) {
                                var e = t.indexes,
                                    i = t.x;
                                t.y;
                                var a = t.xDivision,
                                    s = t.barWidth,
                                    n = t.zeroH,
                                    r = t.strokeWidth,
                                    o = this.w,
                                    l = new S(this.ctx),
                                    c = e.i,
                                    h = e.j,
                                    d = !0,
                                    u = o.config.plotOptions.candlestick.colors.upward,
                                    p = o.config.plotOptions.candlestick.colors.downward,
                                    g = "";
                                this.isBoxPlot && (g = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                                var f = this.yRatio[this.yaxisIndex],
                                    m = e.realIndex,
                                    x = this.getOHLCValue(m, h),
                                    v = n,
                                    b = n;
                                x.o > x.c && (d = !1);
                                var y = Math.min(x.o, x.c),
                                    w = Math.max(x.o, x.c),
                                    C = x.m;
                                o.globals.isXNumeric && (i = (o.globals.seriesX[m][h] - o.globals.minX) / this.xRatio - s / 2);
                                var k = i + s * this.visibleI;
                                void 0 === this.series[c][h] || null === this.series[c][h] ? (y = n, w = n) : (y = n - y / f, w = n - w / f, v = n - x.h / f, b = n - x.l / f, C = n - x.m / f);
                                var A = l.move(k, n),
                                    E = l.move(k + s / 2, y);
                                return o.globals.previousPaths.length > 0 && (E = this.getPreviousPath(m, h, !0)), A = this.isBoxPlot ? [l.move(k, y) + l.line(k + s / 2, y) + l.line(k + s / 2, v) + l.line(k + s / 4, v) + l.line(k + s - s / 4, v) + l.line(k + s / 2, v) + l.line(k + s / 2, y) + l.line(k + s, y) + l.line(k + s, C) + l.line(k, C) + l.line(k, y + r / 2), l.move(k, C) + l.line(k + s, C) + l.line(k + s, w) + l.line(k + s / 2, w) + l.line(k + s / 2, b) + l.line(k + s - s / 4, b) + l.line(k + s / 4, b) + l.line(k + s / 2, b) + l.line(k + s / 2, w) + l.line(k, w) + l.line(k, C) + "z"] : [l.move(k, w) + l.line(k + s / 2, w) + l.line(k + s / 2, v) + l.line(k + s / 2, w) + l.line(k + s, w) + l.line(k + s, y) + l.line(k + s / 2, y) + l.line(k + s / 2, b) + l.line(k + s / 2, y) + l.line(k, y) + l.line(k, w - r / 2)], E += l.move(k, y), o.globals.isXNumeric || (i += a), {
                                    pathTo: A,
                                    pathFrom: E,
                                    x: i,
                                    y: w,
                                    barXPosition: k,
                                    color: this.isBoxPlot ? g : d ? [u] : [p]
                                }
                            }
                        }, {
                            key: "drawHorizontalBoxPaths",
                            value: function(t) {
                                var e = t.indexes;
                                t.x;
                                var i = t.y,
                                    a = t.yDivision,
                                    s = t.barHeight,
                                    n = t.zeroW,
                                    r = t.strokeWidth,
                                    o = this.w,
                                    l = new S(this.ctx),
                                    c = e.i,
                                    h = e.j,
                                    d = this.boxOptions.colors.lower;
                                this.isBoxPlot && (d = [this.boxOptions.colors.lower, this.boxOptions.colors.upper]);
                                var u = this.invertedYRatio,
                                    p = e.realIndex,
                                    g = this.getOHLCValue(p, h),
                                    f = n,
                                    m = n,
                                    x = Math.min(g.o, g.c),
                                    v = Math.max(g.o, g.c),
                                    b = g.m;
                                o.globals.isXNumeric && (i = (o.globals.seriesX[p][h] - o.globals.minX) / this.invertedXRatio - s / 2);
                                var y = i + s * this.visibleI;
                                void 0 === this.series[c][h] || null === this.series[c][h] ? (x = n, v = n) : (x = n + x / u, v = n + v / u, f = n + g.h / u, m = n + g.l / u, b = n + g.m / u);
                                var w = l.move(n, y),
                                    C = l.move(x, y + s / 2);
                                return o.globals.previousPaths.length > 0 && (C = this.getPreviousPath(p, h, !0)), w = [l.move(x, y) + l.line(x, y + s / 2) + l.line(f, y + s / 2) + l.line(f, y + s / 2 - s / 4) + l.line(f, y + s / 2 + s / 4) + l.line(f, y + s / 2) + l.line(x, y + s / 2) + l.line(x, y + s) + l.line(b, y + s) + l.line(b, y) + l.line(x + r / 2, y), l.move(b, y) + l.line(b, y + s) + l.line(v, y + s) + l.line(v, y + s / 2) + l.line(m, y + s / 2) + l.line(m, y + s - s / 4) + l.line(m, y + s / 4) + l.line(m, y + s / 2) + l.line(v, y + s / 2) + l.line(v, y) + l.line(b, y) + "z"], C += l.move(x, y), o.globals.isXNumeric || (i += a), {
                                    pathTo: w,
                                    pathFrom: C,
                                    x: v,
                                    y: i,
                                    barYPosition: y,
                                    color: d
                                }
                            }
                        }, {
                            key: "getOHLCValue",
                            value: function(t, e) {
                                var i = this.w;
                                return {
                                    o: this.isBoxPlot ? i.globals.seriesCandleH[t][e] : i.globals.seriesCandleO[t][e],
                                    h: this.isBoxPlot ? i.globals.seriesCandleO[t][e] : i.globals.seriesCandleH[t][e],
                                    m: i.globals.seriesCandleM[t][e],
                                    l: this.isBoxPlot ? i.globals.seriesCandleC[t][e] : i.globals.seriesCandleL[t][e],
                                    c: this.isBoxPlot ? i.globals.seriesCandleL[t][e] : i.globals.seriesCandleC[t][e]
                                }
                            }
                        }]), i
                    }(),
                    At = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "checkColorRange",
                            value: function() {
                                var t = this.w,
                                    e = !1,
                                    i = t.config.plotOptions[t.config.chart.type];
                                return i.colorScale.ranges.length > 0 && i.colorScale.ranges.map((function(t, i) {
                                    t.from <= 0 && (e = !0)
                                })), e
                            }
                        }, {
                            key: "getShadeColor",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = 1,
                                    r = s.config.plotOptions[t].shadeIntensity,
                                    o = this.determineColor(t, e, i);
                                s.globals.hasNegs || a ? n = s.config.plotOptions[t].reverseNegativeShade ? o.percent < 0 ? o.percent / 100 * (1.25 * r) : (1 - o.percent / 100) * (1.25 * r) : o.percent <= 0 ? 1 - (1 + o.percent / 100) * r : (1 - o.percent / 100) * r : (n = 1 - o.percent / 100, "treemap" === t && (n = (1 - o.percent / 100) * (1.25 * r)));
                                var l = o.color,
                                    c = new b;
                                return s.config.plotOptions[t].enableShades && (l = "dark" === this.w.config.theme.mode ? b.hexToRgba(c.shadeColor(-1 * n, o.color), s.config.fill.opacity) : b.hexToRgba(c.shadeColor(n, o.color), s.config.fill.opacity)), {
                                    color: l,
                                    colorProps: o
                                }
                            }
                        }, {
                            key: "determineColor",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = a.globals.series[e][i],
                                    n = a.config.plotOptions[t],
                                    r = n.colorScale.inverse ? i : e;
                                n.distributed && "treemap" === a.config.chart.type && (r = i);
                                var o = a.globals.colors[r],
                                    l = null,
                                    c = Math.min.apply(Math, m(a.globals.series[e])),
                                    h = Math.max.apply(Math, m(a.globals.series[e]));
                                n.distributed || "heatmap" !== t || (c = a.globals.minY, h = a.globals.maxY), void 0 !== n.colorScale.min && (c = n.colorScale.min < a.globals.minY ? n.colorScale.min : a.globals.minY, h = n.colorScale.max > a.globals.maxY ? n.colorScale.max : a.globals.maxY);
                                var d = Math.abs(h) + Math.abs(c),
                                    u = 100 * s / (0 === d ? d - 1e-6 : d);
                                return n.colorScale.ranges.length > 0 && n.colorScale.ranges.map((function(t, e) {
                                    if (s >= t.from && s <= t.to) {
                                        o = t.color, l = t.foreColor ? t.foreColor : null, c = t.from, h = t.to;
                                        var i = Math.abs(h) + Math.abs(c);
                                        u = 100 * s / (0 === i ? i - 1e-6 : i)
                                    }
                                })), {
                                    color: o,
                                    foreColor: l,
                                    percent: u
                                }
                            }
                        }, {
                            key: "calculateDataLabels",
                            value: function(t) {
                                var e = t.text,
                                    i = t.x,
                                    a = t.y,
                                    s = t.i,
                                    n = t.j,
                                    r = t.colorProps,
                                    o = t.fontSize,
                                    l = this.w.config.dataLabels,
                                    c = new S(this.ctx),
                                    h = new D(this.ctx),
                                    d = null;
                                if (l.enabled) {
                                    d = c.group({
                                        class: "apexcharts-data-labels"
                                    });
                                    var u = l.offsetX,
                                        p = l.offsetY,
                                        g = i + u,
                                        f = a + parseFloat(l.style.fontSize) / 3 + p;
                                    h.plotDataLabelsText({
                                        x: g,
                                        y: f,
                                        text: e,
                                        i: s,
                                        j: n,
                                        color: r.foreColor,
                                        parent: d,
                                        fontSize: o,
                                        dataLabelsConfig: l
                                    })
                                }
                                return d
                            }
                        }, {
                            key: "addListeners",
                            value: function(t) {
                                var e = new S(this.ctx);
                                t.node.addEventListener("mouseenter", e.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", e.pathMouseLeave.bind(this, t)), t.node.addEventListener("mousedown", e.pathMouseDown.bind(this, t))
                            }
                        }]), t
                    }(),
                    Et = function() {
                        function t(e, i) {
                            o(this, t), this.ctx = e, this.w = e.w, this.xRatio = i.xRatio, this.yRatio = i.yRatio, this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.helpers = new At(e), this.rectRadius = this.w.config.plotOptions.heatmap.radius, this.strokeWidth = this.w.config.stroke.show ? this.w.config.stroke.width : 0
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = i.group({
                                        class: "apexcharts-heatmap"
                                    });
                                a.attr("clip-path", "url(#gridRectMask".concat(e.globals.cuid, ")"));
                                var s = e.globals.gridWidth / e.globals.dataPoints,
                                    n = e.globals.gridHeight / e.globals.series.length,
                                    r = 0,
                                    o = !1;
                                this.negRange = this.helpers.checkColorRange();
                                var l = t.slice();
                                e.config.yaxis[0].reversed && (o = !0, l.reverse());
                                for (var c = o ? 0 : l.length - 1; o ? c < l.length : c >= 0; o ? c++ : c--) {
                                    var h = i.group({
                                        class: "apexcharts-series apexcharts-heatmap-series",
                                        seriesName: b.escapeString(e.globals.seriesNames[c]),
                                        rel: c + 1,
                                        "data:realIndex": c
                                    });
                                    if (this.ctx.series.addCollapsedClassToSeries(h, c), e.config.chart.dropShadow.enabled) {
                                        var d = e.config.chart.dropShadow;
                                        new w(this.ctx).dropShadow(h, d, c)
                                    }
                                    for (var u = 0, p = e.config.plotOptions.heatmap.shadeIntensity, g = 0; g < l[c].length; g++) {
                                        var f = this.helpers.getShadeColor(e.config.chart.type, c, g, this.negRange),
                                            m = f.color,
                                            x = f.colorProps;
                                        "image" === e.config.fill.type && (m = new I(this.ctx).fillPath({
                                            seriesNumber: c,
                                            dataPointIndex: g,
                                            opacity: e.globals.hasNegs ? x.percent < 0 ? 1 - (1 + x.percent / 100) : p + x.percent / 100 : x.percent / 100,
                                            patternID: b.randomId(),
                                            width: e.config.fill.image.width ? e.config.fill.image.width : s,
                                            height: e.config.fill.image.height ? e.config.fill.image.height : n
                                        }));
                                        var v = this.rectRadius,
                                            y = i.drawRect(u, r, s, n, v);
                                        if (y.attr({
                                                cx: u,
                                                cy: r
                                            }), y.node.classList.add("apexcharts-heatmap-rect"), h.add(y), y.attr({
                                                fill: m,
                                                i: c,
                                                index: c,
                                                j: g,
                                                val: l[c][g],
                                                "stroke-width": this.strokeWidth,
                                                stroke: e.config.plotOptions.heatmap.useFillColorAsStroke ? m : e.globals.stroke.colors[0],
                                                color: m
                                            }), this.helpers.addListeners(y), e.config.chart.animations.enabled && !e.globals.dataChanged) {
                                            var C = 1;
                                            e.globals.resized || (C = e.config.chart.animations.speed), this.animateHeatMap(y, u, r, s, n, C)
                                        }
                                        if (e.globals.dataChanged) {
                                            var k = 1;
                                            if (this.dynamicAnim.enabled && e.globals.shouldAnimate) {
                                                k = this.dynamicAnim.speed;
                                                var A = e.globals.previousPaths[c] && e.globals.previousPaths[c][g] && e.globals.previousPaths[c][g].color;
                                                A || (A = "rgba(255, 255, 255, 0)"), this.animateHeatColor(y, b.isColorHex(A) ? A : b.rgb2hex(A), b.isColorHex(m) ? m : b.rgb2hex(m), k)
                                            }
                                        }
                                        var E = (0, e.config.dataLabels.formatter)(e.globals.series[c][g], {
                                                value: e.globals.series[c][g],
                                                seriesIndex: c,
                                                dataPointIndex: g,
                                                w: e
                                            }),
                                            T = this.helpers.calculateDataLabels({
                                                text: E,
                                                x: u + s / 2,
                                                y: r + n / 2,
                                                i: c,
                                                j: g,
                                                colorProps: x,
                                                series: l
                                            });
                                        null !== T && h.add(T), u += s
                                    }
                                    r += n, a.add(h)
                                }
                                var P = e.globals.yAxisScale[0].result.slice();
                                e.config.yaxis[0].reversed ? P.unshift("") : P.push(""), e.globals.yAxisScale[0].result = P;
                                var M = e.globals.gridHeight / e.globals.series.length;
                                return e.config.yaxis[0].labels.offsetY = -M / 2, a
                            }
                        }, {
                            key: "animateHeatMap",
                            value: function(t, e, i, a, s, n) {
                                var r = new y(this.ctx);
                                r.animateRect(t, {
                                    x: e + a / 2,
                                    y: i + s / 2,
                                    width: 0,
                                    height: 0
                                }, {
                                    x: e,
                                    y: i,
                                    width: a,
                                    height: s
                                }, n, (function() {
                                    r.animationCompleted(t)
                                }))
                            }
                        }, {
                            key: "animateHeatColor",
                            value: function(t, e, i, a) {
                                t.attr({
                                    fill: e
                                }).animate(a).attr({
                                    fill: i
                                })
                            }
                        }]), t
                    }(),
                    Tt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "drawYAxisTexts",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = s.config.yaxis[0],
                                    r = s.globals.yLabelFormatters[0];
                                return new S(this.ctx).drawText({
                                    x: t + n.labels.offsetX,
                                    y: e + n.labels.offsetY,
                                    text: r(a, i),
                                    textAnchor: "middle",
                                    fontSize: n.labels.style.fontSize,
                                    fontFamily: n.labels.style.fontFamily,
                                    foreColor: Array.isArray(n.labels.style.colors) ? n.labels.style.colors[i] : n.labels.style.colors
                                })
                            }
                        }]), t
                    }(),
                    Pt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w;
                            var i = this.w;
                            this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animBeginArr = [0], this.animDur = 0, this.donutDataLabels = this.w.config.plotOptions.pie.donut.labels, this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = Math.min(i.globals.gridWidth, i.globals.gridHeight), this.centerY = this.defaultSize / 2, this.centerX = i.globals.gridWidth / 2, "radialBar" === i.config.chart.type ? this.fullAngle = 360 : this.fullAngle = Math.abs(i.config.plotOptions.pie.endAngle - i.config.plotOptions.pie.startAngle), this.initialAngle = i.config.plotOptions.pie.startAngle % this.fullAngle, i.globals.radialSize = this.defaultSize / 2.05 - i.config.stroke.width - (i.config.chart.sparkline.enabled ? 0 : i.config.chart.dropShadow.blur), this.donutSize = i.globals.radialSize * parseInt(i.config.plotOptions.pie.donut.size, 10) / 100, this.maxY = 0, this.sliceLabels = [], this.sliceSizes = [], this.prevSectorAngleArr = []
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = new S(this.ctx);
                                if (this.ret = a.group({
                                        class: "apexcharts-pie"
                                    }), i.globals.noData) return this.ret;
                                for (var s = 0, n = 0; n < t.length; n++) s += b.negToZero(t[n]);
                                var r = [],
                                    o = a.group();
                                0 === s && (s = 1e-5), t.forEach((function(t) {
                                    e.maxY = Math.max(e.maxY, t)
                                })), i.config.yaxis[0].max && (this.maxY = i.config.yaxis[0].max), "back" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret);
                                for (var l = 0; l < t.length; l++) {
                                    var c = this.fullAngle * b.negToZero(t[l]) / s;
                                    r.push(c), "polarArea" === this.chartType ? (r[l] = this.fullAngle / t.length, this.sliceSizes.push(i.globals.radialSize * t[l] / this.maxY)) : this.sliceSizes.push(i.globals.radialSize)
                                }
                                if (i.globals.dataChanged) {
                                    for (var h, d = 0, u = 0; u < i.globals.previousPaths.length; u++) d += b.negToZero(i.globals.previousPaths[u]);
                                    for (var p = 0; p < i.globals.previousPaths.length; p++) h = this.fullAngle * b.negToZero(i.globals.previousPaths[p]) / d, this.prevSectorAngleArr.push(h)
                                }
                                this.donutSize < 0 && (this.donutSize = 0);
                                var g = i.config.plotOptions.pie.customScale,
                                    f = i.globals.gridWidth / 2,
                                    m = i.globals.gridHeight / 2,
                                    x = f - i.globals.gridWidth / 2 * g,
                                    v = m - i.globals.gridHeight / 2 * g;
                                if ("donut" === this.chartType) {
                                    var y = a.drawCircle(this.donutSize);
                                    y.attr({
                                        cx: this.centerX,
                                        cy: this.centerY,
                                        fill: i.config.plotOptions.pie.donut.background ? i.config.plotOptions.pie.donut.background : "transparent"
                                    }), o.add(y)
                                }
                                var w = this.drawArcs(r, t);
                                if (this.sliceLabels.forEach((function(t) {
                                        w.add(t)
                                    })), o.attr({
                                        transform: "translate(".concat(x, ", ").concat(v, ") scale(").concat(g, ")")
                                    }), o.add(w), this.ret.add(o), this.donutDataLabels.show) {
                                    var C = this.renderInnerDataLabels(this.donutDataLabels, {
                                        hollowSize: this.donutSize,
                                        centerX: this.centerX,
                                        centerY: this.centerY,
                                        opacity: this.donutDataLabels.show,
                                        translateX: x,
                                        translateY: v
                                    });
                                    this.ret.add(C)
                                }
                                return "front" === i.config.grid.position && "polarArea" === this.chartType && this.drawPolarElements(this.ret), this.ret
                            }
                        }, {
                            key: "drawArcs",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new w(this.ctx),
                                    s = new S(this.ctx),
                                    n = new I(this.ctx),
                                    r = s.group({
                                        class: "apexcharts-slices"
                                    }),
                                    o = this.initialAngle,
                                    l = this.initialAngle,
                                    c = this.initialAngle,
                                    h = this.initialAngle;
                                this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0;
                                for (var d = 0; d < t.length; d++) {
                                    var u = s.group({
                                        class: "apexcharts-series apexcharts-pie-series",
                                        seriesName: b.escapeString(i.globals.seriesNames[d]),
                                        rel: d + 1,
                                        "data:realIndex": d
                                    });
                                    r.add(u), l = h, c = (o = c) + t[d], h = l + this.prevSectorAngleArr[d];
                                    var p = c < o ? this.fullAngle + c - o : c - o,
                                        g = n.fillPath({
                                            seriesNumber: d,
                                            size: this.sliceSizes[d],
                                            value: e[d]
                                        }),
                                        f = this.getChangedPath(l, h),
                                        m = s.drawPath({
                                            d: f,
                                            stroke: Array.isArray(this.lineColorArr) ? this.lineColorArr[d] : this.lineColorArr,
                                            strokeWidth: 0,
                                            fill: g,
                                            fillOpacity: i.config.fill.opacity,
                                            classes: "apexcharts-pie-area apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(d)
                                        });
                                    if (m.attr({
                                            index: 0,
                                            j: d
                                        }), a.setSelectionFilter(m, 0, d), i.config.chart.dropShadow.enabled) {
                                        var x = i.config.chart.dropShadow;
                                        a.dropShadow(m, x, d)
                                    }
                                    this.addListeners(m, this.donutDataLabels), S.setAttrs(m.node, {
                                        "data:angle": p,
                                        "data:startAngle": o,
                                        "data:strokeWidth": this.strokeWidth,
                                        "data:value": e[d]
                                    });
                                    var v = {
                                        x: 0,
                                        y: 0
                                    };
                                    "pie" === this.chartType || "polarArea" === this.chartType ? v = b.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize / 1.25 + i.config.plotOptions.pie.dataLabels.offset, (o + p / 2) % this.fullAngle) : "donut" === this.chartType && (v = b.polarToCartesian(this.centerX, this.centerY, (i.globals.radialSize + this.donutSize) / 2 + i.config.plotOptions.pie.dataLabels.offset, (o + p / 2) % this.fullAngle)), u.add(m);
                                    var y = 0;
                                    if (!this.initialAnim || i.globals.resized || i.globals.dataChanged ? this.animBeginArr.push(0) : (0 == (y = p / this.fullAngle * i.config.chart.animations.speed) && (y = 1), this.animDur = y + this.animDur, this.animBeginArr.push(this.animDur)), this.dynamicAnim && i.globals.dataChanged ? this.animatePaths(m, {
                                            size: this.sliceSizes[d],
                                            endAngle: c,
                                            startAngle: o,
                                            prevStartAngle: l,
                                            prevEndAngle: h,
                                            animateStartingPos: !0,
                                            i: d,
                                            animBeginArr: this.animBeginArr,
                                            shouldSetPrevPaths: !0,
                                            dur: i.config.chart.animations.dynamicAnimation.speed
                                        }) : this.animatePaths(m, {
                                            size: this.sliceSizes[d],
                                            endAngle: c,
                                            startAngle: o,
                                            i: d,
                                            totalItems: t.length - 1,
                                            animBeginArr: this.animBeginArr,
                                            dur: y
                                        }), i.config.plotOptions.pie.expandOnClick && "polarArea" !== this.chartType && m.click(this.pieClicked.bind(this, d)), void 0 !== i.globals.selectedDataPoints[0] && i.globals.selectedDataPoints[0].indexOf(d) > -1 && this.pieClicked(d), i.config.dataLabels.enabled) {
                                        var C = v.x,
                                            k = v.y,
                                            A = 100 * p / this.fullAngle + "%";
                                        if (0 !== p && i.config.plotOptions.pie.dataLabels.minAngleToShowLabel < t[d]) {
                                            var E = i.config.dataLabels.formatter;
                                            void 0 !== E && (A = E(i.globals.seriesPercent[d][0], {
                                                seriesIndex: d,
                                                w: i
                                            }));
                                            var T = i.globals.dataLabels.style.colors[d],
                                                P = s.group({
                                                    class: "apexcharts-datalabels"
                                                }),
                                                M = s.drawText({
                                                    x: C,
                                                    y: k,
                                                    text: A,
                                                    textAnchor: "middle",
                                                    fontSize: i.config.dataLabels.style.fontSize,
                                                    fontFamily: i.config.dataLabels.style.fontFamily,
                                                    fontWeight: i.config.dataLabels.style.fontWeight,
                                                    foreColor: T
                                                });
                                            if (P.add(M), i.config.dataLabels.dropShadow.enabled) {
                                                var L = i.config.dataLabels.dropShadow;
                                                a.dropShadow(M, L)
                                            }
                                            M.node.classList.add("apexcharts-pie-label"), i.config.chart.animations.animate && !1 === i.globals.resized && (M.node.classList.add("apexcharts-pie-label-delay"), M.node.style.animationDelay = i.config.chart.animations.speed / 940 + "s"), this.sliceLabels.push(P)
                                        }
                                    }
                                }
                                return r
                            }
                        }, {
                            key: "addListeners",
                            value: function(t, e) {
                                var i = new S(this.ctx);
                                t.node.addEventListener("mouseenter", i.pathMouseEnter.bind(this, t)), t.node.addEventListener("mouseleave", i.pathMouseLeave.bind(this, t)), t.node.addEventListener("mouseleave", this.revertDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", i.pathMouseDown.bind(this, t)), this.donutDataLabels.total.showAlways || (t.node.addEventListener("mouseenter", this.printDataLabelsInner.bind(this, t.node, e)), t.node.addEventListener("mousedown", this.printDataLabelsInner.bind(this, t.node, e)))
                            }
                        }, {
                            key: "animatePaths",
                            value: function(t, e) {
                                var i = this.w,
                                    a = e.endAngle < e.startAngle ? this.fullAngle + e.endAngle - e.startAngle : e.endAngle - e.startAngle,
                                    s = a,
                                    n = e.startAngle,
                                    r = e.startAngle;
                                void 0 !== e.prevStartAngle && void 0 !== e.prevEndAngle && (n = e.prevEndAngle, s = e.prevEndAngle < e.prevStartAngle ? this.fullAngle + e.prevEndAngle - e.prevStartAngle : e.prevEndAngle - e.prevStartAngle), e.i === i.config.series.length - 1 && (a + r > this.fullAngle ? e.endAngle = e.endAngle - (a + r) : a + r < this.fullAngle && (e.endAngle = e.endAngle + (this.fullAngle - (a + r)))), a === this.fullAngle && (a = this.fullAngle - .01), this.animateArc(t, n, r, a, s, e)
                            }
                        }, {
                            key: "animateArc",
                            value: function(t, e, i, a, s, n) {
                                var r, o = this,
                                    l = this.w,
                                    c = new y(this.ctx),
                                    h = n.size;
                                (isNaN(e) || isNaN(s)) && (e = i, s = a, n.dur = 0);
                                var d = a,
                                    u = i,
                                    p = e < i ? this.fullAngle + e - i : e - i;
                                l.globals.dataChanged && n.shouldSetPrevPaths && n.prevEndAngle && (r = o.getPiePath({
                                    me: o,
                                    startAngle: n.prevStartAngle,
                                    angle: n.prevEndAngle < n.prevStartAngle ? this.fullAngle + n.prevEndAngle - n.prevStartAngle : n.prevEndAngle - n.prevStartAngle,
                                    size: h
                                }), t.attr({
                                    d: r
                                })), 0 !== n.dur ? t.animate(n.dur, l.globals.easing, n.animBeginArr[n.i]).afterAll((function() {
                                    "pie" !== o.chartType && "donut" !== o.chartType && "polarArea" !== o.chartType || this.animate(l.config.chart.animations.dynamicAnimation.speed).attr({
                                        "stroke-width": o.strokeWidth
                                    }), n.i === l.config.series.length - 1 && c.animationCompleted(t)
                                })).during((function(l) {
                                    d = p + (a - p) * l, n.animateStartingPos && (d = s + (a - s) * l, u = e - s + (i - (e - s)) * l), r = o.getPiePath({
                                        me: o,
                                        startAngle: u,
                                        angle: d,
                                        size: h
                                    }), t.node.setAttribute("data:pathOrig", r), t.attr({
                                        d: r
                                    })
                                })) : (r = o.getPiePath({
                                    me: o,
                                    startAngle: u,
                                    angle: a,
                                    size: h
                                }), n.isTrack || (l.globals.animationEnded = !0), t.node.setAttribute("data:pathOrig", r), t.attr({
                                    d: r,
                                    "stroke-width": o.strokeWidth
                                }))
                            }
                        }, {
                            key: "pieClicked",
                            value: function(t) {
                                var e, i = this.w,
                                    a = this,
                                    s = a.sliceSizes[t] + (i.config.plotOptions.pie.expandOnClick ? 4 : 0),
                                    n = i.globals.dom.Paper.select(".apexcharts-".concat(a.chartType.toLowerCase(), "-slice-").concat(t)).members[0];
                                if ("true" !== n.attr("data:pieClicked")) {
                                    var r = i.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area");
                                    Array.prototype.forEach.call(r, (function(t) {
                                        t.setAttribute("data:pieClicked", "false");
                                        var e = t.getAttribute("data:pathOrig");
                                        t.setAttribute("d", e)
                                    })), n.attr("data:pieClicked", "true");
                                    var o = parseInt(n.attr("data:startAngle"), 10),
                                        l = parseInt(n.attr("data:angle"), 10);
                                    e = a.getPiePath({
                                        me: a,
                                        startAngle: o,
                                        angle: l,
                                        size: s
                                    }), 360 !== l && n.plot(e)
                                } else {
                                    n.attr({
                                        "data:pieClicked": "false"
                                    }), this.revertDataLabelsInner(n.node, this.donutDataLabels);
                                    var c = n.attr("data:pathOrig");
                                    n.attr({
                                        d: c
                                    })
                                }
                            }
                        }, {
                            key: "getChangedPath",
                            value: function(t, e) {
                                var i = "";
                                return this.dynamicAnim && this.w.globals.dataChanged && (i = this.getPiePath({
                                    me: this,
                                    startAngle: t,
                                    angle: e - t,
                                    size: this.size
                                })), i
                            }
                        }, {
                            key: "getPiePath",
                            value: function(t) {
                                var e = t.me,
                                    i = t.startAngle,
                                    a = t.angle,
                                    s = t.size,
                                    n = i,
                                    r = Math.PI * (n - 90) / 180,
                                    o = a + i;
                                Math.ceil(o) >= this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle && (o = this.fullAngle + this.w.config.plotOptions.pie.startAngle % this.fullAngle - .01), Math.ceil(o) > this.fullAngle && (o -= this.fullAngle);
                                var l = Math.PI * (o - 90) / 180,
                                    c = e.centerX + s * Math.cos(r),
                                    h = e.centerY + s * Math.sin(r),
                                    d = e.centerX + s * Math.cos(l),
                                    u = e.centerY + s * Math.sin(l),
                                    p = b.polarToCartesian(e.centerX, e.centerY, e.donutSize, o),
                                    g = b.polarToCartesian(e.centerX, e.centerY, e.donutSize, n),
                                    f = a > 180 ? 1 : 0,
                                    m = ["M", c, h, "A", s, s, 0, f, 1, d, u];
                                return "donut" === e.chartType ? [].concat(m, ["L", p.x, p.y, "A", e.donutSize, e.donutSize, 0, f, 0, g.x, g.y, "L", c, h, "z"]).join(" ") : "pie" === e.chartType || "polarArea" === e.chartType ? [].concat(m, ["L", e.centerX, e.centerY, "L", c, h]).join(" ") : [].concat(m).join(" ")
                            }
                        }, {
                            key: "drawPolarElements",
                            value: function(t) {
                                var e = this.w,
                                    i = new K(this.ctx),
                                    a = new S(this.ctx),
                                    s = new Tt(this.ctx),
                                    n = a.group(),
                                    r = a.group(),
                                    o = i.niceScale(0, Math.ceil(this.maxY), e.config.yaxis[0].tickAmount, 0, !0),
                                    l = o.result.reverse(),
                                    c = o.result.length;
                                this.maxY = o.niceMax;
                                for (var h = e.globals.radialSize, d = h / (c - 1), u = 0; u < c - 1; u++) {
                                    var p = a.drawCircle(h);
                                    if (p.attr({
                                            cx: this.centerX,
                                            cy: this.centerY,
                                            fill: "none",
                                            "stroke-width": e.config.plotOptions.polarArea.rings.strokeWidth,
                                            stroke: e.config.plotOptions.polarArea.rings.strokeColor
                                        }), e.config.yaxis[0].show) {
                                        var g = s.drawYAxisTexts(this.centerX, this.centerY - h + parseInt(e.config.yaxis[0].labels.style.fontSize, 10) / 2, u, l[u]);
                                        r.add(g)
                                    }
                                    n.add(p), h -= d
                                }
                                this.drawSpokes(t), t.add(n), t.add(r)
                            }
                        }, {
                            key: "renderInnerDataLabels",
                            value: function(t, e) {
                                var i = this.w,
                                    a = new S(this.ctx),
                                    s = a.group({
                                        class: "apexcharts-datalabels-group",
                                        transform: "translate(".concat(e.translateX ? e.translateX : 0, ", ").concat(e.translateY ? e.translateY : 0, ") scale(").concat(i.config.plotOptions.pie.customScale, ")")
                                    }),
                                    n = t.total.show;
                                s.node.style.opacity = e.opacity;
                                var r, o, l = e.centerX,
                                    c = e.centerY;
                                r = void 0 === t.name.color ? i.globals.colors[0] : t.name.color;
                                var h = t.name.fontSize,
                                    d = t.name.fontFamily,
                                    u = t.name.fontWeight;
                                o = void 0 === t.value.color ? i.config.chart.foreColor : t.value.color;
                                var p = t.value.formatter,
                                    g = "",
                                    f = "";
                                if (n ? (r = t.total.color, h = t.total.fontSize, d = t.total.fontFamily, u = t.total.fontWeight, f = t.total.label, g = t.total.formatter(i)) : 1 === i.globals.series.length && (g = p(i.globals.series[0], i), f = i.globals.seriesNames[0]), f && (f = t.name.formatter(f, t.total.show, i)), t.name.show) {
                                    var m = a.drawText({
                                        x: l,
                                        y: c + parseFloat(t.name.offsetY),
                                        text: f,
                                        textAnchor: "middle",
                                        foreColor: r,
                                        fontSize: h,
                                        fontWeight: u,
                                        fontFamily: d
                                    });
                                    m.node.classList.add("apexcharts-datalabel-label"), s.add(m)
                                }
                                if (t.value.show) {
                                    var x = t.name.show ? parseFloat(t.value.offsetY) + 16 : t.value.offsetY,
                                        v = a.drawText({
                                            x: l,
                                            y: c + x,
                                            text: g,
                                            textAnchor: "middle",
                                            foreColor: o,
                                            fontWeight: t.value.fontWeight,
                                            fontSize: t.value.fontSize,
                                            fontFamily: t.value.fontFamily
                                        });
                                    v.node.classList.add("apexcharts-datalabel-value"), s.add(v)
                                }
                                return s
                            }
                        }, {
                            key: "printInnerLabels",
                            value: function(t, e, i, a) {
                                var s, n = this.w;
                                a ? s = void 0 === t.name.color ? n.globals.colors[parseInt(a.parentNode.getAttribute("rel"), 10) - 1] : t.name.color : n.globals.series.length > 1 && t.total.show && (s = t.total.color);
                                var r = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-label"),
                                    o = n.globals.dom.baseEl.querySelector(".apexcharts-datalabel-value");
                                i = (0, t.value.formatter)(i, n), a || "function" != typeof t.total.formatter || (i = t.total.formatter(n));
                                var l = e === t.total.label;
                                e = t.name.formatter(e, l, n), null !== r && (r.textContent = e), null !== o && (o.textContent = i), null !== r && (r.style.fill = s)
                            }
                        }, {
                            key: "printDataLabelsInner",
                            value: function(t, e) {
                                var i = this.w,
                                    a = t.getAttribute("data:value"),
                                    s = i.globals.seriesNames[parseInt(t.parentNode.getAttribute("rel"), 10) - 1];
                                i.globals.series.length > 1 && this.printInnerLabels(e, s, a, t);
                                var n = i.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group");
                                null !== n && (n.style.opacity = 1)
                            }
                        }, {
                            key: "drawSpokes",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = new S(this.ctx),
                                    s = i.config.plotOptions.polarArea.spokes;
                                if (0 !== s.strokeWidth) {
                                    for (var n = [], r = 360 / i.globals.series.length, o = 0; o < i.globals.series.length; o++) n.push(b.polarToCartesian(this.centerX, this.centerY, i.globals.radialSize, i.config.plotOptions.pie.startAngle + r * o));
                                    n.forEach((function(i, n) {
                                        var r = a.drawLine(i.x, i.y, e.centerX, e.centerY, Array.isArray(s.connectorColors) ? s.connectorColors[n] : s.connectorColors);
                                        t.add(r)
                                    }))
                                }
                            }
                        }, {
                            key: "revertDataLabelsInner",
                            value: function(t, e, i) {
                                var a = this,
                                    s = this.w,
                                    n = s.globals.dom.baseEl.querySelector(".apexcharts-datalabels-group"),
                                    r = !1,
                                    o = s.globals.dom.baseEl.getElementsByClassName("apexcharts-pie-area"),
                                    l = function(t) {
                                        var i = t.makeSliceOut,
                                            s = t.printLabel;
                                        Array.prototype.forEach.call(o, (function(t) {
                                            "true" === t.getAttribute("data:pieClicked") && (i && (r = !0), s && a.printDataLabelsInner(t, e))
                                        }))
                                    };
                                if (l({
                                        makeSliceOut: !0,
                                        printLabel: !1
                                    }), e.total.show && s.globals.series.length > 1) r && !e.total.showAlways ? l({
                                    makeSliceOut: !1,
                                    printLabel: !0
                                }) : this.printInnerLabels(e, e.total.label, e.total.formatter(s));
                                else if (l({
                                        makeSliceOut: !1,
                                        printLabel: !0
                                    }), !r)
                                    if (s.globals.selectedDataPoints.length && s.globals.series.length > 1)
                                        if (s.globals.selectedDataPoints[0].length > 0) {
                                            var c = s.globals.selectedDataPoints[0],
                                                h = s.globals.dom.baseEl.querySelector(".apexcharts-".concat(this.chartType.toLowerCase(), "-slice-").concat(c));
                                            this.printDataLabelsInner(h, e)
                                        } else n && s.globals.selectedDataPoints.length && 0 === s.globals.selectedDataPoints[0].length && (n.style.opacity = 0);
                                else n && s.globals.series.length > 1 && (n.style.opacity = 0)
                            }
                        }]), t
                    }(),
                    Mt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.chartType = this.w.config.chart.type, this.initialAnim = this.w.config.chart.animations.enabled, this.dynamicAnim = this.initialAnim && this.w.config.chart.animations.dynamicAnimation.enabled, this.animDur = 0;
                            var i = this.w;
                            this.graphics = new S(this.ctx), this.lineColorArr = void 0 !== i.globals.stroke.colors ? i.globals.stroke.colors : i.globals.colors, this.defaultSize = i.globals.svgHeight < i.globals.svgWidth ? i.globals.gridHeight + 1.5 * i.globals.goldenPadding : i.globals.gridWidth, this.isLog = i.config.yaxis[0].logarithmic, this.coreUtils = new C(this.ctx), this.maxValue = this.isLog ? this.coreUtils.getLogVal(i.globals.maxY, 0) : i.globals.maxY, this.minValue = this.isLog ? this.coreUtils.getLogVal(this.w.globals.minY, 0) : i.globals.minY, this.polygons = i.config.plotOptions.radar.polygons, this.strokeWidth = i.config.stroke.show ? i.config.stroke.width : 0, this.size = this.defaultSize / 2.1 - this.strokeWidth - i.config.chart.dropShadow.blur, i.config.xaxis.labels.show && (this.size = this.size - i.globals.xAxisLabelsWidth / 1.75), void 0 !== i.config.plotOptions.radar.size && (this.size = i.config.plotOptions.radar.size), this.dataRadiusOfPercent = [], this.dataRadius = [], this.angleArr = [], this.yaxisLabelsTextsPos = []
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = new I(this.ctx),
                                    s = [],
                                    r = new D(this.ctx);
                                t.length && (this.dataPointsLen = t[i.globals.maxValsInArrayIndex].length), this.disAngle = 2 * Math.PI / this.dataPointsLen;
                                var o = i.globals.gridWidth / 2,
                                    l = i.globals.gridHeight / 2,
                                    c = o + i.config.plotOptions.radar.offsetX,
                                    h = l + i.config.plotOptions.radar.offsetY,
                                    d = this.graphics.group({
                                        class: "apexcharts-radar-series apexcharts-plot-series",
                                        transform: "translate(".concat(c || 0, ", ").concat(h || 0, ")")
                                    }),
                                    u = [],
                                    p = null,
                                    g = null;
                                if (this.yaxisLabels = this.graphics.group({
                                        class: "apexcharts-yaxis"
                                    }), t.forEach((function(t, o) {
                                        var l = t.length === i.globals.dataPoints,
                                            c = e.graphics.group().attr({
                                                class: "apexcharts-series",
                                                "data:longestSeries": l,
                                                seriesName: b.escapeString(i.globals.seriesNames[o]),
                                                rel: o + 1,
                                                "data:realIndex": o
                                            });
                                        e.dataRadiusOfPercent[o] = [], e.dataRadius[o] = [], e.angleArr[o] = [], t.forEach((function(t, i) {
                                            var a = Math.abs(e.maxValue - e.minValue);
                                            t += Math.abs(e.minValue), e.isLog && (t = e.coreUtils.getLogVal(t, 0)), e.dataRadiusOfPercent[o][i] = t / a, e.dataRadius[o][i] = e.dataRadiusOfPercent[o][i] * e.size, e.angleArr[o][i] = i * e.disAngle
                                        })), u = e.getDataPointsPos(e.dataRadius[o], e.angleArr[o]);
                                        var h = e.createPaths(u, {
                                            x: 0,
                                            y: 0
                                        });
                                        p = e.graphics.group({
                                            class: "apexcharts-series-markers-wrap apexcharts-element-hidden"
                                        }), g = e.graphics.group({
                                            class: "apexcharts-datalabels",
                                            "data:realIndex": o
                                        }), i.globals.delayedElements.push({
                                            el: p.node,
                                            index: o
                                        });
                                        var d = {
                                                i: o,
                                                realIndex: o,
                                                animationDelay: o,
                                                initialSpeed: i.config.chart.animations.speed,
                                                dataChangeSpeed: i.config.chart.animations.dynamicAnimation.speed,
                                                className: "apexcharts-radar",
                                                shouldClipToGrid: !1,
                                                bindEventsOnPaths: !1,
                                                stroke: i.globals.stroke.colors[o],
                                                strokeLineCap: i.config.stroke.lineCap
                                            },
                                            f = null;
                                        i.globals.previousPaths.length > 0 && (f = e.getPreviousPath(o));
                                        for (var m = 0; m < h.linePathsTo.length; m++) {
                                            var x = e.graphics.renderPaths(n(n({}, d), {}, {
                                                pathFrom: null === f ? h.linePathsFrom[m] : f,
                                                pathTo: h.linePathsTo[m],
                                                strokeWidth: Array.isArray(e.strokeWidth) ? e.strokeWidth[o] : e.strokeWidth,
                                                fill: "none",
                                                drawShadow: !1
                                            }));
                                            c.add(x);
                                            var v = a.fillPath({
                                                    seriesNumber: o
                                                }),
                                                y = e.graphics.renderPaths(n(n({}, d), {}, {
                                                    pathFrom: null === f ? h.areaPathsFrom[m] : f,
                                                    pathTo: h.areaPathsTo[m],
                                                    strokeWidth: 0,
                                                    fill: v,
                                                    drawShadow: !1
                                                }));
                                            if (i.config.chart.dropShadow.enabled) {
                                                var S = new w(e.ctx),
                                                    C = i.config.chart.dropShadow;
                                                S.dropShadow(y, Object.assign({}, C, {
                                                    noUserSpaceOnUse: !0
                                                }), o)
                                            }
                                            c.add(y)
                                        }
                                        t.forEach((function(t, a) {
                                            var s = new _(e.ctx).getMarkerConfig({
                                                    cssClass: "apexcharts-marker",
                                                    seriesIndex: o,
                                                    dataPointIndex: a
                                                }),
                                                l = e.graphics.drawMarker(u[a].x, u[a].y, s);
                                            l.attr("rel", a), l.attr("j", a), l.attr("index", o), l.node.setAttribute("default-marker-size", s.pSize);
                                            var h = e.graphics.group({
                                                class: "apexcharts-series-markers"
                                            });
                                            h && h.add(l), p.add(h), c.add(p);
                                            var d = i.config.dataLabels;
                                            if (d.enabled) {
                                                var f = d.formatter(i.globals.series[o][a], {
                                                    seriesIndex: o,
                                                    dataPointIndex: a,
                                                    w: i
                                                });
                                                r.plotDataLabelsText({
                                                    x: u[a].x,
                                                    y: u[a].y,
                                                    text: f,
                                                    textAnchor: "middle",
                                                    i: o,
                                                    j: o,
                                                    parent: g,
                                                    offsetCorrection: !1,
                                                    dataLabelsConfig: n({}, d)
                                                })
                                            }
                                            c.add(g)
                                        })), s.push(c)
                                    })), this.drawPolygons({
                                        parent: d
                                    }), i.config.xaxis.labels.show) {
                                    var f = this.drawXAxisTexts();
                                    d.add(f)
                                }
                                return s.forEach((function(t) {
                                    d.add(t)
                                })), d.add(this.yaxisLabels), d
                            }
                        }, {
                            key: "drawPolygons",
                            value: function(t) {
                                for (var e = this, i = this.w, a = t.parent, s = new Tt(this.ctx), n = i.globals.yAxisScale[0].result.reverse(), r = n.length, o = [], l = this.size / (r - 1), c = 0; c < r; c++) o[c] = l * c;
                                o.reverse();
                                var h = [],
                                    d = [];
                                o.forEach((function(t, i) {
                                    var a = b.getPolygonPos(t, e.dataPointsLen),
                                        s = "";
                                    a.forEach((function(t, a) {
                                        if (0 === i) {
                                            var n = e.graphics.drawLine(t.x, t.y, 0, 0, Array.isArray(e.polygons.connectorColors) ? e.polygons.connectorColors[a] : e.polygons.connectorColors);
                                            d.push(n)
                                        }
                                        0 === a && e.yaxisLabelsTextsPos.push({
                                            x: t.x,
                                            y: t.y
                                        }), s += t.x + "," + t.y + " "
                                    })), h.push(s)
                                })), h.forEach((function(t, s) {
                                    var n = e.polygons.strokeColors,
                                        r = e.polygons.strokeWidth,
                                        o = e.graphics.drawPolygon(t, Array.isArray(n) ? n[s] : n, Array.isArray(r) ? r[s] : r, i.globals.radarPolygons.fill.colors[s]);
                                    a.add(o)
                                })), d.forEach((function(t) {
                                    a.add(t)
                                })), i.config.yaxis[0].show && this.yaxisLabelsTextsPos.forEach((function(t, i) {
                                    var a = s.drawYAxisTexts(t.x, t.y, i, n[i]);
                                    e.yaxisLabels.add(a)
                                }))
                            }
                        }, {
                            key: "drawXAxisTexts",
                            value: function() {
                                var t = this,
                                    e = this.w,
                                    i = e.config.xaxis.labels,
                                    a = this.graphics.group({
                                        class: "apexcharts-xaxis"
                                    }),
                                    s = b.getPolygonPos(this.size, this.dataPointsLen);
                                return e.globals.labels.forEach((function(r, o) {
                                    var l = e.config.xaxis.labels.formatter,
                                        c = new D(t.ctx);
                                    if (s[o]) {
                                        var h = t.getTextPos(s[o], t.size),
                                            d = l(r, {
                                                seriesIndex: -1,
                                                dataPointIndex: o,
                                                w: e
                                            });
                                        c.plotDataLabelsText({
                                            x: h.newX,
                                            y: h.newY,
                                            text: d,
                                            textAnchor: h.textAnchor,
                                            i: o,
                                            j: o,
                                            parent: a,
                                            color: Array.isArray(i.style.colors) && i.style.colors[o] ? i.style.colors[o] : "#a8a8a8",
                                            dataLabelsConfig: n({
                                                textAnchor: h.textAnchor,
                                                dropShadow: {
                                                    enabled: !1
                                                }
                                            }, i),
                                            offsetCorrection: !1
                                        })
                                    }
                                })), a
                            }
                        }, {
                            key: "createPaths",
                            value: function(t, e) {
                                var i = this,
                                    a = [],
                                    s = [],
                                    n = [],
                                    r = [];
                                if (t.length) {
                                    s = [this.graphics.move(e.x, e.y)], r = [this.graphics.move(e.x, e.y)];
                                    var o = this.graphics.move(t[0].x, t[0].y),
                                        l = this.graphics.move(t[0].x, t[0].y);
                                    t.forEach((function(e, a) {
                                        o += i.graphics.line(e.x, e.y), l += i.graphics.line(e.x, e.y), a === t.length - 1 && (o += "Z", l += "Z")
                                    })), a.push(o), n.push(l)
                                }
                                return {
                                    linePathsFrom: s,
                                    linePathsTo: a,
                                    areaPathsFrom: r,
                                    areaPathsTo: n
                                }
                            }
                        }, {
                            key: "getTextPos",
                            value: function(t, e) {
                                var i = "middle",
                                    a = t.x,
                                    s = t.y;
                                return Math.abs(t.x) >= 10 ? t.x > 0 ? (i = "start", a += 10) : t.x < 0 && (i = "end", a -= 10) : i = "middle", Math.abs(t.y) >= e - 10 && (t.y < 0 ? s -= 10 : t.y > 0 && (s += 10)), {
                                    textAnchor: i,
                                    newX: a,
                                    newY: s
                                }
                            }
                        }, {
                            key: "getPreviousPath",
                            value: function(t) {
                                for (var e = this.w, i = null, a = 0; a < e.globals.previousPaths.length; a++) {
                                    var s = e.globals.previousPaths[a];
                                    s.paths.length > 0 && parseInt(s.realIndex, 10) === parseInt(t, 10) && void 0 !== e.globals.previousPaths[a].paths[0] && (i = e.globals.previousPaths[a].paths[0].d)
                                }
                                return i
                            }
                        }, {
                            key: "getDataPointsPos",
                            value: function(t, e) {
                                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : this.dataPointsLen;
                                t = t || [], e = e || [];
                                for (var a = [], s = 0; s < i; s++) {
                                    var n = {};
                                    n.x = t[s] * Math.sin(e[s]), n.y = -t[s] * Math.cos(e[s]), a.push(n)
                                }
                                return a
                            }
                        }]), t
                    }(),
                    Lt = function(t) {
                        d(i, Pt);
                        var e = f(i);

                        function i(t) {
                            var a;
                            o(this, i), (a = e.call(this, t)).ctx = t, a.w = t.w, a.animBeginArr = [0], a.animDur = 0;
                            var s = a.w;
                            return a.startAngle = s.config.plotOptions.radialBar.startAngle, a.endAngle = s.config.plotOptions.radialBar.endAngle, a.totalAngle = Math.abs(s.config.plotOptions.radialBar.endAngle - s.config.plotOptions.radialBar.startAngle), a.trackStartAngle = s.config.plotOptions.radialBar.track.startAngle, a.trackEndAngle = s.config.plotOptions.radialBar.track.endAngle, a.donutDataLabels = a.w.config.plotOptions.radialBar.dataLabels, a.radialDataLabels = a.donutDataLabels, a.trackStartAngle || (a.trackStartAngle = a.startAngle), a.trackEndAngle || (a.trackEndAngle = a.endAngle), 360 === a.endAngle && (a.endAngle = 359.99), a.margin = parseInt(s.config.plotOptions.radialBar.track.margin, 10), a
                        }
                        return c(i, [{
                            key: "draw",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = i.group({
                                        class: "apexcharts-radialbar"
                                    });
                                if (e.globals.noData) return a;
                                var s = i.group(),
                                    n = this.defaultSize / 2,
                                    r = e.globals.gridWidth / 2,
                                    o = this.defaultSize / 2.05;
                                e.config.chart.sparkline.enabled || (o = o - e.config.stroke.width - e.config.chart.dropShadow.blur);
                                var l = e.globals.fill.colors;
                                if (e.config.plotOptions.radialBar.track.show) {
                                    var c = this.drawTracks({
                                        size: o,
                                        centerX: r,
                                        centerY: n,
                                        colorArr: l,
                                        series: t
                                    });
                                    s.add(c)
                                }
                                var h = this.drawArcs({
                                        size: o,
                                        centerX: r,
                                        centerY: n,
                                        colorArr: l,
                                        series: t
                                    }),
                                    d = 360;
                                e.config.plotOptions.radialBar.startAngle < 0 && (d = this.totalAngle);
                                var u = (360 - d) / 360;
                                if (e.globals.radialSize = o - o * u, this.radialDataLabels.value.show) {
                                    var p = Math.max(this.radialDataLabels.value.offsetY, this.radialDataLabels.name.offsetY);
                                    e.globals.radialSize += p * u
                                }
                                return s.add(h.g), "front" === e.config.plotOptions.radialBar.hollow.position && (h.g.add(h.elHollow), h.dataLabels && h.g.add(h.dataLabels)), a.add(s), a
                            }
                        }, {
                            key: "drawTracks",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = i.group({
                                        class: "apexcharts-tracks"
                                    }),
                                    s = new w(this.ctx),
                                    n = new I(this.ctx),
                                    r = this.getStrokeWidth(t);
                                t.size = t.size - r / 2;
                                for (var o = 0; o < t.series.length; o++) {
                                    var l = i.group({
                                        class: "apexcharts-radialbar-track apexcharts-track"
                                    });
                                    a.add(l), l.attr({
                                        rel: o + 1
                                    }), t.size = t.size - r - this.margin;
                                    var c = e.config.plotOptions.radialBar.track,
                                        h = n.fillPath({
                                            seriesNumber: 0,
                                            size: t.size,
                                            fillColors: Array.isArray(c.background) ? c.background[o] : c.background,
                                            solid: !0
                                        }),
                                        d = this.trackStartAngle,
                                        u = this.trackEndAngle;
                                    Math.abs(u) + Math.abs(d) >= 360 && (u = 360 - Math.abs(this.startAngle) - .1);
                                    var p = i.drawPath({
                                        d: "",
                                        stroke: h,
                                        strokeWidth: r * parseInt(c.strokeWidth, 10) / 100,
                                        fill: "none",
                                        strokeOpacity: c.opacity,
                                        classes: "apexcharts-radialbar-area"
                                    });
                                    if (c.dropShadow.enabled) {
                                        var g = c.dropShadow;
                                        s.dropShadow(p, g)
                                    }
                                    l.add(p), p.attr("id", "apexcharts-radialbarTrack-" + o), this.animatePaths(p, {
                                        centerX: t.centerX,
                                        centerY: t.centerY,
                                        endAngle: u,
                                        startAngle: d,
                                        size: t.size,
                                        i: o,
                                        totalItems: 2,
                                        animBeginArr: 0,
                                        dur: 0,
                                        isTrack: !0,
                                        easing: e.globals.easing
                                    })
                                }
                                return a
                            }
                        }, {
                            key: "drawArcs",
                            value: function(t) {
                                var e = this.w,
                                    i = new S(this.ctx),
                                    a = new I(this.ctx),
                                    s = new w(this.ctx),
                                    n = i.group(),
                                    r = this.getStrokeWidth(t);
                                t.size = t.size - r / 2;
                                var o = e.config.plotOptions.radialBar.hollow.background,
                                    l = t.size - r * t.series.length - this.margin * t.series.length - r * parseInt(e.config.plotOptions.radialBar.track.strokeWidth, 10) / 100 / 2,
                                    c = l - e.config.plotOptions.radialBar.hollow.margin;
                                void 0 !== e.config.plotOptions.radialBar.hollow.image && (o = this.drawHollowImage(t, n, l, o));
                                var h = this.drawHollow({
                                    size: c,
                                    centerX: t.centerX,
                                    centerY: t.centerY,
                                    fill: o || "transparent"
                                });
                                if (e.config.plotOptions.radialBar.hollow.dropShadow.enabled) {
                                    var d = e.config.plotOptions.radialBar.hollow.dropShadow;
                                    s.dropShadow(h, d)
                                }
                                var u = 1;
                                !this.radialDataLabels.total.show && e.globals.series.length > 1 && (u = 0);
                                var p = null;
                                this.radialDataLabels.show && (p = this.renderInnerDataLabels(this.radialDataLabels, {
                                    hollowSize: l,
                                    centerX: t.centerX,
                                    centerY: t.centerY,
                                    opacity: u
                                })), "back" === e.config.plotOptions.radialBar.hollow.position && (n.add(h), p && n.add(p));
                                var g = !1;
                                e.config.plotOptions.radialBar.inverseOrder && (g = !0);
                                for (var f = g ? t.series.length - 1 : 0; g ? f >= 0 : f < t.series.length; g ? f-- : f++) {
                                    var m = i.group({
                                        class: "apexcharts-series apexcharts-radial-series",
                                        seriesName: b.escapeString(e.globals.seriesNames[f])
                                    });
                                    n.add(m), m.attr({
                                        rel: f + 1,
                                        "data:realIndex": f
                                    }), this.ctx.series.addCollapsedClassToSeries(m, f), t.size = t.size - r - this.margin;
                                    var x = a.fillPath({
                                            seriesNumber: f,
                                            size: t.size,
                                            value: t.series[f]
                                        }),
                                        v = this.startAngle,
                                        y = void 0,
                                        C = b.negToZero(t.series[f] > 100 ? 100 : t.series[f]) / 100,
                                        k = Math.round(this.totalAngle * C) + this.startAngle,
                                        A = void 0;
                                    e.globals.dataChanged && (y = this.startAngle, A = Math.round(this.totalAngle * b.negToZero(e.globals.previousPaths[f]) / 100) + y), Math.abs(k) + Math.abs(v) >= 360 && (k -= .01), Math.abs(A) + Math.abs(y) >= 360 && (A -= .01);
                                    var E = k - v,
                                        T = Array.isArray(e.config.stroke.dashArray) ? e.config.stroke.dashArray[f] : e.config.stroke.dashArray,
                                        P = i.drawPath({
                                            d: "",
                                            stroke: x,
                                            strokeWidth: r,
                                            fill: "none",
                                            fillOpacity: e.config.fill.opacity,
                                            classes: "apexcharts-radialbar-area apexcharts-radialbar-slice-" + f,
                                            strokeDashArray: T
                                        });
                                    if (S.setAttrs(P.node, {
                                            "data:angle": E,
                                            "data:value": t.series[f]
                                        }), e.config.chart.dropShadow.enabled) {
                                        var M = e.config.chart.dropShadow;
                                        s.dropShadow(P, M, f)
                                    }
                                    s.setSelectionFilter(P, 0, f), this.addListeners(P, this.radialDataLabels), m.add(P), P.attr({
                                        index: 0,
                                        j: f
                                    });
                                    var L = 0;
                                    !this.initialAnim || e.globals.resized || e.globals.dataChanged || (L = e.config.chart.animations.speed), e.globals.dataChanged && (L = e.config.chart.animations.dynamicAnimation.speed), this.animDur = L / (1.2 * t.series.length) + this.animDur, this.animBeginArr.push(this.animDur), this.animatePaths(P, {
                                        centerX: t.centerX,
                                        centerY: t.centerY,
                                        endAngle: k,
                                        startAngle: v,
                                        prevEndAngle: A,
                                        prevStartAngle: y,
                                        size: t.size,
                                        i: f,
                                        totalItems: 2,
                                        animBeginArr: this.animBeginArr,
                                        dur: L,
                                        shouldSetPrevPaths: !0,
                                        easing: e.globals.easing
                                    })
                                }
                                return {
                                    g: n,
                                    elHollow: h,
                                    dataLabels: p
                                }
                            }
                        }, {
                            key: "drawHollow",
                            value: function(t) {
                                var e = new S(this.ctx).drawCircle(2 * t.size);
                                return e.attr({
                                    class: "apexcharts-radialbar-hollow",
                                    cx: t.centerX,
                                    cy: t.centerY,
                                    r: t.size,
                                    fill: t.fill
                                }), e
                            }
                        }, {
                            key: "drawHollowImage",
                            value: function(t, e, i, a) {
                                var s = this.w,
                                    n = new I(this.ctx),
                                    r = b.randomId(),
                                    o = s.config.plotOptions.radialBar.hollow.image;
                                if (s.config.plotOptions.radialBar.hollow.imageClipped) n.clippedImgArea({
                                    width: i,
                                    height: i,
                                    image: o,
                                    patternID: "pattern".concat(s.globals.cuid).concat(r)
                                }), a = "url(#pattern".concat(s.globals.cuid).concat(r, ")");
                                else {
                                    var l = s.config.plotOptions.radialBar.hollow.imageWidth,
                                        c = s.config.plotOptions.radialBar.hollow.imageHeight;
                                    if (void 0 === l && void 0 === c) {
                                        var h = s.globals.dom.Paper.image(o).loaded((function(e) {
                                            this.move(t.centerX - e.width / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - e.height / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY)
                                        }));
                                        e.add(h)
                                    } else {
                                        var d = s.globals.dom.Paper.image(o).loaded((function(e) {
                                            this.move(t.centerX - l / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetX, t.centerY - c / 2 + s.config.plotOptions.radialBar.hollow.imageOffsetY), this.size(l, c)
                                        }));
                                        e.add(d)
                                    }
                                }
                                return a
                            }
                        }, {
                            key: "getStrokeWidth",
                            value: function(t) {
                                var e = this.w;
                                return t.size * (100 - parseInt(e.config.plotOptions.radialBar.hollow.size, 10)) / 100 / (t.series.length + 1) - this.margin
                            }
                        }]), i
                    }(),
                    It = function() {
                        function t(e) {
                            o(this, t), this.w = e.w, this.lineCtx = e
                        }
                        return c(t, [{
                            key: "sameValueSeriesFix",
                            value: function(t, e) {
                                var i = this.w;
                                if ("line" === i.config.chart.type && ("gradient" === i.config.fill.type || "gradient" === i.config.fill.type[t]) && new C(this.lineCtx.ctx, i).seriesHaveSameValues(t)) {
                                    var a = e[t].slice();
                                    a[a.length - 1] = a[a.length - 1] + 1e-6, e[t] = a
                                }
                                return e
                            }
                        }, {
                            key: "calculatePoints",
                            value: function(t) {
                                var e = t.series,
                                    i = t.realIndex,
                                    a = t.x,
                                    s = t.y,
                                    n = t.i,
                                    r = t.j,
                                    o = t.prevY,
                                    l = this.w,
                                    c = [],
                                    h = [];
                                if (0 === r) {
                                    var d = this.lineCtx.categoryAxisCorrection + l.config.markers.offsetX;
                                    l.globals.isXNumeric && (d = (l.globals.seriesX[i][0] - l.globals.minX) / this.lineCtx.xRatio + l.config.markers.offsetX), c.push(d), h.push(b.isNumber(e[n][0]) ? o + l.config.markers.offsetY : null), c.push(a + l.config.markers.offsetX), h.push(b.isNumber(e[n][r + 1]) ? s + l.config.markers.offsetY : null)
                                } else c.push(a + l.config.markers.offsetX), h.push(b.isNumber(e[n][r + 1]) ? s + l.config.markers.offsetY : null);
                                return {
                                    x: c,
                                    y: h
                                }
                            }
                        }, {
                            key: "checkPreviousPaths",
                            value: function(t) {
                                for (var e = t.pathFromLine, i = t.pathFromArea, a = t.realIndex, s = this.w, n = 0; n < s.globals.previousPaths.length; n++) {
                                    var r = s.globals.previousPaths[n];
                                    ("line" === r.type || "area" === r.type) && r.paths.length > 0 && parseInt(r.realIndex, 10) === parseInt(a, 10) && ("line" === r.type ? (this.lineCtx.appendPathFrom = !1, e = s.globals.previousPaths[n].paths[0].d) : "area" === r.type && (this.lineCtx.appendPathFrom = !1, i = s.globals.previousPaths[n].paths[0].d, s.config.stroke.show && s.globals.previousPaths[n].paths[1] && (e = s.globals.previousPaths[n].paths[1].d)))
                                }
                                return {
                                    pathFromLine: e,
                                    pathFromArea: i
                                }
                            }
                        }, {
                            key: "determineFirstPrevY",
                            value: function(t) {
                                var e = t.i,
                                    i = t.series,
                                    a = t.prevY,
                                    s = t.lineYPosition,
                                    n = this.w;
                                if (void 0 !== i[e][0]) a = (s = n.config.chart.stacked && e > 0 ? this.lineCtx.prevSeriesY[e - 1][0] : this.lineCtx.zeroY) - i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] + 2 * (this.lineCtx.isReversed ? i[e][0] / this.lineCtx.yRatio[this.lineCtx.yaxisIndex] : 0);
                                else if (n.config.chart.stacked && e > 0 && void 0 === i[e][0])
                                    for (var r = e - 1; r >= 0; r--)
                                        if (null !== i[r][0] && void 0 !== i[r][0]) {
                                            a = s = this.lineCtx.prevSeriesY[r][0];
                                            break
                                        }
                                return {
                                    prevY: a,
                                    lineYPosition: s
                                }
                            }
                        }]), t
                    }(),
                    _t = function() {
                        function t(e, i, a) {
                            o(this, t), this.ctx = e, this.w = e.w, this.xyRatios = i, this.pointsChart = !("bubble" !== this.w.config.chart.type && "scatter" !== this.w.config.chart.type) || a, this.scatter = new z(this.ctx), this.noNegatives = this.w.globals.minX === Number.MAX_VALUE, this.lineHelpers = new It(this), this.markers = new _(this.ctx), this.prevSeriesY = [], this.categoryAxisCorrection = 0, this.yaxisIndex = 0
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = new S(this.ctx),
                                    n = a.globals.comboCharts ? e : a.config.chart.type,
                                    r = s.group({
                                        class: "apexcharts-".concat(n, "-series apexcharts-plot-series")
                                    }),
                                    o = new C(this.ctx, a);
                                this.yRatio = this.xyRatios.yRatio, this.zRatio = this.xyRatios.zRatio, this.xRatio = this.xyRatios.xRatio, this.baseLineY = this.xyRatios.baseLineY, t = o.getLogSeries(t), this.yRatio = o.getLogYRatios(this.yRatio);
                                for (var l = [], c = 0; c < t.length; c++) {
                                    t = this.lineHelpers.sameValueSeriesFix(c, t);
                                    var h = a.globals.comboCharts ? i[c] : c;
                                    this._initSerieVariables(t, c, h);
                                    var d = [],
                                        u = [],
                                        p = a.globals.padHorizontal + this.categoryAxisCorrection;
                                    this.ctx.series.addCollapsedClassToSeries(this.elSeries, h), a.globals.isXNumeric && a.globals.seriesX.length > 0 && (p = (a.globals.seriesX[h][0] - a.globals.minX) / this.xRatio), u.push(p);
                                    var g, f = p,
                                        m = f,
                                        x = this.zeroY;
                                    x = this.lineHelpers.determineFirstPrevY({
                                        i: c,
                                        series: t,
                                        prevY: x,
                                        lineYPosition: 0
                                    }).prevY, d.push(x), g = x;
                                    var v = this._calculatePathsFrom({
                                            series: t,
                                            i: c,
                                            realIndex: h,
                                            prevX: m,
                                            prevY: x
                                        }),
                                        b = this._iterateOverDataPoints({
                                            series: t,
                                            realIndex: h,
                                            i: c,
                                            x: p,
                                            y: 1,
                                            pX: f,
                                            pY: g,
                                            pathsFrom: v,
                                            linePaths: [],
                                            areaPaths: [],
                                            seriesIndex: i,
                                            lineYPosition: 0,
                                            xArrj: u,
                                            yArrj: d
                                        });
                                    this._handlePaths({
                                        type: n,
                                        realIndex: h,
                                        i: c,
                                        paths: b
                                    }), this.elSeries.add(this.elPointsMain), this.elSeries.add(this.elDataLabelsWrap), l.push(this.elSeries)
                                }
                                if (a.config.chart.stacked)
                                    for (var y = l.length; y > 0; y--) r.add(l[y - 1]);
                                else
                                    for (var w = 0; w < l.length; w++) r.add(l[w]);
                                return r
                            }
                        }, {
                            key: "_initSerieVariables",
                            value: function(t, e, i) {
                                var a = this.w,
                                    s = new S(this.ctx);
                                this.xDivision = a.globals.gridWidth / (a.globals.dataPoints - ("on" === a.config.xaxis.tickPlacement ? 1 : 0)), this.strokeWidth = Array.isArray(a.config.stroke.width) ? a.config.stroke.width[i] : a.config.stroke.width, this.yRatio.length > 1 && (this.yaxisIndex = i), this.isReversed = a.config.yaxis[this.yaxisIndex] && a.config.yaxis[this.yaxisIndex].reversed, this.zeroY = a.globals.gridHeight - this.baseLineY[this.yaxisIndex] - (this.isReversed ? a.globals.gridHeight : 0) + (this.isReversed ? 2 * this.baseLineY[this.yaxisIndex] : 0), this.areaBottomY = this.zeroY, (this.zeroY > a.globals.gridHeight || "end" === a.config.plotOptions.area.fillTo) && (this.areaBottomY = a.globals.gridHeight), this.categoryAxisCorrection = this.xDivision / 2, this.elSeries = s.group({
                                    class: "apexcharts-series",
                                    seriesName: b.escapeString(a.globals.seriesNames[i])
                                }), this.elPointsMain = s.group({
                                    class: "apexcharts-series-markers-wrap",
                                    "data:realIndex": i
                                }), this.elDataLabelsWrap = s.group({
                                    class: "apexcharts-datalabels",
                                    "data:realIndex": i
                                });
                                var n = t[e].length === a.globals.dataPoints;
                                this.elSeries.attr({
                                    "data:longestSeries": n,
                                    rel: e + 1,
                                    "data:realIndex": i
                                }), this.appendPathFrom = !0
                            }
                        }, {
                            key: "_calculatePathsFrom",
                            value: function(t) {
                                var e, i, a, s, n = t.series,
                                    r = t.i,
                                    o = t.realIndex,
                                    l = t.prevX,
                                    c = t.prevY,
                                    h = this.w,
                                    d = new S(this.ctx);
                                if (null === n[r][0]) {
                                    for (var u = 0; u < n[r].length; u++)
                                        if (null !== n[r][u]) {
                                            l = this.xDivision * u, c = this.zeroY - n[r][u] / this.yRatio[this.yaxisIndex], e = d.move(l, c), i = d.move(l, this.areaBottomY);
                                            break
                                        }
                                } else e = d.move(l, c), i = d.move(l, this.areaBottomY) + d.line(l, c);
                                if (a = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), s = d.move(-1, this.zeroY) + d.line(-1, this.zeroY), h.globals.previousPaths.length > 0) {
                                    var p = this.lineHelpers.checkPreviousPaths({
                                        pathFromLine: a,
                                        pathFromArea: s,
                                        realIndex: o
                                    });
                                    a = p.pathFromLine, s = p.pathFromArea
                                }
                                return {
                                    prevX: l,
                                    prevY: c,
                                    linePath: e,
                                    areaPath: i,
                                    pathFromLine: a,
                                    pathFromArea: s
                                }
                            }
                        }, {
                            key: "_handlePaths",
                            value: function(t) {
                                var e = t.type,
                                    i = t.realIndex,
                                    a = t.i,
                                    s = t.paths,
                                    r = this.w,
                                    o = new S(this.ctx),
                                    l = new I(this.ctx);
                                this.prevSeriesY.push(s.yArrj), r.globals.seriesXvalues[i] = s.xArrj, r.globals.seriesYvalues[i] = s.yArrj;
                                var c = r.config.forecastDataPoints;
                                if (c.count > 0) {
                                    var h = r.globals.seriesXvalues[i][r.globals.seriesXvalues[i].length - c.count - 1],
                                        d = o.drawRect(h, 0, r.globals.gridWidth, r.globals.gridHeight, 0);
                                    r.globals.dom.elForecastMask.appendChild(d.node);
                                    var u = o.drawRect(0, 0, h, r.globals.gridHeight, 0);
                                    r.globals.dom.elNonForecastMask.appendChild(u.node)
                                }
                                this.pointsChart || r.globals.delayedElements.push({
                                    el: this.elPointsMain.node,
                                    index: i
                                });
                                var p = {
                                    i: a,
                                    realIndex: i,
                                    animationDelay: a,
                                    initialSpeed: r.config.chart.animations.speed,
                                    dataChangeSpeed: r.config.chart.animations.dynamicAnimation.speed,
                                    className: "apexcharts-".concat(e)
                                };
                                if ("area" === e)
                                    for (var g = l.fillPath({
                                            seriesNumber: i
                                        }), f = 0; f < s.areaPaths.length; f++) {
                                        var m = o.renderPaths(n(n({}, p), {}, {
                                            pathFrom: s.pathFromArea,
                                            pathTo: s.areaPaths[f],
                                            stroke: "none",
                                            strokeWidth: 0,
                                            strokeLineCap: null,
                                            fill: g
                                        }));
                                        this.elSeries.add(m)
                                    }
                                if (r.config.stroke.show && !this.pointsChart) {
                                    var x = null;
                                    if ("line" === e) x = l.fillPath({
                                        seriesNumber: i,
                                        i: a
                                    });
                                    else if ("solid" === r.config.stroke.fill.type) x = r.globals.stroke.colors[i];
                                    else {
                                        var v = r.config.fill;
                                        r.config.fill = r.config.stroke.fill, x = l.fillPath({
                                            seriesNumber: i,
                                            i: a
                                        }), r.config.fill = v
                                    }
                                    for (var b = 0; b < s.linePaths.length; b++) {
                                        var y = n(n({}, p), {}, {
                                                pathFrom: s.pathFromLine,
                                                pathTo: s.linePaths[b],
                                                stroke: x,
                                                strokeWidth: this.strokeWidth,
                                                strokeLineCap: r.config.stroke.lineCap,
                                                fill: "none"
                                            }),
                                            w = o.renderPaths(y);
                                        if (this.elSeries.add(w), c.count > 0) {
                                            var C = o.renderPaths(y);
                                            C.node.setAttribute("stroke-dasharray", c.dashArray), c.strokeWidth && C.node.setAttribute("stroke-width", c.strokeWidth), this.elSeries.add(C), C.attr("clip-path", "url(#forecastMask".concat(r.globals.cuid, ")")), w.attr("clip-path", "url(#nonForecastMask".concat(r.globals.cuid, ")"))
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "_iterateOverDataPoints",
                            value: function(t) {
                                for (var e = t.series, i = t.realIndex, a = t.i, s = t.x, n = t.y, r = t.pX, o = t.pY, l = t.pathsFrom, c = t.linePaths, h = t.areaPaths, d = t.seriesIndex, u = t.lineYPosition, p = t.xArrj, g = t.yArrj, f = this.w, m = new S(this.ctx), x = this.yRatio, v = l.prevY, y = l.linePath, w = l.areaPath, C = l.pathFromLine, k = l.pathFromArea, A = b.isNumber(f.globals.minYArr[i]) ? f.globals.minYArr[i] : f.globals.minY, E = f.globals.dataPoints > 1 ? f.globals.dataPoints - 1 : f.globals.dataPoints, T = 0; T < E; T++) {
                                    var P = void 0 === e[a][T + 1] || null === e[a][T + 1];
                                    if (f.globals.isXNumeric) {
                                        var M = f.globals.seriesX[i][T + 1];
                                        void 0 === f.globals.seriesX[i][T + 1] && (M = f.globals.seriesX[i][E - 1]), s = (M - f.globals.minX) / this.xRatio
                                    } else s += this.xDivision;
                                    u = f.config.chart.stacked && a > 0 && f.globals.collapsedSeries.length < f.config.series.length - 1 ? this.prevSeriesY[function(t) {
                                        for (var e = t, i = 0; i < f.globals.series.length; i++)
                                            if (f.globals.collapsedSeriesIndices.indexOf(t) > -1) {
                                                e--;
                                                break
                                            }
                                        return e >= 0 ? e : 0
                                    }(a - 1)][T + 1] : this.zeroY, n = P ? u - A / x[this.yaxisIndex] + 2 * (this.isReversed ? A / x[this.yaxisIndex] : 0) : u - e[a][T + 1] / x[this.yaxisIndex] + 2 * (this.isReversed ? e[a][T + 1] / x[this.yaxisIndex] : 0), p.push(s), g.push(n);
                                    var L = this.lineHelpers.calculatePoints({
                                            series: e,
                                            x: s,
                                            y: n,
                                            realIndex: i,
                                            i: a,
                                            j: T,
                                            prevY: v
                                        }),
                                        I = this._createPaths({
                                            series: e,
                                            i: a,
                                            realIndex: i,
                                            j: T,
                                            x: s,
                                            y: n,
                                            pX: r,
                                            pY: o,
                                            linePath: y,
                                            areaPath: w,
                                            linePaths: c,
                                            areaPaths: h,
                                            seriesIndex: d
                                        });
                                    h = I.areaPaths, c = I.linePaths, r = I.pX, o = I.pY, w = I.areaPath, y = I.linePath, this.appendPathFrom && (C += m.line(s, this.zeroY), k += m.line(s, this.zeroY)), this.handleNullDataPoints(e, L, a, T, i), this._handleMarkersAndLabels({
                                        pointsPos: L,
                                        series: e,
                                        x: s,
                                        y: n,
                                        prevY: v,
                                        i: a,
                                        j: T,
                                        realIndex: i
                                    })
                                }
                                return {
                                    yArrj: g,
                                    xArrj: p,
                                    pathFromArea: k,
                                    areaPaths: h,
                                    pathFromLine: C,
                                    linePaths: c
                                }
                            }
                        }, {
                            key: "_handleMarkersAndLabels",
                            value: function(t) {
                                var e = t.pointsPos;
                                t.series, t.x, t.y, t.prevY;
                                var i = t.i,
                                    a = t.j,
                                    s = t.realIndex,
                                    n = this.w,
                                    r = new D(this.ctx);
                                if (this.pointsChart) this.scatter.draw(this.elSeries, a, {
                                    realIndex: s,
                                    pointsPos: e,
                                    zRatio: this.zRatio,
                                    elParent: this.elPointsMain
                                });
                                else {
                                    n.globals.series[i].length > 1 && this.elPointsMain.node.classList.add("apexcharts-element-hidden");
                                    var o = this.markers.plotChartMarkers(e, s, a + 1);
                                    null !== o && this.elPointsMain.add(o)
                                }
                                var l = r.drawDataLabel(e, s, a + 1, null);
                                null !== l && this.elDataLabelsWrap.add(l)
                            }
                        }, {
                            key: "_createPaths",
                            value: function(t) {
                                var e = t.series,
                                    i = t.i,
                                    a = t.realIndex,
                                    s = t.j,
                                    n = t.x,
                                    r = t.y,
                                    o = t.pX,
                                    l = t.pY,
                                    c = t.linePath,
                                    h = t.areaPath,
                                    d = t.linePaths,
                                    u = t.areaPaths,
                                    p = t.seriesIndex,
                                    g = this.w,
                                    f = new S(this.ctx),
                                    m = g.config.stroke.curve,
                                    x = this.areaBottomY;
                                if (Array.isArray(g.config.stroke.curve) && (m = Array.isArray(p) ? g.config.stroke.curve[p[i]] : g.config.stroke.curve[i]), "smooth" === m) {
                                    var v = .35 * (n - o);
                                    g.globals.hasNullValues ? (null !== e[i][s] && (null !== e[i][s + 1] ? (c = f.move(o, l) + f.curve(o + v, l, n - v, r, n + 1, r), h = f.move(o + 1, l) + f.curve(o + v, l, n - v, r, n + 1, r) + f.line(n, x) + f.line(o, x) + "z") : (c = f.move(o, l), h = f.move(o, l) + "z")), d.push(c), u.push(h)) : (c += f.curve(o + v, l, n - v, r, n, r), h += f.curve(o + v, l, n - v, r, n, r)), o = n, l = r, s === e[i].length - 2 && (h = h + f.curve(o, l, n, r, n, x) + f.move(n, r) + "z", g.globals.hasNullValues || (d.push(c), u.push(h)))
                                } else {
                                    if (null === e[i][s + 1]) {
                                        c += f.move(n, r);
                                        var b = g.globals.isXNumeric ? (g.globals.seriesX[a][s] - g.globals.minX) / this.xRatio : n - this.xDivision;
                                        h = h + f.line(b, x) + f.move(n, r) + "z"
                                    }
                                    null === e[i][s] && (c += f.move(n, r), h += f.move(n, x)), "stepline" === m ? (c = c + f.line(n, null, "H") + f.line(null, r, "V"), h = h + f.line(n, null, "H") + f.line(null, r, "V")) : "straight" === m && (c += f.line(n, r), h += f.line(n, r)), s === e[i].length - 2 && (h = h + f.line(n, x) + f.move(n, r) + "z", d.push(c), u.push(h))
                                }
                                return {
                                    linePaths: d,
                                    areaPaths: u,
                                    pX: o,
                                    pY: l,
                                    linePath: c,
                                    areaPath: h
                                }
                            }
                        }, {
                            key: "handleNullDataPoints",
                            value: function(t, e, i, a, s) {
                                var n = this.w;
                                if (null === t[i][a] && n.config.markers.showNullDataPoints || 1 === t[i].length) {
                                    var r = this.markers.plotChartMarkers(e, s, a + 1, this.strokeWidth - n.config.markers.strokeWidth / 2, !0);
                                    null !== r && this.elPointsMain.add(r)
                                }
                            }
                        }]), t
                    }();
                window.TreemapSquared = {}, window.TreemapSquared.generate = function() {
                    function t(e, i, a, s) {
                        this.xoffset = e, this.yoffset = i, this.height = s, this.width = a, this.shortestEdge = function() {
                            return Math.min(this.height, this.width)
                        }, this.getCoordinates = function(t) {
                            var e, i = [],
                                a = this.xoffset,
                                s = this.yoffset,
                                r = n(t) / this.height,
                                o = n(t) / this.width;
                            if (this.width >= this.height)
                                for (e = 0; e < t.length; e++) i.push([a, s, a + r, s + t[e] / r]), s += t[e] / r;
                            else
                                for (e = 0; e < t.length; e++) i.push([a, s, a + t[e] / o, s + o]), a += t[e] / o;
                            return i
                        }, this.cutArea = function(e) {
                            var i;
                            if (this.width >= this.height) {
                                var a = e / this.height,
                                    s = this.width - a;
                                i = new t(this.xoffset + a, this.yoffset, s, this.height)
                            } else {
                                var n = e / this.width,
                                    r = this.height - n;
                                i = new t(this.xoffset, this.yoffset + n, this.width, r)
                            }
                            return i
                        }
                    }

                    function e(e, a, s, r, o) {
                        return r = void 0 === r ? 0 : r, o = void 0 === o ? 0 : o,
                            function(t) {
                                var e, i, a = [];
                                for (e = 0; e < t.length; e++)
                                    for (i = 0; i < t[e].length; i++) a.push(t[e][i]);
                                return a
                            }(i(function(t, e) {
                                var i, a = [],
                                    s = e / n(t);
                                for (i = 0; i < t.length; i++) a[i] = t[i] * s;
                                return a
                            }(e, a * s), [], new t(r, o, a, s), []))
                    }

                    function i(t, e, s, r) {
                        var o, l, c;
                        if (0 !== t.length) return o = s.shortestEdge(),
                            function(t, e, i) {
                                var s;
                                return 0 === t.length || ((s = t.slice()).push(e), a(t, i) >= a(s, i))
                            }(e, l = t[0], o) ? (e.push(l), i(t.slice(1), e, s, r)) : (c = s.cutArea(n(e), r), r.push(s.getCoordinates(e)), i(t, [], c, r)), r;
                        r.push(s.getCoordinates(e))
                    }

                    function a(t, e) {
                        var i = Math.min.apply(Math, t),
                            a = Math.max.apply(Math, t),
                            s = n(t);
                        return Math.max(Math.pow(e, 2) * a / Math.pow(s, 2), Math.pow(s, 2) / (Math.pow(e, 2) * i))
                    }

                    function s(t) {
                        return t && t.constructor === Array
                    }

                    function n(t) {
                        var e, i = 0;
                        for (e = 0; e < t.length; e++) i += t[e];
                        return i
                    }

                    function r(t) {
                        var e, i = 0;
                        if (s(t[0]))
                            for (e = 0; e < t.length; e++) i += r(t[e]);
                        else i = n(t);
                        return i
                    }
                    return function t(i, a, n, o, l) {
                        o = void 0 === o ? 0 : o, l = void 0 === l ? 0 : l;
                        var c, h, d = [],
                            u = [];
                        if (s(i[0])) {
                            for (h = 0; h < i.length; h++) d[h] = r(i[h]);
                            for (c = e(d, a, n, o, l), h = 0; h < i.length; h++) u.push(t(i[h], c[h][2] - c[h][0], c[h][3] - c[h][1], c[h][0], c[h][1]))
                        } else u = e(i, a, n, o, l);
                        return u
                    }
                }();
                var zt, Dt, Xt = function() {
                        function t(e, i) {
                            o(this, t), this.ctx = e, this.w = e.w, this.strokeWidth = this.w.config.stroke.width, this.helpers = new At(e), this.dynamicAnim = this.w.config.chart.animations.dynamicAnimation, this.labels = []
                        }
                        return c(t, [{
                            key: "draw",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = new S(this.ctx),
                                    s = new I(this.ctx),
                                    n = a.group({
                                        class: "apexcharts-treemap"
                                    });
                                if (i.globals.noData) return n;
                                var r = [];
                                return t.forEach((function(t) {
                                    var e = t.map((function(t) {
                                        return Math.abs(t)
                                    }));
                                    r.push(e)
                                })), this.negRange = this.helpers.checkColorRange(), i.config.series.forEach((function(t, i) {
                                    t.data.forEach((function(t) {
                                        Array.isArray(e.labels[i]) || (e.labels[i] = []), e.labels[i].push(t.x)
                                    }))
                                })), window.TreemapSquared.generate(r, i.globals.gridWidth, i.globals.gridHeight).forEach((function(r, o) {
                                    var l = a.group({
                                        class: "apexcharts-series apexcharts-treemap-series",
                                        seriesName: b.escapeString(i.globals.seriesNames[o]),
                                        rel: o + 1,
                                        "data:realIndex": o
                                    });
                                    if (i.config.chart.dropShadow.enabled) {
                                        var c = i.config.chart.dropShadow;
                                        new w(e.ctx).dropShadow(n, c, o)
                                    }
                                    var h = a.group({
                                        class: "apexcharts-data-labels"
                                    });
                                    r.forEach((function(n, r) {
                                        var c = n[0],
                                            h = n[1],
                                            d = n[2],
                                            u = n[3],
                                            p = a.drawRect(c, h, d - c, u - h, 0, "#fff", 1, e.strokeWidth, i.config.plotOptions.treemap.useFillColorAsStroke ? f : i.globals.stroke.colors[o]);
                                        p.attr({
                                            cx: c,
                                            cy: h,
                                            index: o,
                                            i: o,
                                            j: r,
                                            width: d - c,
                                            height: u - h
                                        });
                                        var g = e.helpers.getShadeColor(i.config.chart.type, o, r, e.negRange),
                                            f = g.color;
                                        void 0 !== i.config.series[o].data[r] && i.config.series[o].data[r].fillColor && (f = i.config.series[o].data[r].fillColor);
                                        var m = s.fillPath({
                                            color: f,
                                            seriesNumber: o,
                                            dataPointIndex: r
                                        });
                                        p.node.classList.add("apexcharts-treemap-rect"), p.attr({
                                            fill: m
                                        }), e.helpers.addListeners(p);
                                        var x = {
                                                x: c + (d - c) / 2,
                                                y: h + (u - h) / 2,
                                                width: 0,
                                                height: 0
                                            },
                                            v = {
                                                x: c,
                                                y: h,
                                                width: d - c,
                                                height: u - h
                                            };
                                        if (i.config.chart.animations.enabled && !i.globals.dataChanged) {
                                            var b = 1;
                                            i.globals.resized || (b = i.config.chart.animations.speed), e.animateTreemap(p, x, v, b)
                                        }
                                        if (i.globals.dataChanged) {
                                            var y = 1;
                                            e.dynamicAnim.enabled && i.globals.shouldAnimate && (y = e.dynamicAnim.speed, i.globals.previousPaths[o] && i.globals.previousPaths[o][r] && i.globals.previousPaths[o][r].rect && (x = i.globals.previousPaths[o][r].rect), e.animateTreemap(p, x, v, y))
                                        }
                                        var w = e.getFontSize(n),
                                            S = i.config.dataLabels.formatter(e.labels[o][r], {
                                                value: i.globals.series[o][r],
                                                seriesIndex: o,
                                                dataPointIndex: r,
                                                w: i
                                            }),
                                            C = e.helpers.calculateDataLabels({
                                                text: S,
                                                x: (c + d) / 2,
                                                y: (h + u) / 2 + e.strokeWidth / 2 + w / 3,
                                                i: o,
                                                j: r,
                                                colorProps: g,
                                                fontSize: w,
                                                series: t
                                            });
                                        i.config.dataLabels.enabled && C && e.rotateToFitLabel(C, w, S, c, h, d, u), l.add(p), null !== C && l.add(C)
                                    })), l.add(h), n.add(l)
                                })), n
                            }
                        }, {
                            key: "getFontSize",
                            value: function(t) {
                                var e, i, a = this.w,
                                    s = function t(e) {
                                        var i, a = 0;
                                        if (Array.isArray(e[0]))
                                            for (i = 0; i < e.length; i++) a += t(e[i]);
                                        else
                                            for (i = 0; i < e.length; i++) a += e[i].length;
                                        return a
                                    }(this.labels) / function t(e) {
                                        var i, a = 0;
                                        if (Array.isArray(e[0]))
                                            for (i = 0; i < e.length; i++) a += t(e[i]);
                                        else
                                            for (i = 0; i < e.length; i++) a += 1;
                                        return a
                                    }(this.labels);
                                return e = (t[2] - t[0]) * (t[3] - t[1]), i = Math.pow(e, .5), Math.min(i / s, parseInt(a.config.dataLabels.style.fontSize, 10))
                            }
                        }, {
                            key: "rotateToFitLabel",
                            value: function(t, e, i, a, s, n, r) {
                                var o = new S(this.ctx),
                                    l = o.getTextRects(i, e);
                                if (l.width + this.w.config.stroke.width + 5 > n - a && l.width <= r - s) {
                                    var c = o.rotateAroundCenter(t.node);
                                    t.node.setAttribute("transform", "rotate(-90 ".concat(c.x, " ").concat(c.y, ")"))
                                }
                            }
                        }, {
                            key: "animateTreemap",
                            value: function(t, e, i, a) {
                                var s = new y(this.ctx);
                                s.animateRect(t, {
                                    x: e.x,
                                    y: e.y,
                                    width: e.width,
                                    height: e.height
                                }, {
                                    x: i.x,
                                    y: i.y,
                                    width: i.width,
                                    height: i.height
                                }, a, (function() {
                                    s.animationCompleted(t)
                                }))
                            }
                        }]), t
                    }(),
                    Ot = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w, this.timeScaleArray = [], this.utc = this.w.config.xaxis.labels.datetimeUTC
                        }
                        return c(t, [{
                            key: "calculateTimeScaleTicks",
                            value: function(t, e) {
                                var i = this,
                                    a = this.w;
                                if (a.globals.allSeriesCollapsed) return a.globals.labels = [], a.globals.timescaleLabels = [], [];
                                var s = new F(this.ctx),
                                    r = (e - t) / 864e5;
                                this.determineInterval(r), a.globals.disableZoomIn = !1, a.globals.disableZoomOut = !1, r < .00011574074074074075 ? a.globals.disableZoomIn = !0 : r > 5e4 && (a.globals.disableZoomOut = !0);
                                var o = s.getTimeUnitsfromTimestamp(t, e, this.utc),
                                    l = a.globals.gridWidth / r,
                                    c = l / 24,
                                    h = c / 60,
                                    d = h / 60,
                                    u = Math.floor(24 * r),
                                    p = Math.floor(1440 * r),
                                    g = Math.floor(86400 * r),
                                    f = Math.floor(r),
                                    m = Math.floor(r / 30),
                                    x = Math.floor(r / 365),
                                    v = {
                                        minMillisecond: o.minMillisecond,
                                        minSecond: o.minSecond,
                                        minMinute: o.minMinute,
                                        minHour: o.minHour,
                                        minDate: o.minDate,
                                        minMonth: o.minMonth,
                                        minYear: o.minYear
                                    },
                                    b = {
                                        firstVal: v,
                                        currentMillisecond: v.minMillisecond,
                                        currentSecond: v.minSecond,
                                        currentMinute: v.minMinute,
                                        currentHour: v.minHour,
                                        currentMonthDate: v.minDate,
                                        currentDate: v.minDate,
                                        currentMonth: v.minMonth,
                                        currentYear: v.minYear,
                                        daysWidthOnXAxis: l,
                                        hoursWidthOnXAxis: c,
                                        minutesWidthOnXAxis: h,
                                        secondsWidthOnXAxis: d,
                                        numberOfSeconds: g,
                                        numberOfMinutes: p,
                                        numberOfHours: u,
                                        numberOfDays: f,
                                        numberOfMonths: m,
                                        numberOfYears: x
                                    };
                                switch (this.tickInterval) {
                                    case "years":
                                        this.generateYearScale(b);
                                        break;
                                    case "months":
                                    case "half_year":
                                        this.generateMonthScale(b);
                                        break;
                                    case "months_days":
                                    case "months_fortnight":
                                    case "days":
                                    case "week_days":
                                        this.generateDayScale(b);
                                        break;
                                    case "hours":
                                        this.generateHourScale(b);
                                        break;
                                    case "minutes_fives":
                                    case "minutes":
                                        this.generateMinuteScale(b);
                                        break;
                                    case "seconds_tens":
                                    case "seconds_fives":
                                    case "seconds":
                                        this.generateSecondScale(b)
                                }
                                var y = this.timeScaleArray.map((function(t) {
                                    var e = {
                                        position: t.position,
                                        unit: t.unit,
                                        year: t.year,
                                        day: t.day ? t.day : 1,
                                        hour: t.hour ? t.hour : 0,
                                        month: t.month + 1
                                    };
                                    return "month" === t.unit ? n(n({}, e), {}, {
                                        day: 1,
                                        value: t.value + 1
                                    }) : "day" === t.unit || "hour" === t.unit ? n(n({}, e), {}, {
                                        value: t.value
                                    }) : "minute" === t.unit ? n(n({}, e), {}, {
                                        value: t.value,
                                        minute: t.value
                                    }) : "second" === t.unit ? n(n({}, e), {}, {
                                        value: t.value,
                                        minute: t.minute,
                                        second: t.second
                                    }) : t
                                }));
                                return y.filter((function(t) {
                                    var e = 1,
                                        s = Math.ceil(a.globals.gridWidth / 120),
                                        n = t.value;
                                    void 0 !== a.config.xaxis.tickAmount && (s = a.config.xaxis.tickAmount), y.length > s && (e = Math.floor(y.length / s));
                                    var r = !1,
                                        o = !1;
                                    switch (i.tickInterval) {
                                        case "years":
                                            "year" === t.unit && (r = !0);
                                            break;
                                        case "half_year":
                                            e = 7, "year" === t.unit && (r = !0);
                                            break;
                                        case "months":
                                            e = 1, "year" === t.unit && (r = !0);
                                            break;
                                        case "months_fortnight":
                                            e = 15, "year" !== t.unit && "month" !== t.unit || (r = !0), 30 === n && (o = !0);
                                            break;
                                        case "months_days":
                                            e = 10, "month" === t.unit && (r = !0), 30 === n && (o = !0);
                                            break;
                                        case "week_days":
                                            e = 8, "month" === t.unit && (r = !0);
                                            break;
                                        case "days":
                                            e = 1, "month" === t.unit && (r = !0);
                                            break;
                                        case "hours":
                                            "day" === t.unit && (r = !0);
                                            break;
                                        case "minutes_fives":
                                        case "seconds_fives":
                                            n % 5 != 0 && (o = !0);
                                            break;
                                        case "seconds_tens":
                                            n % 10 != 0 && (o = !0)
                                    }
                                    if ("hours" === i.tickInterval || "minutes_fives" === i.tickInterval || "seconds_tens" === i.tickInterval || "seconds_fives" === i.tickInterval) {
                                        if (!o) return !0
                                    } else if ((n % e == 0 || r) && !o) return !0
                                }))
                            }
                        }, {
                            key: "recalcDimensionsBasedOnFormat",
                            value: function(t, e) {
                                var i = this.w,
                                    a = this.formatDates(t),
                                    s = this.removeOverlappingTS(a);
                                i.globals.timescaleLabels = s.slice(), new dt(this.ctx).plotCoords()
                            }
                        }, {
                            key: "determineInterval",
                            value: function(t) {
                                var e = 24 * t,
                                    i = 60 * e;
                                switch (!0) {
                                    case t / 365 > 5:
                                        this.tickInterval = "years";
                                        break;
                                    case t > 800:
                                        this.tickInterval = "half_year";
                                        break;
                                    case t > 180:
                                        this.tickInterval = "months";
                                        break;
                                    case t > 90:
                                        this.tickInterval = "months_fortnight";
                                        break;
                                    case t > 60:
                                        this.tickInterval = "months_days";
                                        break;
                                    case t > 30:
                                        this.tickInterval = "week_days";
                                        break;
                                    case t > 2:
                                        this.tickInterval = "days";
                                        break;
                                    case e > 2.4:
                                        this.tickInterval = "hours";
                                        break;
                                    case i > 15:
                                        this.tickInterval = "minutes_fives";
                                        break;
                                    case i > 5:
                                        this.tickInterval = "minutes";
                                        break;
                                    case i > 1:
                                        this.tickInterval = "seconds_tens";
                                        break;
                                    case 60 * i > 20:
                                        this.tickInterval = "seconds_fives";
                                        break;
                                    default:
                                        this.tickInterval = "seconds"
                                }
                            }
                        }, {
                            key: "generateYearScale",
                            value: function(t) {
                                var e = t.firstVal,
                                    i = t.currentMonth,
                                    a = t.currentYear,
                                    s = t.daysWidthOnXAxis,
                                    n = t.numberOfYears,
                                    r = e.minYear,
                                    o = 0,
                                    l = new F(this.ctx),
                                    c = "year";
                                if (e.minDate > 1 || e.minMonth > 0) {
                                    var h = l.determineRemainingDaysOfYear(e.minYear, e.minMonth, e.minDate);
                                    o = (l.determineDaysOfYear(e.minYear) - h + 1) * s, r = e.minYear + 1, this.timeScaleArray.push({
                                        position: o,
                                        value: r,
                                        unit: c,
                                        year: r,
                                        month: b.monthMod(i + 1)
                                    })
                                } else 1 === e.minDate && 0 === e.minMonth && this.timeScaleArray.push({
                                    position: o,
                                    value: r,
                                    unit: c,
                                    year: a,
                                    month: b.monthMod(i + 1)
                                });
                                for (var d = r, u = o, p = 0; p < n; p++) d++, u = l.determineDaysOfYear(d - 1) * s + u, this.timeScaleArray.push({
                                    position: u,
                                    value: d,
                                    unit: c,
                                    year: d,
                                    month: 1
                                })
                            }
                        }, {
                            key: "generateMonthScale",
                            value: function(t) {
                                var e = t.firstVal,
                                    i = t.currentMonthDate,
                                    a = t.currentMonth,
                                    s = t.currentYear,
                                    n = t.daysWidthOnXAxis,
                                    r = t.numberOfMonths,
                                    o = a,
                                    l = 0,
                                    c = new F(this.ctx),
                                    h = "month",
                                    d = 0;
                                if (e.minDate > 1) {
                                    l = (c.determineDaysOfMonths(a + 1, e.minYear) - i + 1) * n, o = b.monthMod(a + 1);
                                    var u = s + d,
                                        p = b.monthMod(o),
                                        g = o;
                                    0 === o && (h = "year", g = u, p = 1, u += d += 1), this.timeScaleArray.push({
                                        position: l,
                                        value: g,
                                        unit: h,
                                        year: u,
                                        month: p
                                    })
                                } else this.timeScaleArray.push({
                                    position: l,
                                    value: o,
                                    unit: h,
                                    year: s,
                                    month: b.monthMod(a)
                                });
                                for (var f = o + 1, m = l, x = 0, v = 1; x < r; x++, v++) {
                                    0 === (f = b.monthMod(f)) ? (h = "year", d += 1) : h = "month";
                                    var y = this._getYear(s, f, d);
                                    m = c.determineDaysOfMonths(f, y) * n + m;
                                    var w = 0 === f ? y : f;
                                    this.timeScaleArray.push({
                                        position: m,
                                        value: w,
                                        unit: h,
                                        year: y,
                                        month: 0 === f ? 1 : f
                                    }), f++
                                }
                            }
                        }, {
                            key: "generateDayScale",
                            value: function(t) {
                                var e = t.firstVal,
                                    i = t.currentMonth,
                                    a = t.currentYear,
                                    s = t.hoursWidthOnXAxis,
                                    n = t.numberOfDays,
                                    r = new F(this.ctx),
                                    o = "day",
                                    l = e.minDate + 1,
                                    c = l,
                                    h = function(t, e, i) {
                                        return t > r.determineDaysOfMonths(e + 1, i) ? (c = 1, o = "month", u = e += 1, e) : e
                                    },
                                    d = (24 - e.minHour) * s,
                                    u = l,
                                    p = h(c, i, a);
                                0 === e.minHour && 1 === e.minDate ? (d = 0, u = b.monthMod(e.minMonth), o = "month", c = e.minDate, n++) : 1 !== e.minDate && 0 === e.minHour && 0 === e.minMinute && (d = 0, l = e.minDate, u = l, p = h(c = l, i, a)), this.timeScaleArray.push({
                                    position: d,
                                    value: u,
                                    unit: o,
                                    year: this._getYear(a, p, 0),
                                    month: b.monthMod(p),
                                    day: c
                                });
                                for (var g = d, f = 0; f < n; f++) {
                                    o = "day", p = h(c += 1, p, this._getYear(a, p, 0));
                                    var m = this._getYear(a, p, 0);
                                    g = 24 * s + g;
                                    var x = 1 === c ? b.monthMod(p) : c;
                                    this.timeScaleArray.push({
                                        position: g,
                                        value: x,
                                        unit: o,
                                        year: m,
                                        month: b.monthMod(p),
                                        day: x
                                    })
                                }
                            }
                        }, {
                            key: "generateHourScale",
                            value: function(t) {
                                var e = t.firstVal,
                                    i = t.currentDate,
                                    a = t.currentMonth,
                                    s = t.currentYear,
                                    n = t.minutesWidthOnXAxis,
                                    r = t.numberOfHours,
                                    o = new F(this.ctx),
                                    l = "hour",
                                    c = function(t, e) {
                                        return t > o.determineDaysOfMonths(e + 1, s) && (f = 1, e += 1), {
                                            month: e,
                                            date: f
                                        }
                                    },
                                    h = function(t, e) {
                                        return t > o.determineDaysOfMonths(e + 1, s) ? e += 1 : e
                                    },
                                    d = 60 - (e.minMinute + e.minSecond / 60),
                                    u = d * n,
                                    p = e.minHour + 1,
                                    g = p + 1;
                                60 === d && (u = 0, g = (p = e.minHour) + 1);
                                var f = i,
                                    m = h(f, a);
                                this.timeScaleArray.push({
                                    position: u,
                                    value: p,
                                    unit: l,
                                    day: f,
                                    hour: g,
                                    year: s,
                                    month: b.monthMod(m)
                                });
                                for (var x = u, v = 0; v < r; v++) {
                                    l = "hour", g >= 24 && (g = 0, l = "day", m = c(f += 1, m).month, m = h(f, m));
                                    var y = this._getYear(s, m, 0);
                                    x = 0 === g && 0 === v ? d * n : 60 * n + x;
                                    var w = 0 === g ? f : g;
                                    this.timeScaleArray.push({
                                        position: x,
                                        value: w,
                                        unit: l,
                                        hour: g,
                                        day: f,
                                        year: y,
                                        month: b.monthMod(m)
                                    }), g++
                                }
                            }
                        }, {
                            key: "generateMinuteScale",
                            value: function(t) {
                                for (var e = t.currentMillisecond, i = t.currentSecond, a = t.currentMinute, s = t.currentHour, n = t.currentDate, r = t.currentMonth, o = t.currentYear, l = t.minutesWidthOnXAxis, c = t.secondsWidthOnXAxis, h = t.numberOfMinutes, d = a + 1, u = n, p = r, g = o, f = s, m = (60 - i - e / 1e3) * c, x = 0; x < h; x++) d >= 60 && (d = 0, 24 === (f += 1) && (f = 0)), this.timeScaleArray.push({
                                    position: m,
                                    value: d,
                                    unit: "minute",
                                    hour: f,
                                    minute: d,
                                    day: u,
                                    year: this._getYear(g, p, 0),
                                    month: b.monthMod(p)
                                }), m += l, d++
                            }
                        }, {
                            key: "generateSecondScale",
                            value: function(t) {
                                for (var e = t.currentMillisecond, i = t.currentSecond, a = t.currentMinute, s = t.currentHour, n = t.currentDate, r = t.currentMonth, o = t.currentYear, l = t.secondsWidthOnXAxis, c = t.numberOfSeconds, h = i + 1, d = a, u = n, p = r, g = o, f = s, m = (1e3 - e) / 1e3 * l, x = 0; x < c; x++) h >= 60 && (h = 0, ++d >= 60 && (d = 0, 24 == ++f && (f = 0))), this.timeScaleArray.push({
                                    position: m,
                                    value: h,
                                    unit: "second",
                                    hour: f,
                                    minute: d,
                                    second: h,
                                    day: u,
                                    year: this._getYear(g, p, 0),
                                    month: b.monthMod(p)
                                }), m += l, h++
                            }
                        }, {
                            key: "createRawDateString",
                            value: function(t, e) {
                                var i = t.year;
                                return 0 === t.month && (t.month = 1), i += "-" + ("0" + t.month.toString()).slice(-2), "day" === t.unit ? i += "day" === t.unit ? "-" + ("0" + e).slice(-2) : "-01" : i += "-" + ("0" + (t.day ? t.day : "1")).slice(-2), "hour" === t.unit ? i += "hour" === t.unit ? "T" + ("0" + e).slice(-2) : "T00" : i += "T" + ("0" + (t.hour ? t.hour : "0")).slice(-2), "minute" === t.unit ? i += ":" + ("0" + e).slice(-2) : i += ":" + (t.minute ? ("0" + t.minute).slice(-2) : "00"), "second" === t.unit ? i += ":" + ("0" + e).slice(-2) : i += ":00", this.utc && (i += ".000Z"), i
                            }
                        }, {
                            key: "formatDates",
                            value: function(t) {
                                var e = this,
                                    i = this.w;
                                return t.map((function(t) {
                                    var a = t.value.toString(),
                                        s = new F(e.ctx),
                                        n = e.createRawDateString(t, a),
                                        r = s.getDate(s.parseDate(n));
                                    if (e.utc || (r = s.getDate(s.parseDateWithTimezone(n))), void 0 === i.config.xaxis.labels.format) {
                                        var o = "dd MMM",
                                            l = i.config.xaxis.labels.datetimeFormatter;
                                        "year" === t.unit && (o = l.year), "month" === t.unit && (o = l.month), "day" === t.unit && (o = l.day), "hour" === t.unit && (o = l.hour), "minute" === t.unit && (o = l.minute), "second" === t.unit && (o = l.second), a = s.formatDate(r, o)
                                    } else a = s.formatDate(r, i.config.xaxis.labels.format);
                                    return {
                                        dateString: n,
                                        position: t.position,
                                        value: a,
                                        unit: t.unit,
                                        year: t.year,
                                        month: t.month
                                    }
                                }))
                            }
                        }, {
                            key: "removeOverlappingTS",
                            value: function(t) {
                                var e, i = this,
                                    a = new S(this.ctx),
                                    s = !1;
                                t.length > 0 && t[0].value && t.every((function(e) {
                                    return e.value.length === t[0].value.length
                                })) && (s = !0, e = a.getTextRects(t[0].value).width);
                                var n = 0,
                                    r = t.map((function(r, o) {
                                        if (o > 0 && i.w.config.xaxis.labels.hideOverlappingLabels) {
                                            var l = s ? e : a.getTextRects(t[n].value).width,
                                                c = t[n].position;
                                            return r.position > c + l + 10 ? (n = o, r) : null
                                        }
                                        return r
                                    }));
                                return r.filter((function(t) {
                                    return null !== t
                                }))
                            }
                        }, {
                            key: "_getYear",
                            value: function(t, e, i) {
                                return t + Math.floor(e / 12) + i
                            }
                        }]), t
                    }(),
                    Nt = function() {
                        function t(e, i) {
                            o(this, t), this.ctx = i, this.w = i.w, this.el = e
                        }
                        return c(t, [{
                            key: "setupElements",
                            value: function() {
                                var t = this.w.globals,
                                    e = this.w.config,
                                    i = e.chart.type;
                                t.axisCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble", "radar", "heatmap", "treemap"].indexOf(i) > -1, t.xyCharts = ["line", "area", "bar", "rangeBar", "candlestick", "boxPlot", "scatter", "bubble"].indexOf(i) > -1, t.isBarHorizontal = ("bar" === e.chart.type || "rangeBar" === e.chart.type || "boxPlot" === e.chart.type) && e.plotOptions.bar.horizontal, t.chartClass = ".apexcharts" + t.chartID, t.dom.baseEl = this.el, t.dom.elWrap = document.createElement("div"), S.setAttrs(t.dom.elWrap, {
                                    id: t.chartClass.substring(1),
                                    class: "apexcharts-canvas " + t.chartClass.substring(1)
                                }), this.el.appendChild(t.dom.elWrap), t.dom.Paper = new window.SVG.Doc(t.dom.elWrap), t.dom.Paper.attr({
                                    class: "apexcharts-svg",
                                    "xmlns:data": "ApexChartsNS",
                                    transform: "translate(".concat(e.chart.offsetX, ", ").concat(e.chart.offsetY, ")")
                                }), t.dom.Paper.node.style.background = e.chart.background, this.setSVGDimensions(), t.dom.elGraphical = t.dom.Paper.group().attr({
                                    class: "apexcharts-inner apexcharts-graphical"
                                }), t.dom.elAnnotations = t.dom.Paper.group().attr({
                                    class: "apexcharts-annotations"
                                }), t.dom.elDefs = t.dom.Paper.defs(), t.dom.elLegendWrap = document.createElement("div"), t.dom.elLegendWrap.classList.add("apexcharts-legend"), t.dom.elWrap.appendChild(t.dom.elLegendWrap), t.dom.Paper.add(t.dom.elGraphical), t.dom.elGraphical.add(t.dom.elDefs)
                            }
                        }, {
                            key: "plotChartType",
                            value: function(t, e) {
                                var i = this.w,
                                    a = i.config,
                                    s = i.globals,
                                    n = {
                                        series: [],
                                        i: []
                                    },
                                    r = {
                                        series: [],
                                        i: []
                                    },
                                    o = {
                                        series: [],
                                        i: []
                                    },
                                    l = {
                                        series: [],
                                        i: []
                                    },
                                    c = {
                                        series: [],
                                        i: []
                                    },
                                    h = {
                                        series: [],
                                        i: []
                                    },
                                    d = {
                                        series: [],
                                        i: []
                                    };
                                s.series.map((function(e, u) {
                                    var p = 0;
                                    void 0 !== t[u].type ? ("column" === t[u].type || "bar" === t[u].type ? (s.series.length > 1 && a.plotOptions.bar.horizontal && console.warn("Horizontal bars are not supported in a mixed/combo chart. Please turn off `plotOptions.bar.horizontal`"), c.series.push(e), c.i.push(u), p++, i.globals.columnSeries = c.series) : "area" === t[u].type ? (r.series.push(e), r.i.push(u), p++) : "line" === t[u].type ? (n.series.push(e), n.i.push(u), p++) : "scatter" === t[u].type ? (o.series.push(e), o.i.push(u)) : "bubble" === t[u].type ? (l.series.push(e), l.i.push(u), p++) : "candlestick" === t[u].type ? (h.series.push(e), h.i.push(u), p++) : "boxPlot" === t[u].type ? (d.series.push(e), d.i.push(u), p++) : console.warn("You have specified an unrecognized chart type. Available types for this property are line/area/column/bar/scatter/bubble"), p > 1 && (s.comboCharts = !0)) : (n.series.push(e), n.i.push(u))
                                }));
                                var u = new _t(this.ctx, e),
                                    p = new kt(this.ctx, e);
                                this.ctx.pie = new Pt(this.ctx);
                                var g = new Lt(this.ctx);
                                this.ctx.rangeBar = new R(this.ctx, e);
                                var f = new Mt(this.ctx),
                                    m = [];
                                if (s.comboCharts) {
                                    if (r.series.length > 0 && m.push(u.draw(r.series, "area", r.i)), c.series.length > 0)
                                        if (i.config.chart.stacked) {
                                            var x = new Ct(this.ctx, e);
                                            m.push(x.draw(c.series, c.i))
                                        } else this.ctx.bar = new Y(this.ctx, e), m.push(this.ctx.bar.draw(c.series, c.i));
                                    if (n.series.length > 0 && m.push(u.draw(n.series, "line", n.i)), h.series.length > 0 && m.push(p.draw(h.series, h.i)), d.series.length > 0 && m.push(p.draw(d.series, d.i)), o.series.length > 0) {
                                        var v = new _t(this.ctx, e, !0);
                                        m.push(v.draw(o.series, "scatter", o.i))
                                    }
                                    if (l.series.length > 0) {
                                        var b = new _t(this.ctx, e, !0);
                                        m.push(b.draw(l.series, "bubble", l.i))
                                    }
                                } else switch (a.chart.type) {
                                    case "line":
                                        m = u.draw(s.series, "line");
                                        break;
                                    case "area":
                                        m = u.draw(s.series, "area");
                                        break;
                                    case "bar":
                                        a.chart.stacked ? m = new Ct(this.ctx, e).draw(s.series) : (this.ctx.bar = new Y(this.ctx, e), m = this.ctx.bar.draw(s.series));
                                        break;
                                    case "candlestick":
                                    case "boxPlot":
                                        m = new kt(this.ctx, e).draw(s.series);
                                        break;
                                    case "rangeBar":
                                        m = this.ctx.rangeBar.draw(s.series);
                                        break;
                                    case "heatmap":
                                        m = new Et(this.ctx, e).draw(s.series);
                                        break;
                                    case "treemap":
                                        m = new Xt(this.ctx, e).draw(s.series);
                                        break;
                                    case "pie":
                                    case "donut":
                                    case "polarArea":
                                        m = this.ctx.pie.draw(s.series);
                                        break;
                                    case "radialBar":
                                        m = g.draw(s.series);
                                        break;
                                    case "radar":
                                        m = f.draw(s.series);
                                        break;
                                    default:
                                        m = u.draw(s.series)
                                }
                                return m
                            }
                        }, {
                            key: "setSVGDimensions",
                            value: function() {
                                var t = this.w.globals,
                                    e = this.w.config;
                                t.svgWidth = e.chart.width, t.svgHeight = e.chart.height;
                                var i = b.getDimensions(this.el),
                                    a = e.chart.width.toString().split(/[0-9]+/g).pop();
                                "%" === a ? b.isNumber(i[0]) && (0 === i[0].width && (i = b.getDimensions(this.el.parentNode)), t.svgWidth = i[0] * parseInt(e.chart.width, 10) / 100) : "px" !== a && "" !== a || (t.svgWidth = parseInt(e.chart.width, 10));
                                var s = e.chart.height.toString().split(/[0-9]+/g).pop();
                                if ("auto" !== t.svgHeight && "" !== t.svgHeight)
                                    if ("%" === s) {
                                        var n = b.getDimensions(this.el.parentNode);
                                        t.svgHeight = n[1] * parseInt(e.chart.height, 10) / 100
                                    } else t.svgHeight = parseInt(e.chart.height, 10);
                                else t.axisCharts ? t.svgHeight = t.svgWidth / 1.61 : t.svgHeight = t.svgWidth / 1.2;
                                if (t.svgWidth < 0 && (t.svgWidth = 0), t.svgHeight < 0 && (t.svgHeight = 0), S.setAttrs(t.dom.Paper.node, {
                                        width: t.svgWidth,
                                        height: t.svgHeight
                                    }), "%" !== s) {
                                    var r = e.chart.sparkline.enabled ? 0 : t.axisCharts ? e.chart.parentHeightOffset : 0;
                                    t.dom.Paper.node.parentNode.parentNode.style.minHeight = t.svgHeight + r + "px"
                                }
                                t.dom.elWrap.style.width = t.svgWidth + "px", t.dom.elWrap.style.height = t.svgHeight + "px"
                            }
                        }, {
                            key: "shiftGraphPosition",
                            value: function() {
                                var t = this.w.globals,
                                    e = t.translateY,
                                    i = {
                                        transform: "translate(" + t.translateX + ", " + e + ")"
                                    };
                                S.setAttrs(t.dom.elGraphical.node, i)
                            }
                        }, {
                            key: "resizeNonAxisCharts",
                            value: function() {
                                var t = this.w,
                                    e = t.globals,
                                    i = 0,
                                    a = t.config.chart.sparkline.enabled ? 1 : 15;
                                a += t.config.grid.padding.bottom, "top" !== t.config.legend.position && "bottom" !== t.config.legend.position || !t.config.legend.show || t.config.legend.floating || (i = new pt(this.ctx).legendHelpers.getLegendBBox().clwh + 10);
                                var s = t.globals.dom.baseEl.querySelector(".apexcharts-radialbar, .apexcharts-pie"),
                                    n = 2.05 * t.globals.radialSize;
                                if (s && !t.config.chart.sparkline.enabled && 0 !== t.config.plotOptions.radialBar.startAngle) {
                                    var r = b.getBoundingClientRect(s);
                                    n = r.bottom;
                                    var o = r.bottom - r.top;
                                    n = Math.max(2.05 * t.globals.radialSize, o)
                                }
                                var l = n + e.translateY + i + a;
                                e.dom.elLegendForeign && e.dom.elLegendForeign.setAttribute("height", l), t.config.chart.height && String(t.config.chart.height).indexOf("%") > 0 || (e.dom.elWrap.style.height = l + "px", S.setAttrs(e.dom.Paper.node, {
                                    height: l
                                }), e.dom.Paper.node.parentNode.parentNode.style.minHeight = l + "px")
                            }
                        }, {
                            key: "coreCalculations",
                            value: function() {
                                new Q(this.ctx).init()
                            }
                        }, {
                            key: "resetGlobals",
                            value: function() {
                                var t = this,
                                    e = function() {
                                        return t.w.config.series.map((function(t) {
                                            return []
                                        }))
                                    },
                                    i = new B,
                                    a = this.w.globals;
                                i.initGlobalVars(a), a.seriesXvalues = e(), a.seriesYvalues = e()
                            }
                        }, {
                            key: "isMultipleY",
                            value: function() {
                                if (this.w.config.yaxis.constructor === Array && this.w.config.yaxis.length > 1) return this.w.globals.isMultipleYAxis = !0, !0
                            }
                        }, {
                            key: "xySettings",
                            value: function() {
                                var t = null,
                                    e = this.w;
                                if (e.globals.axisCharts) {
                                    if ("back" === e.config.xaxis.crosshairs.position && new at(this.ctx).drawXCrosshairs(), "back" === e.config.yaxis[0].crosshairs.position && new at(this.ctx).drawYCrosshairs(), "datetime" === e.config.xaxis.type && void 0 === e.config.xaxis.labels.formatter) {
                                        this.ctx.timeScale = new Ot(this.ctx);
                                        var i = [];
                                        isFinite(e.globals.minX) && isFinite(e.globals.maxX) && !e.globals.isBarHorizontal ? i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minX, e.globals.maxX) : e.globals.isBarHorizontal && (i = this.ctx.timeScale.calculateTimeScaleTicks(e.globals.minY, e.globals.maxY)), this.ctx.timeScale.recalcDimensionsBasedOnFormat(i)
                                    }
                                    t = new C(this.ctx).getCalculatedRatios()
                                }
                                return t
                            }
                        }, {
                            key: "updateSourceChart",
                            value: function(t) {
                                this.ctx.w.globals.selection = void 0, this.ctx.updateHelpers._updateOptions({
                                    chart: {
                                        selection: {
                                            xaxis: {
                                                min: t.w.globals.minX,
                                                max: t.w.globals.maxX
                                            }
                                        }
                                    }
                                }, !1, !1)
                            }
                        }, {
                            key: "setupBrushHandler",
                            value: function() {
                                var t = this,
                                    e = this.w;
                                if (e.config.chart.brush.enabled && "function" != typeof e.config.chart.events.selection) {
                                    var i = e.config.chart.brush.targets || [e.config.chart.brush.target];
                                    i.forEach((function(e) {
                                        var i = ApexCharts.getChartByID(e);
                                        i.w.globals.brushSource = t.ctx, "function" != typeof i.w.config.chart.events.zoomed && (i.w.config.chart.events.zoomed = function() {
                                            t.updateSourceChart(i)
                                        }), "function" != typeof i.w.config.chart.events.scrolled && (i.w.config.chart.events.scrolled = function() {
                                            t.updateSourceChart(i)
                                        })
                                    })), e.config.chart.events.selection = function(t, a) {
                                        i.forEach((function(t) {
                                            var i = ApexCharts.getChartByID(t),
                                                s = b.clone(e.config.yaxis);
                                            if (e.config.chart.brush.autoScaleYaxis && 1 === i.w.globals.series.length) {
                                                var r = new K(i);
                                                s = r.autoScaleY(i, s, a)
                                            }
                                            var o = i.w.config.yaxis.reduce((function(t, e, a) {
                                                return [].concat(m(t), [n(n({}, i.w.config.yaxis[a]), {}, {
                                                    min: s[0].min,
                                                    max: s[0].max
                                                })])
                                            }), []);
                                            i.ctx.updateHelpers._updateOptions({
                                                xaxis: {
                                                    min: a.xaxis.min,
                                                    max: a.xaxis.max
                                                },
                                                yaxis: o
                                            }, !1, !1, !1, !1)
                                        }))
                                    }
                                }
                            }
                        }]), t
                    }(),
                    Yt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "_updateOptions",
                            value: function(t) {
                                var e = this,
                                    i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                    a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                    s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                    n = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
                                return new Promise((function(o) {
                                    var l = [e.ctx];
                                    s && (l = e.ctx.getSyncedCharts()), e.ctx.w.globals.isExecCalled && (l = [e.ctx], e.ctx.w.globals.isExecCalled = !1), l.forEach((function(s, c) {
                                        var h = s.w;
                                        if (h.globals.shouldAnimate = a, i || (h.globals.resized = !0, h.globals.dataChanged = !0, a && s.series.getPreviousPaths()), t && "object" === r(t) && (s.config = new W(t), t = C.extendArrayProps(s.config, t, h), s.w.globals.chartID !== e.ctx.w.globals.chartID && delete t.series, h.config = b.extend(h.config, t), n && (h.globals.lastXAxis = t.xaxis ? b.clone(t.xaxis) : [], h.globals.lastYAxis = t.yaxis ? b.clone(t.yaxis) : [], h.globals.initialConfig = b.extend({}, h.config), h.globals.initialSeries = b.clone(h.config.series), t.series))) {
                                            for (var d = 0; d < h.globals.collapsedSeriesIndices.length; d++) {
                                                var u = h.config.series[h.globals.collapsedSeriesIndices[d]];
                                                h.globals.collapsedSeries[d].data = h.globals.axisCharts ? u.data.slice() : u
                                            }
                                            for (var p = 0; p < h.globals.ancillaryCollapsedSeriesIndices.length; p++) {
                                                var g = h.config.series[h.globals.ancillaryCollapsedSeriesIndices[p]];
                                                h.globals.ancillaryCollapsedSeries[p].data = h.globals.axisCharts ? g.data.slice() : g
                                            }
                                            s.series.emptyCollapsedSeries(h.config.series)
                                        }
                                        return s.update(t).then((function() {
                                            c === l.length - 1 && o(s)
                                        }))
                                    }))
                                }))
                            }
                        }, {
                            key: "_updateSeries",
                            value: function(t, e) {
                                var i = this,
                                    a = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                                return new Promise((function(s) {
                                    var n, r = i.w;
                                    return r.globals.shouldAnimate = e, r.globals.dataChanged = !0, e && i.ctx.series.getPreviousPaths(), r.globals.axisCharts ? (0 === (n = t.map((function(t, e) {
                                        return i._extendSeries(t, e)
                                    }))).length && (n = [{
                                        data: []
                                    }]), r.config.series = n) : r.config.series = t.slice(), a && (r.globals.initialConfig.series = b.clone(r.config.series), r.globals.initialSeries = b.clone(r.config.series)), i.ctx.update().then((function() {
                                        s(i.ctx)
                                    }))
                                }))
                            }
                        }, {
                            key: "_extendSeries",
                            value: function(t, e) {
                                var i = this.w,
                                    a = i.config.series[e];
                                return n(n({}, i.config.series[e]), {}, {
                                    name: t.name ? t.name : a && a.name,
                                    color: t.color ? t.color : a && a.color,
                                    type: t.type ? t.type : a && a.type,
                                    data: t.data ? t.data : a && a.data
                                })
                            }
                        }, {
                            key: "toggleDataPointSelection",
                            value: function(t, e) {
                                var i = this.w,
                                    a = null,
                                    s = ".apexcharts-series[data\\:realIndex='".concat(t, "']");
                                return i.globals.axisCharts ? a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(e, "'], ").concat(s, " circle[j='").concat(e, "'], ").concat(s, " rect[j='").concat(e, "']")).members[0] : void 0 === e && (a = i.globals.dom.Paper.select("".concat(s, " path[j='").concat(t, "']")).members[0], "pie" !== i.config.chart.type && "polarArea" !== i.config.chart.type && "donut" !== i.config.chart.type || this.ctx.pie.pieClicked(t)), a ? (new S(this.ctx).pathMouseDown(a, null), a.node ? a.node : null) : (console.warn("toggleDataPointSelection: Element not found"), null)
                            }
                        }, {
                            key: "forceXAxisUpdate",
                            value: function(t) {
                                var e = this.w;
                                if (["min", "max"].forEach((function(i) {
                                        void 0 !== t.xaxis[i] && (e.config.xaxis[i] = t.xaxis[i], e.globals.lastXAxis[i] = t.xaxis[i])
                                    })), t.xaxis.categories && t.xaxis.categories.length && (e.config.xaxis.categories = t.xaxis.categories), e.config.xaxis.convertedCatToNumeric) {
                                    var i = new H(t);
                                    t = i.convertCatToNumericXaxis(t, this.ctx)
                                }
                                return t
                            }
                        }, {
                            key: "forceYAxisUpdate",
                            value: function(t) {
                                return t.chart && t.chart.stacked && "100%" === t.chart.stackType && (Array.isArray(t.yaxis) ? t.yaxis.forEach((function(e, i) {
                                    t.yaxis[i].min = 0, t.yaxis[i].max = 100
                                })) : (t.yaxis.min = 0, t.yaxis.max = 100)), t
                            }
                        }, {
                            key: "revertDefaultAxisMinMax",
                            value: function(t) {
                                var e = this,
                                    i = this.w,
                                    a = i.globals.lastXAxis,
                                    s = i.globals.lastYAxis;
                                t && t.xaxis && (a = t.xaxis), t && t.yaxis && (s = t.yaxis), i.config.xaxis.min = a.min, i.config.xaxis.max = a.max;
                                i.config.yaxis.map((function(t, a) {
                                    i.globals.zoomed || void 0 !== s[a] ? function(t) {
                                        void 0 !== s[t] && (i.config.yaxis[t].min = s[t].min, i.config.yaxis[t].max = s[t].max)
                                    }(a) : void 0 !== e.ctx.opts.yaxis[a] && (t.min = e.ctx.opts.yaxis[a].min, t.max = e.ctx.opts.yaxis[a].max)
                                }))
                            }
                        }]), t
                    }();
                zt = "undefined" != typeof window ? window : void 0, Dt = function(t, e) {
                        var i = (void 0 !== this ? this : t).SVG = function(t) {
                            if (i.supported) return t = new i.Doc(t), i.parser.draw || i.prepare(), t
                        };
                        if (i.ns = "http://www.w3.org/2000/svg", i.xmlns = "http://www.w3.org/2000/xmlns/", i.xlink = "http://www.w3.org/1999/xlink", i.svgjs = "http://svgjs.dev", i.supported = !0, !i.supported) return !1;
                        i.did = 1e3, i.eid = function(t) {
                            return "Svgjs" + d(t) + i.did++
                        }, i.create = function(t) {
                            var i = e.createElementNS(this.ns, t);
                            return i.setAttribute("id", this.eid(t)), i
                        }, i.extend = function() {
                            var t, e;
                            e = (t = [].slice.call(arguments)).pop();
                            for (var a = t.length - 1; a >= 0; a--)
                                if (t[a])
                                    for (var s in e) t[a].prototype[s] = e[s];
                            i.Set && i.Set.inherit && i.Set.inherit()
                        }, i.invent = function(t) {
                            var e = "function" == typeof t.create ? t.create : function() {
                                this.constructor.call(this, i.create(t.create))
                            };
                            return t.inherit && (e.prototype = new t.inherit), t.extend && i.extend(e, t.extend), t.construct && i.extend(t.parent || i.Container, t.construct), e
                        }, i.adopt = function(e) {
                            return e ? e.instance ? e.instance : ((a = "svg" == e.nodeName ? e.parentNode instanceof t.SVGElement ? new i.Nested : new i.Doc : "linearGradient" == e.nodeName ? new i.Gradient("linear") : "radialGradient" == e.nodeName ? new i.Gradient("radial") : i[d(e.nodeName)] ? new(i[d(e.nodeName)]) : new i.Element(e)).type = e.nodeName, a.node = e, e.instance = a, a instanceof i.Doc && a.namespace().defs(), a.setData(JSON.parse(e.getAttribute("svgjs:data")) || {}), a) : null;
                            var a
                        }, i.prepare = function() {
                            var t = e.getElementsByTagName("body")[0],
                                a = (t ? new i.Doc(t) : i.adopt(e.documentElement).nested()).size(2, 0);
                            i.parser = {
                                body: t || e.documentElement,
                                draw: a.style("opacity:0;position:absolute;left:-100%;top:-100%;overflow:hidden").node,
                                poly: a.polyline().node,
                                path: a.path().node,
                                native: i.create("svg")
                            }
                        }, i.parser = {
                            native: i.create("svg")
                        }, e.addEventListener("DOMContentLoaded", (function() {
                            i.parser.draw || i.prepare()
                        }), !1), i.regex = {
                            numberAndUnit: /^([+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?)([a-z%]*)$/i,
                            hex: /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,
                            rgb: /rgb\((\d+),(\d+),(\d+)\)/,
                            reference: /#([a-z0-9\-_]+)/i,
                            transforms: /\)\s*,?\s*/,
                            whitespace: /\s/g,
                            isHex: /^#[a-f0-9]{3,6}$/i,
                            isRgb: /^rgb\(/,
                            isCss: /[^:]+:[^;]+;?/,
                            isBlank: /^(\s+)?$/,
                            isNumber: /^[+-]?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,
                            isPercent: /^-?[\d\.]+%$/,
                            isImage: /\.(jpg|jpeg|png|gif|svg)(\?[^=]+.*)?/i,
                            delimiter: /[\s,]+/,
                            hyphen: /([^e])\-/gi,
                            pathLetters: /[MLHVCSQTAZ]/gi,
                            isPathLetter: /[MLHVCSQTAZ]/i,
                            numbersWithDots: /((\d?\.\d+(?:e[+-]?\d+)?)((?:\.\d+(?:e[+-]?\d+)?)+))+/gi,
                            dots: /\./g
                        }, i.utils = {
                            map: function(t, e) {
                                for (var i = t.length, a = [], s = 0; s < i; s++) a.push(e(t[s]));
                                return a
                            },
                            filter: function(t, e) {
                                for (var i = t.length, a = [], s = 0; s < i; s++) e(t[s]) && a.push(t[s]);
                                return a
                            },
                            filterSVGElements: function(e) {
                                return this.filter(e, (function(e) {
                                    return e instanceof t.SVGElement
                                }))
                            }
                        }, i.defaults = {
                            attrs: {
                                "fill-opacity": 1,
                                "stroke-opacity": 1,
                                "stroke-width": 0,
                                "stroke-linejoin": "miter",
                                "stroke-linecap": "butt",
                                fill: "#000000",
                                stroke: "#000000",
                                opacity: 1,
                                x: 0,
                                y: 0,
                                cx: 0,
                                cy: 0,
                                width: 0,
                                height: 0,
                                r: 0,
                                rx: 0,
                                ry: 0,
                                offset: 0,
                                "stop-opacity": 1,
                                "stop-color": "#000000",
                                "font-size": 16,
                                "font-family": "Helvetica, Arial, sans-serif",
                                "text-anchor": "start"
                            }
                        }, i.Color = function(t) {
                            var e, a;
                            this.r = 0, this.g = 0, this.b = 0, t && ("string" == typeof t ? i.regex.isRgb.test(t) ? (e = i.regex.rgb.exec(t.replace(i.regex.whitespace, "")), this.r = parseInt(e[1]), this.g = parseInt(e[2]), this.b = parseInt(e[3])) : i.regex.isHex.test(t) && (e = i.regex.hex.exec(4 == (a = t).length ? ["#", a.substring(1, 2), a.substring(1, 2), a.substring(2, 3), a.substring(2, 3), a.substring(3, 4), a.substring(3, 4)].join("") : a), this.r = parseInt(e[1], 16), this.g = parseInt(e[2], 16), this.b = parseInt(e[3], 16)) : "object" === r(t) && (this.r = t.r, this.g = t.g, this.b = t.b))
                        }, i.extend(i.Color, {
                            toString: function() {
                                return this.toHex()
                            },
                            toHex: function() {
                                return "#" + u(this.r) + u(this.g) + u(this.b)
                            },
                            toRgb: function() {
                                return "rgb(" + [this.r, this.g, this.b].join() + ")"
                            },
                            brightness: function() {
                                return this.r / 255 * .3 + this.g / 255 * .59 + this.b / 255 * .11
                            },
                            morph: function(t) {
                                return this.destination = new i.Color(t), this
                            },
                            at: function(t) {
                                return this.destination ? (t = t < 0 ? 0 : t > 1 ? 1 : t, new i.Color({
                                    r: ~~(this.r + (this.destination.r - this.r) * t),
                                    g: ~~(this.g + (this.destination.g - this.g) * t),
                                    b: ~~(this.b + (this.destination.b - this.b) * t)
                                })) : this
                            }
                        }), i.Color.test = function(t) {
                            return t += "", i.regex.isHex.test(t) || i.regex.isRgb.test(t)
                        }, i.Color.isRgb = function(t) {
                            return t && "number" == typeof t.r && "number" == typeof t.g && "number" == typeof t.b
                        }, i.Color.isColor = function(t) {
                            return i.Color.isRgb(t) || i.Color.test(t)
                        }, i.Array = function(t, e) {
                            0 == (t = (t || []).valueOf()).length && e && (t = e.valueOf()), this.value = this.parse(t)
                        }, i.extend(i.Array, {
                            toString: function() {
                                return this.value.join(" ")
                            },
                            valueOf: function() {
                                return this.value
                            },
                            parse: function(t) {
                                return t = t.valueOf(), Array.isArray(t) ? t : this.split(t)
                            }
                        }), i.PointArray = function(t, e) {
                            i.Array.call(this, t, e || [
                                [0, 0]
                            ])
                        }, i.PointArray.prototype = new i.Array, i.PointArray.prototype.constructor = i.PointArray;
                        for (var a = {
                                M: function(t, e, i) {
                                    return e.x = i.x = t[0], e.y = i.y = t[1], ["M", e.x, e.y]
                                },
                                L: function(t, e) {
                                    return e.x = t[0], e.y = t[1], ["L", t[0], t[1]]
                                },
                                H: function(t, e) {
                                    return e.x = t[0], ["H", t[0]]
                                },
                                V: function(t, e) {
                                    return e.y = t[0], ["V", t[0]]
                                },
                                C: function(t, e) {
                                    return e.x = t[4], e.y = t[5], ["C", t[0], t[1], t[2], t[3], t[4], t[5]]
                                },
                                Q: function(t, e) {
                                    return e.x = t[2], e.y = t[3], ["Q", t[0], t[1], t[2], t[3]]
                                },
                                Z: function(t, e, i) {
                                    return e.x = i.x, e.y = i.y, ["Z"]
                                }
                            }, s = "mlhvqtcsaz".split(""), n = 0, o = s.length; n < o; ++n) a[s[n]] = function(t) {
                            return function(e, i, s) {
                                if ("H" == t) e[0] = e[0] + i.x;
                                else if ("V" == t) e[0] = e[0] + i.y;
                                else if ("A" == t) e[5] = e[5] + i.x, e[6] = e[6] + i.y;
                                else
                                    for (var n = 0, r = e.length; n < r; ++n) e[n] = e[n] + (n % 2 ? i.y : i.x);
                                if (a && "function" == typeof a[t]) return a[t](e, i, s)
                            }
                        }(s[n].toUpperCase());
                        i.PathArray = function(t, e) {
                            i.Array.call(this, t, e || [
                                ["M", 0, 0]
                            ])
                        }, i.PathArray.prototype = new i.Array, i.PathArray.prototype.constructor = i.PathArray, i.extend(i.PathArray, {
                            toString: function() {
                                return function(t) {
                                    for (var e = 0, i = t.length, a = ""; e < i; e++) a += t[e][0], null != t[e][1] && (a += t[e][1], null != t[e][2] && (a += " ", a += t[e][2], null != t[e][3] && (a += " ", a += t[e][3], a += " ", a += t[e][4], null != t[e][5] && (a += " ", a += t[e][5], a += " ", a += t[e][6], null != t[e][7] && (a += " ", a += t[e][7])))));
                                    return a + " "
                                }(this.value)
                            },
                            move: function(t, e) {
                                var i = this.bbox();
                                return i.x, i.y, this
                            },
                            at: function(t) {
                                if (!this.destination) return this;
                                for (var e = this.value, a = this.destination.value, s = [], n = new i.PathArray, r = 0, o = e.length; r < o; r++) {
                                    s[r] = [e[r][0]];
                                    for (var l = 1, c = e[r].length; l < c; l++) s[r][l] = e[r][l] + (a[r][l] - e[r][l]) * t;
                                    "A" === s[r][0] && (s[r][4] = +(0 != s[r][4]), s[r][5] = +(0 != s[r][5]))
                                }
                                return n.value = s, n
                            },
                            parse: function(t) {
                                if (t instanceof i.PathArray) return t.valueOf();
                                var e, s = {
                                    M: 2,
                                    L: 2,
                                    H: 1,
                                    V: 1,
                                    C: 6,
                                    S: 4,
                                    Q: 4,
                                    T: 2,
                                    A: 7,
                                    Z: 0
                                };
                                t = "string" == typeof t ? t.replace(i.regex.numbersWithDots, c).replace(i.regex.pathLetters, " $& ").replace(i.regex.hyphen, "$1 -").trim().split(i.regex.delimiter) : t.reduce((function(t, e) {
                                    return [].concat.call(t, e)
                                }), []);
                                var n = [],
                                    r = new i.Point,
                                    o = new i.Point,
                                    l = 0,
                                    h = t.length;
                                do {
                                    i.regex.isPathLetter.test(t[l]) ? (e = t[l], ++l) : "M" == e ? e = "L" : "m" == e && (e = "l"), n.push(a[e].call(null, t.slice(l, l += s[e.toUpperCase()]).map(parseFloat), r, o))
                                } while (h > l);
                                return n
                            },
                            bbox: function() {
                                return i.parser.draw || i.prepare(), i.parser.path.setAttribute("d", this.toString()), i.parser.path.getBBox()
                            }
                        }), i.Number = i.invent({
                            create: function(t, e) {
                                this.value = 0, this.unit = e || "", "number" == typeof t ? this.value = isNaN(t) ? 0 : isFinite(t) ? t : t < 0 ? -34e37 : 34e37 : "string" == typeof t ? (e = t.match(i.regex.numberAndUnit)) && (this.value = parseFloat(e[1]), "%" == e[5] ? this.value /= 100 : "s" == e[5] && (this.value *= 1e3), this.unit = e[5]) : t instanceof i.Number && (this.value = t.valueOf(), this.unit = t.unit)
                            },
                            extend: {
                                toString: function() {
                                    return ("%" == this.unit ? ~~(1e8 * this.value) / 1e6 : "s" == this.unit ? this.value / 1e3 : this.value) + this.unit
                                },
                                toJSON: function() {
                                    return this.toString()
                                },
                                valueOf: function() {
                                    return this.value
                                },
                                plus: function(t) {
                                    return t = new i.Number(t), new i.Number(this + t, this.unit || t.unit)
                                },
                                minus: function(t) {
                                    return t = new i.Number(t), new i.Number(this - t, this.unit || t.unit)
                                },
                                times: function(t) {
                                    return t = new i.Number(t), new i.Number(this * t, this.unit || t.unit)
                                },
                                divide: function(t) {
                                    return t = new i.Number(t), new i.Number(this / t, this.unit || t.unit)
                                },
                                to: function(t) {
                                    var e = new i.Number(this);
                                    return "string" == typeof t && (e.unit = t), e
                                },
                                morph: function(t) {
                                    return this.destination = new i.Number(t), t.relative && (this.destination.value += this.value), this
                                },
                                at: function(t) {
                                    return this.destination ? new i.Number(this.destination).minus(this).times(t).plus(this) : this
                                }
                            }
                        }), i.Element = i.invent({
                            create: function(t) {
                                this._stroke = i.defaults.attrs.stroke, this._event = null, this.dom = {}, (this.node = t) && (this.type = t.nodeName, this.node.instance = this, this._stroke = t.getAttribute("stroke") || this._stroke)
                            },
                            extend: {
                                x: function(t) {
                                    return this.attr("x", t)
                                },
                                y: function(t) {
                                    return this.attr("y", t)
                                },
                                cx: function(t) {
                                    return null == t ? this.x() + this.width() / 2 : this.x(t - this.width() / 2)
                                },
                                cy: function(t) {
                                    return null == t ? this.y() + this.height() / 2 : this.y(t - this.height() / 2)
                                },
                                move: function(t, e) {
                                    return this.x(t).y(e)
                                },
                                center: function(t, e) {
                                    return this.cx(t).cy(e)
                                },
                                width: function(t) {
                                    return this.attr("width", t)
                                },
                                height: function(t) {
                                    return this.attr("height", t)
                                },
                                size: function(t, e) {
                                    var a = p(this, t, e);
                                    return this.width(new i.Number(a.width)).height(new i.Number(a.height))
                                },
                                clone: function(t) {
                                    this.writeDataToDom();
                                    var e = m(this.node.cloneNode(!0));
                                    return t ? t.add(e) : this.after(e), e
                                },
                                remove: function() {
                                    return this.parent() && this.parent().removeElement(this), this
                                },
                                replace: function(t) {
                                    return this.after(t).remove(), t
                                },
                                addTo: function(t) {
                                    return t.put(this)
                                },
                                putIn: function(t) {
                                    return t.add(this)
                                },
                                id: function(t) {
                                    return this.attr("id", t)
                                },
                                show: function() {
                                    return this.style("display", "")
                                },
                                hide: function() {
                                    return this.style("display", "none")
                                },
                                visible: function() {
                                    return "none" != this.style("display")
                                },
                                toString: function() {
                                    return this.attr("id")
                                },
                                classes: function() {
                                    var t = this.attr("class");
                                    return null == t ? [] : t.trim().split(i.regex.delimiter)
                                },
                                hasClass: function(t) {
                                    return -1 != this.classes().indexOf(t)
                                },
                                addClass: function(t) {
                                    if (!this.hasClass(t)) {
                                        var e = this.classes();
                                        e.push(t), this.attr("class", e.join(" "))
                                    }
                                    return this
                                },
                                removeClass: function(t) {
                                    return this.hasClass(t) && this.attr("class", this.classes().filter((function(e) {
                                        return e != t
                                    })).join(" ")), this
                                },
                                toggleClass: function(t) {
                                    return this.hasClass(t) ? this.removeClass(t) : this.addClass(t)
                                },
                                reference: function(t) {
                                    return i.get(this.attr(t))
                                },
                                parent: function(e) {
                                    var a = this;
                                    if (!a.node.parentNode) return null;
                                    if (a = i.adopt(a.node.parentNode), !e) return a;
                                    for (; a && a.node instanceof t.SVGElement;) {
                                        if ("string" == typeof e ? a.matches(e) : a instanceof e) return a;
                                        if (!a.node.parentNode || "#document" == a.node.parentNode.nodeName) return null;
                                        a = i.adopt(a.node.parentNode)
                                    }
                                },
                                doc: function() {
                                    return this instanceof i.Doc ? this : this.parent(i.Doc)
                                },
                                parents: function(t) {
                                    var e = [],
                                        i = this;
                                    do {
                                        if (!(i = i.parent(t)) || !i.node) break;
                                        e.push(i)
                                    } while (i.parent);
                                    return e
                                },
                                matches: function(t) {
                                    return function(t, e) {
                                        return (t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector).call(t, e)
                                    }(this.node, t)
                                },
                                native: function() {
                                    return this.node
                                },
                                svg: function(t) {
                                    var a = e.createElement("svg");
                                    if (!(t && this instanceof i.Parent)) return a.appendChild(t = e.createElement("svg")), this.writeDataToDom(), t.appendChild(this.node.cloneNode(!0)), a.innerHTML.replace(/^<svg>/, "").replace(/<\/svg>$/, "");
                                    a.innerHTML = "<svg>" + t.replace(/\n/, "").replace(/<([\w:-]+)([^<]+?)\/>/g, "<$1$2></$1>") + "</svg>";
                                    for (var s = 0, n = a.firstChild.childNodes.length; s < n; s++) this.node.appendChild(a.firstChild.firstChild);
                                    return this
                                },
                                writeDataToDom: function() {
                                    return (this.each || this.lines) && (this.each ? this : this.lines()).each((function() {
                                        this.writeDataToDom()
                                    })), this.node.removeAttribute("svgjs:data"), Object.keys(this.dom).length && this.node.setAttribute("svgjs:data", JSON.stringify(this.dom)), this
                                },
                                setData: function(t) {
                                    return this.dom = t, this
                                },
                                is: function(t) {
                                    return function(t, e) {
                                        return t instanceof e
                                    }(this, t)
                                }
                            }
                        }), i.easing = {
                            "-": function(t) {
                                return t
                            },
                            "<>": function(t) {
                                return -Math.cos(t * Math.PI) / 2 + .5
                            },
                            ">": function(t) {
                                return Math.sin(t * Math.PI / 2)
                            },
                            "<": function(t) {
                                return 1 - Math.cos(t * Math.PI / 2)
                            }
                        }, i.morph = function(t) {
                            return function(e, a) {
                                return new i.MorphObj(e, a).at(t)
                            }
                        }, i.Situation = i.invent({
                            create: function(t) {
                                this.init = !1, this.reversed = !1, this.reversing = !1, this.duration = new i.Number(t.duration).valueOf(), this.delay = new i.Number(t.delay).valueOf(), this.start = +new Date + this.delay, this.finish = this.start + this.duration, this.ease = t.ease, this.loop = 0, this.loops = !1, this.animations = {}, this.attrs = {}, this.styles = {}, this.transforms = [], this.once = {}
                            }
                        }), i.FX = i.invent({
                            create: function(t) {
                                this._target = t, this.situations = [], this.active = !1, this.situation = null, this.paused = !1, this.lastPos = 0, this.pos = 0, this.absPos = 0, this._speed = 1
                            },
                            extend: {
                                animate: function(t, e, a) {
                                    "object" === r(t) && (e = t.ease, a = t.delay, t = t.duration);
                                    var s = new i.Situation({
                                        duration: t || 1e3,
                                        delay: a || 0,
                                        ease: i.easing[e || "-"] || e
                                    });
                                    return this.queue(s), this
                                },
                                target: function(t) {
                                    return t && t instanceof i.Element ? (this._target = t, this) : this._target
                                },
                                timeToAbsPos: function(t) {
                                    return (t - this.situation.start) / (this.situation.duration / this._speed)
                                },
                                absPosToTime: function(t) {
                                    return this.situation.duration / this._speed * t + this.situation.start
                                },
                                startAnimFrame: function() {
                                    this.stopAnimFrame(), this.animationFrame = t.requestAnimationFrame(function() {
                                        this.step()
                                    }.bind(this))
                                },
                                stopAnimFrame: function() {
                                    t.cancelAnimationFrame(this.animationFrame)
                                },
                                start: function() {
                                    return !this.active && this.situation && (this.active = !0, this.startCurrent()), this
                                },
                                startCurrent: function() {
                                    return this.situation.start = +new Date + this.situation.delay / this._speed, this.situation.finish = this.situation.start + this.situation.duration / this._speed, this.initAnimations().step()
                                },
                                queue: function(t) {
                                    return ("function" == typeof t || t instanceof i.Situation) && this.situations.push(t), this.situation || (this.situation = this.situations.shift()), this
                                },
                                dequeue: function() {
                                    return this.stop(), this.situation = this.situations.shift(), this.situation && (this.situation instanceof i.Situation ? this.start() : this.situation.call(this)), this
                                },
                                initAnimations: function() {
                                    var t, e = this.situation;
                                    if (e.init) return this;
                                    for (var a in e.animations) {
                                        t = this.target()[a](), Array.isArray(t) || (t = [t]), Array.isArray(e.animations[a]) || (e.animations[a] = [e.animations[a]]);
                                        for (var s = t.length; s--;) e.animations[a][s] instanceof i.Number && (t[s] = new i.Number(t[s])), e.animations[a][s] = t[s].morph(e.animations[a][s])
                                    }
                                    for (var a in e.attrs) e.attrs[a] = new i.MorphObj(this.target().attr(a), e.attrs[a]);
                                    for (var a in e.styles) e.styles[a] = new i.MorphObj(this.target().style(a), e.styles[a]);
                                    return e.initialTransformation = this.target().matrixify(), e.init = !0, this
                                },
                                clearQueue: function() {
                                    return this.situations = [], this
                                },
                                clearCurrent: function() {
                                    return this.situation = null, this
                                },
                                stop: function(t, e) {
                                    var i = this.active;
                                    return this.active = !1, e && this.clearQueue(), t && this.situation && (!i && this.startCurrent(), this.atEnd()), this.stopAnimFrame(), this.clearCurrent()
                                },
                                after: function(t) {
                                    var e = this.last();
                                    return this.target().on("finished.fx", (function i(a) {
                                        a.detail.situation == e && (t.call(this, e), this.off("finished.fx", i))
                                    })), this._callStart()
                                },
                                during: function(t) {
                                    var e = this.last(),
                                        a = function(a) {
                                            a.detail.situation == e && t.call(this, a.detail.pos, i.morph(a.detail.pos), a.detail.eased, e)
                                        };
                                    return this.target().off("during.fx", a).on("during.fx", a), this.after((function() {
                                        this.off("during.fx", a)
                                    })), this._callStart()
                                },
                                afterAll: function(t) {
                                    var e = function e(i) {
                                        t.call(this), this.off("allfinished.fx", e)
                                    };
                                    return this.target().off("allfinished.fx", e).on("allfinished.fx", e), this._callStart()
                                },
                                last: function() {
                                    return this.situations.length ? this.situations[this.situations.length - 1] : this.situation
                                },
                                add: function(t, e, i) {
                                    return this.last()[i || "animations"][t] = e, this._callStart()
                                },
                                step: function(t) {
                                    var e, i, a;
                                    t || (this.absPos = this.timeToAbsPos(+new Date)), !1 !== this.situation.loops ? (e = Math.max(this.absPos, 0), i = Math.floor(e), !0 === this.situation.loops || i < this.situation.loops ? (this.pos = e - i, a = this.situation.loop, this.situation.loop = i) : (this.absPos = this.situation.loops, this.pos = 1, a = this.situation.loop - 1, this.situation.loop = this.situation.loops), this.situation.reversing && (this.situation.reversed = this.situation.reversed != Boolean((this.situation.loop - a) % 2))) : (this.absPos = Math.min(this.absPos, 1), this.pos = this.absPos), this.pos < 0 && (this.pos = 0), this.situation.reversed && (this.pos = 1 - this.pos);
                                    var s = this.situation.ease(this.pos);
                                    for (var n in this.situation.once) n > this.lastPos && n <= s && (this.situation.once[n].call(this.target(), this.pos, s), delete this.situation.once[n]);
                                    return this.active && this.target().fire("during", {
                                        pos: this.pos,
                                        eased: s,
                                        fx: this,
                                        situation: this.situation
                                    }), this.situation ? (this.eachAt(), 1 == this.pos && !this.situation.reversed || this.situation.reversed && 0 == this.pos ? (this.stopAnimFrame(), this.target().fire("finished", {
                                        fx: this,
                                        situation: this.situation
                                    }), this.situations.length || (this.target().fire("allfinished"), this.situations.length || (this.target().off(".fx"), this.active = !1)), this.active ? this.dequeue() : this.clearCurrent()) : !this.paused && this.active && this.startAnimFrame(), this.lastPos = s, this) : this
                                },
                                eachAt: function() {
                                    var t, e = this,
                                        a = this.target(),
                                        s = this.situation;
                                    for (var n in s.animations) t = [].concat(s.animations[n]).map((function(t) {
                                        return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t
                                    })), a[n].apply(a, t);
                                    for (var n in s.attrs) t = [n].concat(s.attrs[n]).map((function(t) {
                                        return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t
                                    })), a.attr.apply(a, t);
                                    for (var n in s.styles) t = [n].concat(s.styles[n]).map((function(t) {
                                        return "string" != typeof t && t.at ? t.at(s.ease(e.pos), e.pos) : t
                                    })), a.style.apply(a, t);
                                    if (s.transforms.length) {
                                        t = s.initialTransformation, n = 0;
                                        for (var r = s.transforms.length; n < r; n++) {
                                            var o = s.transforms[n];
                                            o instanceof i.Matrix ? t = o.relative ? t.multiply((new i.Matrix).morph(o).at(s.ease(this.pos))) : t.morph(o).at(s.ease(this.pos)) : (o.relative || o.undo(t.extract()), t = t.multiply(o.at(s.ease(this.pos))))
                                        }
                                        a.matrix(t)
                                    }
                                    return this
                                },
                                once: function(t, e, i) {
                                    var a = this.last();
                                    return i || (t = a.ease(t)), a.once[t] = e, this
                                },
                                _callStart: function() {
                                    return setTimeout(function() {
                                        this.start()
                                    }.bind(this), 0), this
                                }
                            },
                            parent: i.Element,
                            construct: {
                                animate: function(t, e, a) {
                                    return (this.fx || (this.fx = new i.FX(this))).animate(t, e, a)
                                },
                                delay: function(t) {
                                    return (this.fx || (this.fx = new i.FX(this))).delay(t)
                                },
                                stop: function(t, e) {
                                    return this.fx && this.fx.stop(t, e), this
                                },
                                finish: function() {
                                    return this.fx && this.fx.finish(), this
                                }
                            }
                        }), i.MorphObj = i.invent({
                            create: function(t, e) {
                                return i.Color.isColor(e) ? new i.Color(t).morph(e) : i.regex.delimiter.test(t) ? i.regex.pathLetters.test(t) ? new i.PathArray(t).morph(e) : new i.Array(t).morph(e) : i.regex.numberAndUnit.test(e) ? new i.Number(t).morph(e) : (this.value = t, void(this.destination = e))
                            },
                            extend: {
                                at: function(t, e) {
                                    return e < 1 ? this.value : this.destination
                                },
                                valueOf: function() {
                                    return this.value
                                }
                            }
                        }), i.extend(i.FX, {
                            attr: function(t, e, i) {
                                if ("object" === r(t))
                                    for (var a in t) this.attr(a, t[a]);
                                else this.add(t, e, "attrs");
                                return this
                            },
                            plot: function(t, e, i, a) {
                                return 4 == arguments.length ? this.plot([t, e, i, a]) : this.add("plot", new(this.target().morphArray)(t))
                            }
                        }), i.Box = i.invent({
                            create: function(t, e, a, s) {
                                if (!("object" !== r(t) || t instanceof i.Element)) return i.Box.call(this, null != t.left ? t.left : t.x, null != t.top ? t.top : t.y, t.width, t.height);
                                4 == arguments.length && (this.x = t, this.y = e, this.width = a, this.height = s), x(this)
                            }
                        }), i.BBox = i.invent({
                            create: function(t) {
                                if (i.Box.apply(this, [].slice.call(arguments)), t instanceof i.Element) {
                                    var a;
                                    try {
                                        if (!e.documentElement.contains) {
                                            for (var s = t.node; s.parentNode;) s = s.parentNode;
                                            if (s != e) throw new Error("Element not in the dom")
                                        }
                                        a = t.node.getBBox()
                                    } catch (e) {
                                        if (t instanceof i.Shape) {
                                            i.parser.draw || i.prepare();
                                            var n = t.clone(i.parser.draw.instance).show();
                                            n && n.node && "function" == typeof n.node.getBBox && (a = n.node.getBBox()), n && "function" == typeof n.remove && n.remove()
                                        } else a = {
                                            x: t.node.clientLeft,
                                            y: t.node.clientTop,
                                            width: t.node.clientWidth,
                                            height: t.node.clientHeight
                                        }
                                    }
                                    i.Box.call(this, a)
                                }
                            },
                            inherit: i.Box,
                            parent: i.Element,
                            construct: {
                                bbox: function() {
                                    return new i.BBox(this)
                                }
                            }
                        }), i.BBox.prototype.constructor = i.BBox, i.Matrix = i.invent({
                            create: function(t) {
                                var e = f([1, 0, 0, 1, 0, 0]);
                                t = null === t ? e : t instanceof i.Element ? t.matrixify() : "string" == typeof t ? f(t.split(i.regex.delimiter).map(parseFloat)) : 6 == arguments.length ? f([].slice.call(arguments)) : Array.isArray(t) ? f(t) : t && "object" === r(t) ? t : e;
                                for (var a = b.length - 1; a >= 0; --a) this[b[a]] = null != t[b[a]] ? t[b[a]] : e[b[a]]
                            },
                            extend: {
                                extract: function() {
                                    var t = g(this, 0, 1);
                                    g(this, 1, 0);
                                    var e = 180 / Math.PI * Math.atan2(t.y, t.x) - 90;
                                    return {
                                        x: this.e,
                                        y: this.f,
                                        transformedX: (this.e * Math.cos(e * Math.PI / 180) + this.f * Math.sin(e * Math.PI / 180)) / Math.sqrt(this.a * this.a + this.b * this.b),
                                        transformedY: (this.f * Math.cos(e * Math.PI / 180) + this.e * Math.sin(-e * Math.PI / 180)) / Math.sqrt(this.c * this.c + this.d * this.d),
                                        rotation: e,
                                        a: this.a,
                                        b: this.b,
                                        c: this.c,
                                        d: this.d,
                                        e: this.e,
                                        f: this.f,
                                        matrix: new i.Matrix(this)
                                    }
                                },
                                clone: function() {
                                    return new i.Matrix(this)
                                },
                                morph: function(t) {
                                    return this.destination = new i.Matrix(t), this
                                },
                                multiply: function(t) {
                                    return new i.Matrix(this.native().multiply(function(t) {
                                        return t instanceof i.Matrix || (t = new i.Matrix(t)), t
                                    }(t).native()))
                                },
                                inverse: function() {
                                    return new i.Matrix(this.native().inverse())
                                },
                                translate: function(t, e) {
                                    return new i.Matrix(this.native().translate(t || 0, e || 0))
                                },
                                native: function() {
                                    for (var t = i.parser.native.createSVGMatrix(), e = b.length - 1; e >= 0; e--) t[b[e]] = this[b[e]];
                                    return t
                                },
                                toString: function() {
                                    return "matrix(" + v(this.a) + "," + v(this.b) + "," + v(this.c) + "," + v(this.d) + "," + v(this.e) + "," + v(this.f) + ")"
                                }
                            },
                            parent: i.Element,
                            construct: {
                                ctm: function() {
                                    return new i.Matrix(this.node.getCTM())
                                },
                                screenCTM: function() {
                                    if (this instanceof i.Nested) {
                                        var t = this.rect(1, 1),
                                            e = t.node.getScreenCTM();
                                        return t.remove(), new i.Matrix(e)
                                    }
                                    return new i.Matrix(this.node.getScreenCTM())
                                }
                            }
                        }), i.Point = i.invent({
                            create: function(t, e) {
                                var i;
                                i = Array.isArray(t) ? {
                                    x: t[0],
                                    y: t[1]
                                } : "object" === r(t) ? {
                                    x: t.x,
                                    y: t.y
                                } : null != t ? {
                                    x: t,
                                    y: null != e ? e : t
                                } : {
                                    x: 0,
                                    y: 0
                                }, this.x = i.x, this.y = i.y
                            },
                            extend: {
                                clone: function() {
                                    return new i.Point(this)
                                },
                                morph: function(t, e) {
                                    return this.destination = new i.Point(t, e), this
                                }
                            }
                        }), i.extend(i.Element, {
                            point: function(t, e) {
                                return new i.Point(t, e).transform(this.screenCTM().inverse())
                            }
                        }), i.extend(i.Element, {
                            attr: function(t, e, a) {
                                if (null == t) {
                                    for (t = {}, a = (e = this.node.attributes).length - 1; a >= 0; a--) t[e[a].nodeName] = i.regex.isNumber.test(e[a].nodeValue) ? parseFloat(e[a].nodeValue) : e[a].nodeValue;
                                    return t
                                }
                                if ("object" === r(t))
                                    for (var s in t) this.attr(s, t[s]);
                                else if (null === e) this.node.removeAttribute(t);
                                else {
                                    if (null == e) return null == (e = this.node.getAttribute(t)) ? i.defaults.attrs[t] : i.regex.isNumber.test(e) ? parseFloat(e) : e;
                                    "stroke-width" == t ? this.attr("stroke", parseFloat(e) > 0 ? this._stroke : null) : "stroke" == t && (this._stroke = e), "fill" != t && "stroke" != t || (i.regex.isImage.test(e) && (e = this.doc().defs().image(e, 0, 0)), e instanceof i.Image && (e = this.doc().defs().pattern(0, 0, (function() {
                                        this.add(e)
                                    })))), "number" == typeof e ? e = new i.Number(e) : i.Color.isColor(e) ? e = new i.Color(e) : Array.isArray(e) && (e = new i.Array(e)), "leading" == t ? this.leading && this.leading(e) : "string" == typeof a ? this.node.setAttributeNS(a, t, e.toString()) : this.node.setAttribute(t, e.toString()), !this.rebuild || "font-size" != t && "x" != t || this.rebuild(t, e)
                                }
                                return this
                            }
                        }), i.extend(i.Element, {
                            transform: function(t, e) {
                                var a;
                                return "object" !== r(t) ? (a = new i.Matrix(this).extract(), "string" == typeof t ? a[t] : a) : (a = new i.Matrix(this), e = !!e || !!t.relative, null != t.a && (a = e ? a.multiply(new i.Matrix(t)) : new i.Matrix(t)), this.attr("transform", a))
                            }
                        }), i.extend(i.Element, {
                            untransform: function() {
                                return this.attr("transform", null)
                            },
                            matrixify: function() {
                                return (this.attr("transform") || "").split(i.regex.transforms).slice(0, -1).map((function(t) {
                                    var e = t.trim().split("(");
                                    return [e[0], e[1].split(i.regex.delimiter).map((function(t) {
                                        return parseFloat(t)
                                    }))]
                                })).reduce((function(t, e) {
                                    return "matrix" == e[0] ? t.multiply(f(e[1])) : t[e[0]].apply(t, e[1])
                                }), new i.Matrix)
                            },
                            toParent: function(t) {
                                if (this == t) return this;
                                var e = this.screenCTM(),
                                    i = t.screenCTM().inverse();
                                return this.addTo(t).untransform().transform(i.multiply(e)), this
                            },
                            toDoc: function() {
                                return this.toParent(this.doc())
                            }
                        }), i.Transformation = i.invent({
                            create: function(t, e) {
                                if (arguments.length > 1 && "boolean" != typeof e) return this.constructor.call(this, [].slice.call(arguments));
                                if (Array.isArray(t))
                                    for (var i = 0, a = this.arguments.length; i < a; ++i) this[this.arguments[i]] = t[i];
                                else if (t && "object" === r(t))
                                    for (i = 0, a = this.arguments.length; i < a; ++i) this[this.arguments[i]] = t[this.arguments[i]];
                                this.inversed = !1, !0 === e && (this.inversed = !0)
                            }
                        }), i.Translate = i.invent({
                            parent: i.Matrix,
                            inherit: i.Transformation,
                            create: function(t, e) {
                                this.constructor.apply(this, [].slice.call(arguments))
                            },
                            extend: {
                                arguments: ["transformedX", "transformedY"],
                                method: "translate"
                            }
                        }), i.extend(i.Element, {
                            style: function(t, e) {
                                if (0 == arguments.length) return this.node.style.cssText || "";
                                if (arguments.length < 2)
                                    if ("object" === r(t))
                                        for (var a in t) this.style(a, t[a]);
                                    else {
                                        if (!i.regex.isCss.test(t)) return this.node.style[h(t)];
                                        for (t = t.split(/\s*;\s*/).filter((function(t) {
                                                return !!t
                                            })).map((function(t) {
                                                return t.split(/\s*:\s*/)
                                            })); e = t.pop();) this.style(e[0], e[1])
                                    }
                                else this.node.style[h(t)] = null === e || i.regex.isBlank.test(e) ? "" : e;
                                return this
                            }
                        }), i.Parent = i.invent({
                            create: function(t) {
                                this.constructor.call(this, t)
                            },
                            inherit: i.Element,
                            extend: {
                                children: function() {
                                    return i.utils.map(i.utils.filterSVGElements(this.node.childNodes), (function(t) {
                                        return i.adopt(t)
                                    }))
                                },
                                add: function(t, e) {
                                    return null == e ? this.node.appendChild(t.node) : t.node != this.node.childNodes[e] && this.node.insertBefore(t.node, this.node.childNodes[e]), this
                                },
                                put: function(t, e) {
                                    return this.add(t, e), t
                                },
                                has: function(t) {
                                    return this.index(t) >= 0
                                },
                                index: function(t) {
                                    return [].slice.call(this.node.childNodes).indexOf(t.node)
                                },
                                get: function(t) {
                                    return i.adopt(this.node.childNodes[t])
                                },
                                first: function() {
                                    return this.get(0)
                                },
                                last: function() {
                                    return this.get(this.node.childNodes.length - 1)
                                },
                                each: function(t, e) {
                                    for (var a = this.children(), s = 0, n = a.length; s < n; s++) a[s] instanceof i.Element && t.apply(a[s], [s, a]), e && a[s] instanceof i.Container && a[s].each(t, e);
                                    return this
                                },
                                removeElement: function(t) {
                                    return this.node.removeChild(t.node), this
                                },
                                clear: function() {
                                    for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                                    return delete this._defs, this
                                },
                                defs: function() {
                                    return this.doc().defs()
                                }
                            }
                        }), i.extend(i.Parent, {
                            ungroup: function(t, e) {
                                return 0 === e || this instanceof i.Defs || this.node == i.parser.draw || (t = t || (this instanceof i.Doc ? this : this.parent(i.Parent)), e = e || 1 / 0, this.each((function() {
                                    return this instanceof i.Defs ? this : this instanceof i.Parent ? this.ungroup(t, e - 1) : this.toParent(t)
                                })), this.node.firstChild || this.remove()), this
                            },
                            flatten: function(t, e) {
                                return this.ungroup(t, e)
                            }
                        }), i.Container = i.invent({
                            create: function(t) {
                                this.constructor.call(this, t)
                            },
                            inherit: i.Parent
                        }), i.ViewBox = i.invent({
                            parent: i.Container,
                            construct: {}
                        }), ["click", "dblclick", "mousedown", "mouseup", "mouseover", "mouseout", "mousemove", "touchstart", "touchmove", "touchleave", "touchend", "touchcancel"].forEach((function(t) {
                            i.Element.prototype[t] = function(e) {
                                return i.on(this.node, t, e), this
                            }
                        })), i.listeners = [], i.handlerMap = [], i.listenerId = 0, i.on = function(t, e, a, s, n) {
                            var r = a.bind(s || t.instance || t),
                                o = (i.handlerMap.indexOf(t) + 1 || i.handlerMap.push(t)) - 1,
                                l = e.split(".")[0],
                                c = e.split(".")[1] || "*";
                            i.listeners[o] = i.listeners[o] || {}, i.listeners[o][l] = i.listeners[o][l] || {}, i.listeners[o][l][c] = i.listeners[o][l][c] || {}, a._svgjsListenerId || (a._svgjsListenerId = ++i.listenerId), i.listeners[o][l][c][a._svgjsListenerId] = r, t.addEventListener(l, r, n || {
                                passive: !0
                            })
                        }, i.off = function(t, e, a) {
                            var s = i.handlerMap.indexOf(t),
                                n = e && e.split(".")[0],
                                r = e && e.split(".")[1],
                                o = "";
                            if (-1 != s)
                                if (a) {
                                    if ("function" == typeof a && (a = a._svgjsListenerId), !a) return;
                                    i.listeners[s][n] && i.listeners[s][n][r || "*"] && (t.removeEventListener(n, i.listeners[s][n][r || "*"][a], !1), delete i.listeners[s][n][r || "*"][a])
                                } else if (r && n) {
                                if (i.listeners[s][n] && i.listeners[s][n][r]) {
                                    for (var l in i.listeners[s][n][r]) i.off(t, [n, r].join("."), l);
                                    delete i.listeners[s][n][r]
                                }
                            } else if (r)
                                for (var c in i.listeners[s])
                                    for (var o in i.listeners[s][c]) r === o && i.off(t, [c, r].join("."));
                            else if (n) {
                                if (i.listeners[s][n]) {
                                    for (var o in i.listeners[s][n]) i.off(t, [n, o].join("."));
                                    delete i.listeners[s][n]
                                }
                            } else {
                                for (var c in i.listeners[s]) i.off(t, c);
                                delete i.listeners[s], delete i.handlerMap[s]
                            }
                        }, i.extend(i.Element, {
                            on: function(t, e, a, s) {
                                return i.on(this.node, t, e, a, s), this
                            },
                            off: function(t, e) {
                                return i.off(this.node, t, e), this
                            },
                            fire: function(e, a) {
                                return e instanceof t.Event ? this.node.dispatchEvent(e) : this.node.dispatchEvent(e = new i.CustomEvent(e, {
                                    detail: a,
                                    cancelable: !0
                                })), this._event = e, this
                            },
                            event: function() {
                                return this._event
                            }
                        }), i.Defs = i.invent({
                            create: "defs",
                            inherit: i.Container
                        }), i.G = i.invent({
                            create: "g",
                            inherit: i.Container,
                            extend: {
                                x: function(t) {
                                    return null == t ? this.transform("x") : this.transform({
                                        x: t - this.x()
                                    }, !0)
                                }
                            },
                            construct: {
                                group: function() {
                                    return this.put(new i.G)
                                }
                            }
                        }), i.Doc = i.invent({
                            create: function(t) {
                                t && ("svg" == (t = "string" == typeof t ? e.getElementById(t) : t).nodeName ? this.constructor.call(this, t) : (this.constructor.call(this, i.create("svg")), t.appendChild(this.node), this.size("100%", "100%")), this.namespace().defs())
                            },
                            inherit: i.Container,
                            extend: {
                                namespace: function() {
                                    return this.attr({
                                        xmlns: i.ns,
                                        version: "1.1"
                                    }).attr("xmlns:xlink", i.xlink, i.xmlns).attr("xmlns:svgjs", i.svgjs, i.xmlns)
                                },
                                defs: function() {
                                    var t;
                                    return this._defs || ((t = this.node.getElementsByTagName("defs")[0]) ? this._defs = i.adopt(t) : this._defs = new i.Defs, this.node.appendChild(this._defs.node)), this._defs
                                },
                                parent: function() {
                                    return this.node.parentNode && "#document" != this.node.parentNode.nodeName ? this.node.parentNode : null
                                },
                                remove: function() {
                                    return this.parent() && this.parent().removeChild(this.node), this
                                },
                                clear: function() {
                                    for (; this.node.hasChildNodes();) this.node.removeChild(this.node.lastChild);
                                    return delete this._defs, i.parser.draw && !i.parser.draw.parentNode && this.node.appendChild(i.parser.draw), this
                                },
                                clone: function(t) {
                                    this.writeDataToDom();
                                    var e = this.node,
                                        i = m(e.cloneNode(!0));
                                    return t ? (t.node || t).appendChild(i.node) : e.parentNode.insertBefore(i.node, e.nextSibling), i
                                }
                            }
                        }), i.extend(i.Element, {}), i.Gradient = i.invent({
                            create: function(t) {
                                this.constructor.call(this, i.create(t + "Gradient")), this.type = t
                            },
                            inherit: i.Container,
                            extend: {
                                at: function(t, e, a) {
                                    return this.put(new i.Stop).update(t, e, a)
                                },
                                update: function(t) {
                                    return this.clear(), "function" == typeof t && t.call(this, this), this
                                },
                                fill: function() {
                                    return "url(#" + this.id() + ")"
                                },
                                toString: function() {
                                    return this.fill()
                                },
                                attr: function(t, e, a) {
                                    return "transform" == t && (t = "gradientTransform"), i.Container.prototype.attr.call(this, t, e, a)
                                }
                            },
                            construct: {
                                gradient: function(t, e) {
                                    return this.defs().gradient(t, e)
                                }
                            }
                        }), i.extend(i.Gradient, i.FX, {
                            from: function(t, e) {
                                return "radial" == (this._target || this).type ? this.attr({
                                    fx: new i.Number(t),
                                    fy: new i.Number(e)
                                }) : this.attr({
                                    x1: new i.Number(t),
                                    y1: new i.Number(e)
                                })
                            },
                            to: function(t, e) {
                                return "radial" == (this._target || this).type ? this.attr({
                                    cx: new i.Number(t),
                                    cy: new i.Number(e)
                                }) : this.attr({
                                    x2: new i.Number(t),
                                    y2: new i.Number(e)
                                })
                            }
                        }), i.extend(i.Defs, {
                            gradient: function(t, e) {
                                return this.put(new i.Gradient(t)).update(e)
                            }
                        }), i.Stop = i.invent({
                            create: "stop",
                            inherit: i.Element,
                            extend: {
                                update: function(t) {
                                    return ("number" == typeof t || t instanceof i.Number) && (t = {
                                        offset: arguments[0],
                                        color: arguments[1],
                                        opacity: arguments[2]
                                    }), null != t.opacity && this.attr("stop-opacity", t.opacity), null != t.color && this.attr("stop-color", t.color), null != t.offset && this.attr("offset", new i.Number(t.offset)), this
                                }
                            }
                        }), i.Pattern = i.invent({
                            create: "pattern",
                            inherit: i.Container,
                            extend: {
                                fill: function() {
                                    return "url(#" + this.id() + ")"
                                },
                                update: function(t) {
                                    return this.clear(), "function" == typeof t && t.call(this, this), this
                                },
                                toString: function() {
                                    return this.fill()
                                },
                                attr: function(t, e, a) {
                                    return "transform" == t && (t = "patternTransform"), i.Container.prototype.attr.call(this, t, e, a)
                                }
                            },
                            construct: {
                                pattern: function(t, e, i) {
                                    return this.defs().pattern(t, e, i)
                                }
                            }
                        }), i.extend(i.Defs, {
                            pattern: function(t, e, a) {
                                return this.put(new i.Pattern).update(a).attr({
                                    x: 0,
                                    y: 0,
                                    width: t,
                                    height: e,
                                    patternUnits: "userSpaceOnUse"
                                })
                            }
                        }), i.Shape = i.invent({
                            create: function(t) {
                                this.constructor.call(this, t)
                            },
                            inherit: i.Element
                        }), i.Symbol = i.invent({
                            create: "symbol",
                            inherit: i.Container,
                            construct: {
                                symbol: function() {
                                    return this.put(new i.Symbol)
                                }
                            }
                        }), i.Use = i.invent({
                            create: "use",
                            inherit: i.Shape,
                            extend: {
                                element: function(t, e) {
                                    return this.attr("href", (e || "") + "#" + t, i.xlink)
                                }
                            },
                            construct: {
                                use: function(t, e) {
                                    return this.put(new i.Use).element(t, e)
                                }
                            }
                        }), i.Rect = i.invent({
                            create: "rect",
                            inherit: i.Shape,
                            construct: {
                                rect: function(t, e) {
                                    return this.put(new i.Rect).size(t, e)
                                }
                            }
                        }), i.Circle = i.invent({
                            create: "circle",
                            inherit: i.Shape,
                            construct: {
                                circle: function(t) {
                                    return this.put(new i.Circle).rx(new i.Number(t).divide(2)).move(0, 0)
                                }
                            }
                        }), i.extend(i.Circle, i.FX, {
                            rx: function(t) {
                                return this.attr("r", t)
                            },
                            ry: function(t) {
                                return this.rx(t)
                            }
                        }), i.Ellipse = i.invent({
                            create: "ellipse",
                            inherit: i.Shape,
                            construct: {
                                ellipse: function(t, e) {
                                    return this.put(new i.Ellipse).size(t, e).move(0, 0)
                                }
                            }
                        }), i.extend(i.Ellipse, i.Rect, i.FX, {
                            rx: function(t) {
                                return this.attr("rx", t)
                            },
                            ry: function(t) {
                                return this.attr("ry", t)
                            }
                        }), i.extend(i.Circle, i.Ellipse, {
                            x: function(t) {
                                return null == t ? this.cx() - this.rx() : this.cx(t + this.rx())
                            },
                            y: function(t) {
                                return null == t ? this.cy() - this.ry() : this.cy(t + this.ry())
                            },
                            cx: function(t) {
                                return null == t ? this.attr("cx") : this.attr("cx", t)
                            },
                            cy: function(t) {
                                return null == t ? this.attr("cy") : this.attr("cy", t)
                            },
                            width: function(t) {
                                return null == t ? 2 * this.rx() : this.rx(new i.Number(t).divide(2))
                            },
                            height: function(t) {
                                return null == t ? 2 * this.ry() : this.ry(new i.Number(t).divide(2))
                            },
                            size: function(t, e) {
                                var a = p(this, t, e);
                                return this.rx(new i.Number(a.width).divide(2)).ry(new i.Number(a.height).divide(2))
                            }
                        }), i.Line = i.invent({
                            create: "line",
                            inherit: i.Shape,
                            extend: {
                                array: function() {
                                    return new i.PointArray([
                                        [this.attr("x1"), this.attr("y1")],
                                        [this.attr("x2"), this.attr("y2")]
                                    ])
                                },
                                plot: function(t, e, a, s) {
                                    return null == t ? this.array() : (t = void 0 !== e ? {
                                        x1: t,
                                        y1: e,
                                        x2: a,
                                        y2: s
                                    } : new i.PointArray(t).toLine(), this.attr(t))
                                },
                                move: function(t, e) {
                                    return this.attr(this.array().move(t, e).toLine())
                                },
                                size: function(t, e) {
                                    var i = p(this, t, e);
                                    return this.attr(this.array().size(i.width, i.height).toLine())
                                }
                            },
                            construct: {
                                line: function(t, e, a, s) {
                                    return i.Line.prototype.plot.apply(this.put(new i.Line), null != t ? [t, e, a, s] : [0, 0, 0, 0])
                                }
                            }
                        }), i.Polyline = i.invent({
                            create: "polyline",
                            inherit: i.Shape,
                            construct: {
                                polyline: function(t) {
                                    return this.put(new i.Polyline).plot(t || new i.PointArray)
                                }
                            }
                        }), i.Polygon = i.invent({
                            create: "polygon",
                            inherit: i.Shape,
                            construct: {
                                polygon: function(t) {
                                    return this.put(new i.Polygon).plot(t || new i.PointArray)
                                }
                            }
                        }), i.extend(i.Polyline, i.Polygon, {
                            array: function() {
                                return this._array || (this._array = new i.PointArray(this.attr("points")))
                            },
                            plot: function(t) {
                                return null == t ? this.array() : this.clear().attr("points", "string" == typeof t ? t : this._array = new i.PointArray(t))
                            },
                            clear: function() {
                                return delete this._array, this
                            },
                            move: function(t, e) {
                                return this.attr("points", this.array().move(t, e))
                            },
                            size: function(t, e) {
                                var i = p(this, t, e);
                                return this.attr("points", this.array().size(i.width, i.height))
                            }
                        }), i.extend(i.Line, i.Polyline, i.Polygon, {
                            morphArray: i.PointArray,
                            x: function(t) {
                                return null == t ? this.bbox().x : this.move(t, this.bbox().y)
                            },
                            y: function(t) {
                                return null == t ? this.bbox().y : this.move(this.bbox().x, t)
                            },
                            width: function(t) {
                                var e = this.bbox();
                                return null == t ? e.width : this.size(t, e.height)
                            },
                            height: function(t) {
                                var e = this.bbox();
                                return null == t ? e.height : this.size(e.width, t)
                            }
                        }), i.Path = i.invent({
                            create: "path",
                            inherit: i.Shape,
                            extend: {
                                morphArray: i.PathArray,
                                array: function() {
                                    return this._array || (this._array = new i.PathArray(this.attr("d")))
                                },
                                plot: function(t) {
                                    return null == t ? this.array() : this.clear().attr("d", "string" == typeof t ? t : this._array = new i.PathArray(t))
                                },
                                clear: function() {
                                    return delete this._array, this
                                }
                            },
                            construct: {
                                path: function(t) {
                                    return this.put(new i.Path).plot(t || new i.PathArray)
                                }
                            }
                        }), i.Image = i.invent({
                            create: "image",
                            inherit: i.Shape,
                            extend: {
                                load: function(e) {
                                    if (!e) return this;
                                    var a = this,
                                        s = new t.Image;
                                    return i.on(s, "load", (function() {
                                        i.off(s);
                                        var t = a.parent(i.Pattern);
                                        null !== t && (0 == a.width() && 0 == a.height() && a.size(s.width, s.height), t && 0 == t.width() && 0 == t.height() && t.size(a.width(), a.height()), "function" == typeof a._loaded && a._loaded.call(a, {
                                            width: s.width,
                                            height: s.height,
                                            ratio: s.width / s.height,
                                            url: e
                                        }))
                                    })), i.on(s, "error", (function(t) {
                                        i.off(s), "function" == typeof a._error && a._error.call(a, t)
                                    })), this.attr("href", s.src = this.src = e, i.xlink)
                                },
                                loaded: function(t) {
                                    return this._loaded = t, this
                                },
                                error: function(t) {
                                    return this._error = t, this
                                }
                            },
                            construct: {
                                image: function(t, e, a) {
                                    return this.put(new i.Image).load(t).size(e || 0, a || e || 0)
                                }
                            }
                        }), i.Text = i.invent({
                            create: function() {
                                this.constructor.call(this, i.create("text")), this.dom.leading = new i.Number(1.3), this._rebuild = !0, this._build = !1, this.attr("font-family", i.defaults.attrs["font-family"])
                            },
                            inherit: i.Shape,
                            extend: {
                                x: function(t) {
                                    return null == t ? this.attr("x") : this.attr("x", t)
                                },
                                text: function(t) {
                                    if (void 0 === t) {
                                        t = "";
                                        for (var e = this.node.childNodes, a = 0, s = e.length; a < s; ++a) 0 != a && 3 != e[a].nodeType && 1 == i.adopt(e[a]).dom.newLined && (t += "\n"), t += e[a].textContent;
                                        return t
                                    }
                                    if (this.clear().build(!0), "function" == typeof t) t.call(this, this);
                                    else {
                                        a = 0;
                                        for (var n = (t = t.split("\n")).length; a < n; a++) this.tspan(t[a]).newLine()
                                    }
                                    return this.build(!1).rebuild()
                                },
                                size: function(t) {
                                    return this.attr("font-size", t).rebuild()
                                },
                                leading: function(t) {
                                    return null == t ? this.dom.leading : (this.dom.leading = new i.Number(t), this.rebuild())
                                },
                                lines: function() {
                                    var t = (this.textPath && this.textPath() || this).node,
                                        e = i.utils.map(i.utils.filterSVGElements(t.childNodes), (function(t) {
                                            return i.adopt(t)
                                        }));
                                    return new i.Set(e)
                                },
                                rebuild: function(t) {
                                    if ("boolean" == typeof t && (this._rebuild = t), this._rebuild) {
                                        var e = this,
                                            a = 0,
                                            s = this.dom.leading * new i.Number(this.attr("font-size"));
                                        this.lines().each((function() {
                                            this.dom.newLined && (e.textPath() || this.attr("x", e.attr("x")), "\n" == this.text() ? a += s : (this.attr("dy", s + a), a = 0))
                                        })), this.fire("rebuild")
                                    }
                                    return this
                                },
                                build: function(t) {
                                    return this._build = !!t, this
                                },
                                setData: function(t) {
                                    return this.dom = t, this.dom.leading = new i.Number(t.leading || 1.3), this
                                }
                            },
                            construct: {
                                text: function(t) {
                                    return this.put(new i.Text).text(t)
                                },
                                plain: function(t) {
                                    return this.put(new i.Text).plain(t)
                                }
                            }
                        }), i.Tspan = i.invent({
                            create: "tspan",
                            inherit: i.Shape,
                            extend: {
                                text: function(t) {
                                    return null == t ? this.node.textContent + (this.dom.newLined ? "\n" : "") : ("function" == typeof t ? t.call(this, this) : this.plain(t), this)
                                },
                                dx: function(t) {
                                    return this.attr("dx", t)
                                },
                                dy: function(t) {
                                    return this.attr("dy", t)
                                },
                                newLine: function() {
                                    var t = this.parent(i.Text);
                                    return this.dom.newLined = !0, this.dy(t.dom.leading * t.attr("font-size")).attr("x", t.x())
                                }
                            }
                        }), i.extend(i.Text, i.Tspan, {
                            plain: function(t) {
                                return !1 === this._build && this.clear(), this.node.appendChild(e.createTextNode(t)), this
                            },
                            tspan: function(t) {
                                var e = (this.textPath && this.textPath() || this).node,
                                    a = new i.Tspan;
                                return !1 === this._build && this.clear(), e.appendChild(a.node), a.text(t)
                            },
                            clear: function() {
                                for (var t = (this.textPath && this.textPath() || this).node; t.hasChildNodes();) t.removeChild(t.lastChild);
                                return this
                            },
                            length: function() {
                                return this.node.getComputedTextLength()
                            }
                        }), i.TextPath = i.invent({
                            create: "textPath",
                            inherit: i.Parent,
                            parent: i.Text,
                            construct: {
                                morphArray: i.PathArray,
                                array: function() {
                                    var t = this.track();
                                    return t ? t.array() : null
                                },
                                plot: function(t) {
                                    var e = this.track(),
                                        i = null;
                                    return e && (i = e.plot(t)), null == t ? i : this
                                },
                                track: function() {
                                    var t = this.textPath();
                                    if (t) return t.reference("href")
                                },
                                textPath: function() {
                                    if (this.node.firstChild && "textPath" == this.node.firstChild.nodeName) return i.adopt(this.node.firstChild)
                                }
                            }
                        }), i.Nested = i.invent({
                            create: function() {
                                this.constructor.call(this, i.create("svg")), this.style("overflow", "visible")
                            },
                            inherit: i.Container,
                            construct: {
                                nested: function() {
                                    return this.put(new i.Nested)
                                }
                            }
                        });
                        var l = {
                            stroke: ["color", "width", "opacity", "linecap", "linejoin", "miterlimit", "dasharray", "dashoffset"],
                            fill: ["color", "opacity", "rule"],
                            prefix: function(t, e) {
                                return "color" == e ? t : t + "-" + e
                            }
                        };

                        function c(t, e, a, s) {
                            return a + s.replace(i.regex.dots, " .")
                        }

                        function h(t) {
                            return t.toLowerCase().replace(/-(.)/g, (function(t, e) {
                                return e.toUpperCase()
                            }))
                        }

                        function d(t) {
                            return t.charAt(0).toUpperCase() + t.slice(1)
                        }

                        function u(t) {
                            var e = t.toString(16);
                            return 1 == e.length ? "0" + e : e
                        }

                        function p(t, e, i) {
                            if (null == e || null == i) {
                                var a = t.bbox();
                                null == e ? e = a.width / a.height * i : null == i && (i = a.height / a.width * e)
                            }
                            return {
                                width: e,
                                height: i
                            }
                        }

                        function g(t, e, i) {
                            return {
                                x: e * t.a + i * t.c + 0,
                                y: e * t.b + i * t.d + 0
                            }
                        }

                        function f(t) {
                            return {
                                a: t[0],
                                b: t[1],
                                c: t[2],
                                d: t[3],
                                e: t[4],
                                f: t[5]
                            }
                        }

                        function m(e) {
                            for (var a = e.childNodes.length - 1; a >= 0; a--) e.childNodes[a] instanceof t.SVGElement && m(e.childNodes[a]);
                            return i.adopt(e).id(i.eid(e.nodeName))
                        }

                        function x(t) {
                            return null == t.x && (t.x = 0, t.y = 0, t.width = 0, t.height = 0), t.w = t.width, t.h = t.height, t.x2 = t.x + t.width, t.y2 = t.y + t.height, t.cx = t.x + t.width / 2, t.cy = t.y + t.height / 2, t
                        }

                        function v(t) {
                            return Math.abs(t) > 1e-37 ? t : 0
                        }["fill", "stroke"].forEach((function(t) {
                            var e = {};
                            e[t] = function(e) {
                                if (void 0 === e) return this;
                                if ("string" == typeof e || i.Color.isRgb(e) || e && "function" == typeof e.fill) this.attr(t, e);
                                else
                                    for (var a = l[t].length - 1; a >= 0; a--) null != e[l[t][a]] && this.attr(l.prefix(t, l[t][a]), e[l[t][a]]);
                                return this
                            }, i.extend(i.Element, i.FX, e)
                        })), i.extend(i.Element, i.FX, {
                            translate: function(t, e) {
                                return this.transform({
                                    x: t,
                                    y: e
                                })
                            },
                            matrix: function(t) {
                                return this.attr("transform", new i.Matrix(6 == arguments.length ? [].slice.call(arguments) : t))
                            },
                            opacity: function(t) {
                                return this.attr("opacity", t)
                            },
                            dx: function(t) {
                                return this.x(new i.Number(t).plus(this instanceof i.FX ? 0 : this.x()), !0)
                            },
                            dy: function(t) {
                                return this.y(new i.Number(t).plus(this instanceof i.FX ? 0 : this.y()), !0)
                            }
                        }), i.extend(i.Path, {
                            length: function() {
                                return this.node.getTotalLength()
                            },
                            pointAt: function(t) {
                                return this.node.getPointAtLength(t)
                            }
                        }), i.Set = i.invent({
                            create: function(t) {
                                Array.isArray(t) ? this.members = t : this.clear()
                            },
                            extend: {
                                add: function() {
                                    for (var t = [].slice.call(arguments), e = 0, i = t.length; e < i; e++) this.members.push(t[e]);
                                    return this
                                },
                                remove: function(t) {
                                    var e = this.index(t);
                                    return e > -1 && this.members.splice(e, 1), this
                                },
                                each: function(t) {
                                    for (var e = 0, i = this.members.length; e < i; e++) t.apply(this.members[e], [e, this.members]);
                                    return this
                                },
                                clear: function() {
                                    return this.members = [], this
                                },
                                length: function() {
                                    return this.members.length
                                },
                                has: function(t) {
                                    return this.index(t) >= 0
                                },
                                index: function(t) {
                                    return this.members.indexOf(t)
                                },
                                get: function(t) {
                                    return this.members[t]
                                },
                                first: function() {
                                    return this.get(0)
                                },
                                last: function() {
                                    return this.get(this.members.length - 1)
                                },
                                valueOf: function() {
                                    return this.members
                                }
                            },
                            construct: {
                                set: function(t) {
                                    return new i.Set(t)
                                }
                            }
                        }), i.FX.Set = i.invent({
                            create: function(t) {
                                this.set = t
                            }
                        }), i.Set.inherit = function() {
                            var t = [];
                            for (var e in i.Shape.prototype) "function" == typeof i.Shape.prototype[e] && "function" != typeof i.Set.prototype[e] && t.push(e);
                            for (var e in t.forEach((function(t) {
                                    i.Set.prototype[t] = function() {
                                        for (var e = 0, a = this.members.length; e < a; e++) this.members[e] && "function" == typeof this.members[e][t] && this.members[e][t].apply(this.members[e], arguments);
                                        return "animate" == t ? this.fx || (this.fx = new i.FX.Set(this)) : this
                                    }
                                })), t = [], i.FX.prototype) "function" == typeof i.FX.prototype[e] && "function" != typeof i.FX.Set.prototype[e] && t.push(e);
                            t.forEach((function(t) {
                                i.FX.Set.prototype[t] = function() {
                                    for (var e = 0, i = this.set.members.length; e < i; e++) this.set.members[e].fx[t].apply(this.set.members[e].fx, arguments);
                                    return this
                                }
                            }))
                        }, i.extend(i.Element, {}), i.extend(i.Element, {
                            remember: function(t, e) {
                                if ("object" === r(arguments[0]))
                                    for (var i in t) this.remember(i, t[i]);
                                else {
                                    if (1 == arguments.length) return this.memory()[t];
                                    this.memory()[t] = e
                                }
                                return this
                            },
                            forget: function() {
                                if (0 == arguments.length) this._memory = {};
                                else
                                    for (var t = arguments.length - 1; t >= 0; t--) delete this.memory()[arguments[t]];
                                return this
                            },
                            memory: function() {
                                return this._memory || (this._memory = {})
                            }
                        }), i.get = function(t) {
                            var a = e.getElementById(function(t) {
                                var e = (t || "").toString().match(i.regex.reference);
                                if (e) return e[1]
                            }(t) || t);
                            return i.adopt(a)
                        }, i.select = function(t, a) {
                            return new i.Set(i.utils.map((a || e).querySelectorAll(t), (function(t) {
                                return i.adopt(t)
                            })))
                        }, i.extend(i.Parent, {
                            select: function(t) {
                                return i.select(t, this.node)
                            }
                        });
                        var b = "abcdef".split("");
                        if ("function" != typeof t.CustomEvent) {
                            var y = function(t, i) {
                                i = i || {
                                    bubbles: !1,
                                    cancelable: !1,
                                    detail: void 0
                                };
                                var a = e.createEvent("CustomEvent");
                                return a.initCustomEvent(t, i.bubbles, i.cancelable, i.detail), a
                            };
                            y.prototype = t.Event.prototype, i.CustomEvent = y
                        } else i.CustomEvent = t.CustomEvent;
                        return i
                    }, void 0 !== (a = function() {
                        return Dt(zt, zt.document)
                    }.call(e, i, e, t)) && (t.exports = a),
                    function() {
                        SVG.Filter = SVG.invent({
                            create: "filter",
                            inherit: SVG.Parent,
                            extend: {
                                source: "SourceGraphic",
                                sourceAlpha: "SourceAlpha",
                                background: "BackgroundImage",
                                backgroundAlpha: "BackgroundAlpha",
                                fill: "FillPaint",
                                stroke: "StrokePaint",
                                autoSetIn: !0,
                                put: function(t, e) {
                                    return this.add(t, e), !t.attr("in") && this.autoSetIn && t.attr("in", this.source), t.attr("result") || t.attr("result", t), t
                                },
                                blend: function(t, e, i) {
                                    return this.put(new SVG.BlendEffect(t, e, i))
                                },
                                colorMatrix: function(t, e) {
                                    return this.put(new SVG.ColorMatrixEffect(t, e))
                                },
                                convolveMatrix: function(t) {
                                    return this.put(new SVG.ConvolveMatrixEffect(t))
                                },
                                componentTransfer: function(t) {
                                    return this.put(new SVG.ComponentTransferEffect(t))
                                },
                                composite: function(t, e, i) {
                                    return this.put(new SVG.CompositeEffect(t, e, i))
                                },
                                flood: function(t, e) {
                                    return this.put(new SVG.FloodEffect(t, e))
                                },
                                offset: function(t, e) {
                                    return this.put(new SVG.OffsetEffect(t, e))
                                },
                                image: function(t) {
                                    return this.put(new SVG.ImageEffect(t))
                                },
                                merge: function() {
                                    var t = [void 0];
                                    for (var e in arguments) t.push(arguments[e]);
                                    return this.put(new(SVG.MergeEffect.bind.apply(SVG.MergeEffect, t)))
                                },
                                gaussianBlur: function(t, e) {
                                    return this.put(new SVG.GaussianBlurEffect(t, e))
                                },
                                morphology: function(t, e) {
                                    return this.put(new SVG.MorphologyEffect(t, e))
                                },
                                diffuseLighting: function(t, e, i) {
                                    return this.put(new SVG.DiffuseLightingEffect(t, e, i))
                                },
                                displacementMap: function(t, e, i, a, s) {
                                    return this.put(new SVG.DisplacementMapEffect(t, e, i, a, s))
                                },
                                specularLighting: function(t, e, i, a) {
                                    return this.put(new SVG.SpecularLightingEffect(t, e, i, a))
                                },
                                tile: function() {
                                    return this.put(new SVG.TileEffect)
                                },
                                turbulence: function(t, e, i, a, s) {
                                    return this.put(new SVG.TurbulenceEffect(t, e, i, a, s))
                                },
                                toString: function() {
                                    return "url(#" + this.attr("id") + ")"
                                }
                            }
                        }), SVG.extend(SVG.Defs, {
                            filter: function(t) {
                                var e = this.put(new SVG.Filter);
                                return "function" == typeof t && t.call(e, e), e
                            }
                        }), SVG.extend(SVG.Container, {
                            filter: function(t) {
                                return this.defs().filter(t)
                            }
                        }), SVG.extend(SVG.Element, SVG.G, SVG.Nested, {
                            filter: function(t) {
                                return this.filterer = t instanceof SVG.Element ? t : this.doc().filter(t), this.doc() && this.filterer.doc() !== this.doc() && this.doc().defs().add(this.filterer), this.attr("filter", this.filterer), this.filterer
                            },
                            unfilter: function(t) {
                                return this.filterer && !0 === t && this.filterer.remove(), delete this.filterer, this.attr("filter", null)
                            }
                        }), SVG.Effect = SVG.invent({
                            create: function() {
                                this.constructor.call(this)
                            },
                            inherit: SVG.Element,
                            extend: { in: function(t) {
                                    return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t)
                                },
                                result: function(t) {
                                    return null == t ? this.attr("result") : this.attr("result", t)
                                },
                                toString: function() {
                                    return this.result()
                                }
                            }
                        }), SVG.ParentEffect = SVG.invent({
                            create: function() {
                                this.constructor.call(this)
                            },
                            inherit: SVG.Parent,
                            extend: { in: function(t) {
                                    return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in") + '"]').get(0) || this.attr("in") : this.attr("in", t)
                                },
                                result: function(t) {
                                    return null == t ? this.attr("result") : this.attr("result", t)
                                },
                                toString: function() {
                                    return this.result()
                                }
                            }
                        });
                        var t = {
                            blend: function(t, e) {
                                return this.parent() && this.parent().blend(this, t, e)
                            },
                            colorMatrix: function(t, e) {
                                return this.parent() && this.parent().colorMatrix(t, e).in(this)
                            },
                            convolveMatrix: function(t) {
                                return this.parent() && this.parent().convolveMatrix(t).in(this)
                            },
                            componentTransfer: function(t) {
                                return this.parent() && this.parent().componentTransfer(t).in(this)
                            },
                            composite: function(t, e) {
                                return this.parent() && this.parent().composite(this, t, e)
                            },
                            flood: function(t, e) {
                                return this.parent() && this.parent().flood(t, e)
                            },
                            offset: function(t, e) {
                                return this.parent() && this.parent().offset(t, e).in(this)
                            },
                            image: function(t) {
                                return this.parent() && this.parent().image(t)
                            },
                            merge: function() {
                                return this.parent() && this.parent().merge.apply(this.parent(), [this].concat(arguments))
                            },
                            gaussianBlur: function(t, e) {
                                return this.parent() && this.parent().gaussianBlur(t, e).in(this)
                            },
                            morphology: function(t, e) {
                                return this.parent() && this.parent().morphology(t, e).in(this)
                            },
                            diffuseLighting: function(t, e, i) {
                                return this.parent() && this.parent().diffuseLighting(t, e, i).in(this)
                            },
                            displacementMap: function(t, e, i, a) {
                                return this.parent() && this.parent().displacementMap(this, t, e, i, a)
                            },
                            specularLighting: function(t, e, i, a) {
                                return this.parent() && this.parent().specularLighting(t, e, i, a).in(this)
                            },
                            tile: function() {
                                return this.parent() && this.parent().tile().in(this)
                            },
                            turbulence: function(t, e, i, a, s) {
                                return this.parent() && this.parent().turbulence(t, e, i, a, s).in(this)
                            }
                        };
                        SVG.extend(SVG.Effect, t), SVG.extend(SVG.ParentEffect, t), SVG.ChildEffect = SVG.invent({
                            create: function() {
                                this.constructor.call(this)
                            },
                            inherit: SVG.Element,
                            extend: { in: function(t) {
                                    this.attr("in", t)
                                }
                            }
                        });
                        var e = {
                                blend: function(t, e, i) {
                                    this.attr({ in: t,
                                        in2: e,
                                        mode: i || "normal"
                                    })
                                },
                                colorMatrix: function(t, e) {
                                    "matrix" == t && (e = s(e)), this.attr({
                                        type: t,
                                        values: void 0 === e ? null : e
                                    })
                                },
                                convolveMatrix: function(t) {
                                    t = s(t), this.attr({
                                        order: Math.sqrt(t.split(" ").length),
                                        kernelMatrix: t
                                    })
                                },
                                composite: function(t, e, i) {
                                    this.attr({ in: t,
                                        in2: e,
                                        operator: i
                                    })
                                },
                                flood: function(t, e) {
                                    this.attr("flood-color", t), null != e && this.attr("flood-opacity", e)
                                },
                                offset: function(t, e) {
                                    this.attr({
                                        dx: t,
                                        dy: e
                                    })
                                },
                                image: function(t) {
                                    this.attr("href", t, SVG.xlink)
                                },
                                displacementMap: function(t, e, i, a, s) {
                                    this.attr({ in: t,
                                        in2: e,
                                        scale: i,
                                        xChannelSelector: a,
                                        yChannelSelector: s
                                    })
                                },
                                gaussianBlur: function(t, e) {
                                    null != t || null != e ? this.attr("stdDeviation", n(Array.prototype.slice.call(arguments))) : this.attr("stdDeviation", "0 0")
                                },
                                morphology: function(t, e) {
                                    this.attr({
                                        operator: t,
                                        radius: e
                                    })
                                },
                                tile: function() {},
                                turbulence: function(t, e, i, a, s) {
                                    this.attr({
                                        numOctaves: e,
                                        seed: i,
                                        stitchTiles: a,
                                        baseFrequency: t,
                                        type: s
                                    })
                                }
                            },
                            i = {
                                merge: function() {
                                    var t;
                                    if (arguments[0] instanceof SVG.Set) {
                                        var e = this;
                                        arguments[0].each((function(t) {
                                            this instanceof SVG.MergeNode ? e.put(this) : (this instanceof SVG.Effect || this instanceof SVG.ParentEffect) && e.put(new SVG.MergeNode(this))
                                        }))
                                    } else {
                                        t = Array.isArray(arguments[0]) ? arguments[0] : arguments;
                                        for (var i = 0; i < t.length; i++) t[i] instanceof SVG.MergeNode ? this.put(t[i]) : this.put(new SVG.MergeNode(t[i]))
                                    }
                                },
                                componentTransfer: function(t) {
                                    if (this.rgb = new SVG.Set, ["r", "g", "b", "a"].forEach(function(t) {
                                            this[t] = new(SVG["Func" + t.toUpperCase()])("identity"), this.rgb.add(this[t]), this.node.appendChild(this[t].node)
                                        }.bind(this)), t)
                                        for (var e in t.rgb && (["r", "g", "b"].forEach(function(e) {
                                                this[e].attr(t.rgb)
                                            }.bind(this)), delete t.rgb), t) this[e].attr(t[e])
                                },
                                diffuseLighting: function(t, e, i) {
                                    this.attr({
                                        surfaceScale: t,
                                        diffuseConstant: e,
                                        kernelUnitLength: i
                                    })
                                },
                                specularLighting: function(t, e, i, a) {
                                    this.attr({
                                        surfaceScale: t,
                                        diffuseConstant: e,
                                        specularExponent: i,
                                        kernelUnitLength: a
                                    })
                                }
                            },
                            a = {
                                distantLight: function(t, e) {
                                    this.attr({
                                        azimuth: t,
                                        elevation: e
                                    })
                                },
                                pointLight: function(t, e, i) {
                                    this.attr({
                                        x: t,
                                        y: e,
                                        z: i
                                    })
                                },
                                spotLight: function(t, e, i, a, s, n) {
                                    this.attr({
                                        x: t,
                                        y: e,
                                        z: i,
                                        pointsAtX: a,
                                        pointsAtY: s,
                                        pointsAtZ: n
                                    })
                                },
                                mergeNode: function(t) {
                                    this.attr("in", t)
                                }
                            };

                        function s(t) {
                            return Array.isArray(t) && (t = new SVG.Array(t)), t.toString().replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/g, " ")
                        }

                        function n(t) {
                            if (!Array.isArray(t)) return t;
                            for (var e = 0, i = t.length, a = []; e < i; e++) a.push(t[e]);
                            return a.join(" ")
                        }

                        function r() {
                            var t = function() {};
                            for (var e in "function" == typeof arguments[arguments.length - 1] && (t = arguments[arguments.length - 1], Array.prototype.splice.call(arguments, arguments.length - 1, 1)), arguments)
                                for (var i in arguments[e]) t(arguments[e][i], i, arguments[e])
                        }["r", "g", "b", "a"].forEach((function(t) {
                            a["Func" + t.toUpperCase()] = function(t) {
                                switch (this.attr("type", t), t) {
                                    case "table":
                                        this.attr("tableValues", arguments[1]);
                                        break;
                                    case "linear":
                                        this.attr("slope", arguments[1]), this.attr("intercept", arguments[2]);
                                        break;
                                    case "gamma":
                                        this.attr("amplitude", arguments[1]), this.attr("exponent", arguments[2]), this.attr("offset", arguments[2])
                                }
                            }
                        })), r(e, (function(t, e) {
                            var i = e.charAt(0).toUpperCase() + e.slice(1);
                            SVG[i + "Effect"] = SVG.invent({
                                create: function() {
                                    this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out")
                                },
                                inherit: SVG.Effect,
                                extend: {}
                            })
                        })), r(i, (function(t, e) {
                            var i = e.charAt(0).toUpperCase() + e.slice(1);
                            SVG[i + "Effect"] = SVG.invent({
                                create: function() {
                                    this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments), this.result(this.attr("id") + "Out")
                                },
                                inherit: SVG.ParentEffect,
                                extend: {}
                            })
                        })), r(a, (function(t, e) {
                            var i = e.charAt(0).toUpperCase() + e.slice(1);
                            SVG[i] = SVG.invent({
                                create: function() {
                                    this.constructor.call(this, SVG.create("fe" + i)), t.apply(this, arguments)
                                },
                                inherit: SVG.ChildEffect,
                                extend: {}
                            })
                        })), SVG.extend(SVG.MergeEffect, { in: function(t) {
                                return t instanceof SVG.MergeNode ? this.add(t, 0) : this.add(new SVG.MergeNode(t), 0), this
                            }
                        }), SVG.extend(SVG.CompositeEffect, SVG.BlendEffect, SVG.DisplacementMapEffect, {
                            in2: function(t) {
                                return null == t ? this.parent() && this.parent().select('[result="' + this.attr("in2") + '"]').get(0) || this.attr("in2") : this.attr("in2", t)
                            }
                        }), SVG.filter = {
                            sepiatone: [.343, .669, .119, 0, 0, .249, .626, .13, 0, 0, .172, .334, .111, 0, 0, 0, 0, 0, 1, 0]
                        }
                    }.call(void 0),
                    function() {
                        function t(t, s, n, r, o, l, c) {
                            for (var h = t.slice(s, n || c), d = r.slice(o, l || c), u = 0, p = {
                                    pos: [0, 0],
                                    start: [0, 0]
                                }, g = {
                                    pos: [0, 0],
                                    start: [0, 0]
                                }; h[u] = e.call(p, h[u]), d[u] = e.call(g, d[u]), h[u][0] != d[u][0] || "M" == h[u][0] || "A" == h[u][0] && (h[u][4] != d[u][4] || h[u][5] != d[u][5]) ? (Array.prototype.splice.apply(h, [u, 1].concat(a.call(p, h[u]))), Array.prototype.splice.apply(d, [u, 1].concat(a.call(g, d[u])))) : (h[u] = i.call(p, h[u]), d[u] = i.call(g, d[u])), ++u != h.length || u != d.length;) u == h.length && h.push(["C", p.pos[0], p.pos[1], p.pos[0], p.pos[1], p.pos[0], p.pos[1]]), u == d.length && d.push(["C", g.pos[0], g.pos[1], g.pos[0], g.pos[1], g.pos[0], g.pos[1]]);
                            return {
                                start: h,
                                dest: d
                            }
                        }

                        function e(t) {
                            switch (t[0]) {
                                case "z":
                                case "Z":
                                    t[0] = "L", t[1] = this.start[0], t[2] = this.start[1];
                                    break;
                                case "H":
                                    t[0] = "L", t[2] = this.pos[1];
                                    break;
                                case "V":
                                    t[0] = "L", t[2] = t[1], t[1] = this.pos[0];
                                    break;
                                case "T":
                                    t[0] = "Q", t[3] = t[1], t[4] = t[2], t[1] = this.reflection[1], t[2] = this.reflection[0];
                                    break;
                                case "S":
                                    t[0] = "C", t[6] = t[4], t[5] = t[3], t[4] = t[2], t[3] = t[1], t[2] = this.reflection[1], t[1] = this.reflection[0]
                            }
                            return t
                        }

                        function i(t) {
                            var e = t.length;
                            return this.pos = [t[e - 2], t[e - 1]], -1 != "SCQT".indexOf(t[0]) && (this.reflection = [2 * this.pos[0] - t[e - 4], 2 * this.pos[1] - t[e - 3]]), t
                        }

                        function a(t) {
                            var e = [t];
                            switch (t[0]) {
                                case "M":
                                    return this.pos = this.start = [t[1], t[2]], e;
                                case "L":
                                    t[5] = t[3] = t[1], t[6] = t[4] = t[2], t[1] = this.pos[0], t[2] = this.pos[1];
                                    break;
                                case "Q":
                                    t[6] = t[4], t[5] = t[3], t[4] = 1 * t[4] / 3 + 2 * t[2] / 3, t[3] = 1 * t[3] / 3 + 2 * t[1] / 3, t[2] = 1 * this.pos[1] / 3 + 2 * t[2] / 3, t[1] = 1 * this.pos[0] / 3 + 2 * t[1] / 3;
                                    break;
                                case "A":
                                    t = (e = function(t, e) {
                                        var i, a, s, n, r, o, l, c, h, d, u, p, g, f, m, x, v, b, y, w, S, C, k, A, E, T, P = Math.abs(e[1]),
                                            M = Math.abs(e[2]),
                                            L = e[3] % 360,
                                            I = e[4],
                                            _ = e[5],
                                            z = e[6],
                                            D = e[7],
                                            X = new SVG.Point(t),
                                            O = new SVG.Point(z, D),
                                            N = [];
                                        if (0 === P || 0 === M || X.x === O.x && X.y === O.y) return [
                                            ["C", X.x, X.y, O.x, O.y, O.x, O.y]
                                        ];
                                        for ((a = (i = new SVG.Point((X.x - O.x) / 2, (X.y - O.y) / 2).transform((new SVG.Matrix).rotate(L))).x * i.x / (P * P) + i.y * i.y / (M * M)) > 1 && (P *= a = Math.sqrt(a), M *= a), s = (new SVG.Matrix).rotate(L).scale(1 / P, 1 / M).rotate(-L), X = X.transform(s), o = (n = [(O = O.transform(s)).x - X.x, O.y - X.y])[0] * n[0] + n[1] * n[1], r = Math.sqrt(o), n[0] /= r, n[1] /= r, l = o < 4 ? Math.sqrt(1 - o / 4) : 0, I === _ && (l *= -1), c = new SVG.Point((O.x + X.x) / 2 + l * -n[1], (O.y + X.y) / 2 + l * n[0]), h = new SVG.Point(X.x - c.x, X.y - c.y), d = new SVG.Point(O.x - c.x, O.y - c.y), u = Math.acos(h.x / Math.sqrt(h.x * h.x + h.y * h.y)), h.y < 0 && (u *= -1), p = Math.acos(d.x / Math.sqrt(d.x * d.x + d.y * d.y)), d.y < 0 && (p *= -1), _ && u > p && (p += 2 * Math.PI), !_ && u < p && (p -= 2 * Math.PI), x = [], v = u, g = (p - u) / (f = Math.ceil(2 * Math.abs(u - p) / Math.PI)), m = 4 * Math.tan(g / 4) / 3, S = 0; S <= f; S++) y = Math.cos(v), b = Math.sin(v), w = new SVG.Point(c.x + y, c.y + b), x[S] = [new SVG.Point(w.x + m * b, w.y - m * y), w, new SVG.Point(w.x - m * b, w.y + m * y)], v += g;
                                        for (x[0][0] = x[0][1].clone(), x[x.length - 1][2] = x[x.length - 1][1].clone(), s = (new SVG.Matrix).rotate(L).scale(P, M).rotate(-L), S = 0, C = x.length; S < C; S++) x[S][0] = x[S][0].transform(s), x[S][1] = x[S][1].transform(s), x[S][2] = x[S][2].transform(s);
                                        for (S = 1, C = x.length; S < C; S++) k = (w = x[S - 1][2]).x, A = w.y, E = (w = x[S][0]).x, T = w.y, z = (w = x[S][1]).x, D = w.y, N.push(["C", k, A, E, T, z, D]);
                                        return N
                                    }(this.pos, t))[0]
                            }
                            return t[0] = "C", this.pos = [t[5], t[6]], this.reflection = [2 * t[5] - t[3], 2 * t[6] - t[4]], e
                        }

                        function s(t, e) {
                            if (!1 === e) return !1;
                            for (var i = e, a = t.length; i < a; ++i)
                                if ("M" == t[i][0]) return i;
                            return !1
                        }
                        SVG.extend(SVG.PathArray, {
                            morph: function(e) {
                                for (var i = this.value, a = this.parse(e), n = 0, r = 0, o = !1, l = !1; !1 !== n || !1 !== r;) {
                                    var c;
                                    o = s(i, !1 !== n && n + 1), l = s(a, !1 !== r && r + 1), !1 === n && (n = 0 == (c = new SVG.PathArray(h.start).bbox()).height || 0 == c.width ? i.push(i[0]) - 1 : i.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1), !1 === r && (r = 0 == (c = new SVG.PathArray(h.dest).bbox()).height || 0 == c.width ? a.push(a[0]) - 1 : a.push(["M", c.x + c.width / 2, c.y + c.height / 2]) - 1);
                                    var h = t(i, n, o, a, r, l);
                                    i = i.slice(0, n).concat(h.start, !1 === o ? [] : i.slice(o)), a = a.slice(0, r).concat(h.dest, !1 === l ? [] : a.slice(l)), n = !1 !== o && n + h.start.length, r = !1 !== l && r + h.dest.length
                                }
                                return this.value = i, this.destination = new SVG.PathArray, this.destination.value = a, this
                            }
                        })
                    }(),
                    function() {
                        function t(t) {
                            t.remember("_draggable", this), this.el = t
                        }
                        t.prototype.init = function(t, e) {
                            var i = this;
                            this.constraint = t, this.value = e, this.el.on("mousedown.drag", (function(t) {
                                i.start(t)
                            })), this.el.on("touchstart.drag", (function(t) {
                                i.start(t)
                            }))
                        }, t.prototype.transformPoint = function(t, e) {
                            var i = (t = t || window.event).changedTouches && t.changedTouches[0] || t;
                            return this.p.x = i.clientX - (e || 0), this.p.y = i.clientY, this.p.matrixTransform(this.m)
                        }, t.prototype.getBBox = function() {
                            var t = this.el.bbox();
                            return this.el instanceof SVG.Nested && (t = this.el.rbox()), (this.el instanceof SVG.G || this.el instanceof SVG.Use || this.el instanceof SVG.Nested) && (t.x = this.el.x(), t.y = this.el.y()), t
                        }, t.prototype.start = function(t) {
                            if ("click" != t.type && "mousedown" != t.type && "mousemove" != t.type || 1 == (t.which || t.buttons)) {
                                var e = this;
                                if (this.el.fire("beforedrag", {
                                        event: t,
                                        handler: this
                                    }), !this.el.event().defaultPrevented) {
                                    t.preventDefault(), t.stopPropagation(), this.parent = this.parent || this.el.parent(SVG.Nested) || this.el.parent(SVG.Doc), this.p = this.parent.node.createSVGPoint(), this.m = this.el.node.getScreenCTM().inverse();
                                    var i, a = this.getBBox();
                                    if (this.el instanceof SVG.Text) switch (i = this.el.node.getComputedTextLength(), this.el.attr("text-anchor")) {
                                        case "middle":
                                            i /= 2;
                                            break;
                                        case "start":
                                            i = 0
                                    }
                                    this.startPoints = {
                                        point: this.transformPoint(t, i),
                                        box: a,
                                        transform: this.el.transform()
                                    }, SVG.on(window, "mousemove.drag", (function(t) {
                                        e.drag(t)
                                    })), SVG.on(window, "touchmove.drag", (function(t) {
                                        e.drag(t)
                                    })), SVG.on(window, "mouseup.drag", (function(t) {
                                        e.end(t)
                                    })), SVG.on(window, "touchend.drag", (function(t) {
                                        e.end(t)
                                    })), this.el.fire("dragstart", {
                                        event: t,
                                        p: this.startPoints.point,
                                        m: this.m,
                                        handler: this
                                    })
                                }
                            }
                        }, t.prototype.drag = function(t) {
                            var e = this.getBBox(),
                                i = this.transformPoint(t),
                                a = this.startPoints.box.x + i.x - this.startPoints.point.x,
                                s = this.startPoints.box.y + i.y - this.startPoints.point.y,
                                n = this.constraint,
                                r = i.x - this.startPoints.point.x,
                                o = i.y - this.startPoints.point.y;
                            if (this.el.fire("dragmove", {
                                    event: t,
                                    p: i,
                                    m: this.m,
                                    handler: this
                                }), this.el.event().defaultPrevented) return i;
                            if ("function" == typeof n) {
                                var l = n.call(this.el, a, s, this.m);
                                "boolean" == typeof l && (l = {
                                    x: l,
                                    y: l
                                }), !0 === l.x ? this.el.x(a) : !1 !== l.x && this.el.x(l.x), !0 === l.y ? this.el.y(s) : !1 !== l.y && this.el.y(l.y)
                            } else "object" == typeof n && (null != n.minX && a < n.minX ? r = (a = n.minX) - this.startPoints.box.x : null != n.maxX && a > n.maxX - e.width && (r = (a = n.maxX - e.width) - this.startPoints.box.x), null != n.minY && s < n.minY ? o = (s = n.minY) - this.startPoints.box.y : null != n.maxY && s > n.maxY - e.height && (o = (s = n.maxY - e.height) - this.startPoints.box.y), null != n.snapToGrid && (a -= a % n.snapToGrid, s -= s % n.snapToGrid, r -= r % n.snapToGrid, o -= o % n.snapToGrid), this.el instanceof SVG.G ? this.el.matrix(this.startPoints.transform).transform({
                                x: r,
                                y: o
                            }, !0) : this.el.move(a, s));
                            return i
                        }, t.prototype.end = function(t) {
                            var e = this.drag(t);
                            this.el.fire("dragend", {
                                event: t,
                                p: e,
                                m: this.m,
                                handler: this
                            }), SVG.off(window, "mousemove.drag"), SVG.off(window, "touchmove.drag"), SVG.off(window, "mouseup.drag"), SVG.off(window, "touchend.drag")
                        }, SVG.extend(SVG.Element, {
                            draggable: function(e, i) {
                                "function" != typeof e && "object" != typeof e || (i = e, e = !0);
                                var a = this.remember("_draggable") || new t(this);
                                return (e = void 0 === e || e) ? a.init(i || {}, e) : (this.off("mousedown.drag"), this.off("touchstart.drag")), this
                            }
                        })
                    }.call(void 0),
                    function() {
                        function t(t) {
                            this.el = t, t.remember("_selectHandler", this), this.pointSelection = {
                                isSelected: !1
                            }, this.rectSelection = {
                                isSelected: !1
                            }, this.pointsList = {
                                lt: [0, 0],
                                rt: ["width", 0],
                                rb: ["width", "height"],
                                lb: [0, "height"],
                                t: ["width", 0],
                                r: ["width", "height"],
                                b: ["width", "height"],
                                l: [0, "height"]
                            }, this.pointCoord = function(t, e, i) {
                                var a = "string" != typeof t ? t : e[t];
                                return i ? a / 2 : a
                            }, this.pointCoords = function(t, e) {
                                var i = this.pointsList[t];
                                return {
                                    x: this.pointCoord(i[0], e, "t" === t || "b" === t),
                                    y: this.pointCoord(i[1], e, "r" === t || "l" === t)
                                }
                            }
                        }
                        t.prototype.init = function(t, e) {
                            var i = this.el.bbox();
                            this.options = {};
                            var a = this.el.selectize.defaults.points;
                            for (var s in this.el.selectize.defaults) this.options[s] = this.el.selectize.defaults[s], void 0 !== e[s] && (this.options[s] = e[s]);
                            var n = ["points", "pointsExclude"];
                            for (var s in n) {
                                var r = this.options[n[s]];
                                "string" == typeof r ? r = r.length > 0 ? r.split(/\s*,\s*/i) : [] : "boolean" == typeof r && "points" === n[s] && (r = r ? a : []), this.options[n[s]] = r
                            }
                            this.options.points = [a, this.options.points].reduce((function(t, e) {
                                return t.filter((function(t) {
                                    return e.indexOf(t) > -1
                                }))
                            })), this.options.points = [this.options.points, this.options.pointsExclude].reduce((function(t, e) {
                                return t.filter((function(t) {
                                    return e.indexOf(t) < 0
                                }))
                            })), this.parent = this.el.parent(), this.nested = this.nested || this.parent.group(), this.nested.matrix(new SVG.Matrix(this.el).translate(i.x, i.y)), this.options.deepSelect && -1 !== ["line", "polyline", "polygon"].indexOf(this.el.type) ? this.selectPoints(t) : this.selectRect(t), this.observe(), this.cleanup()
                        }, t.prototype.selectPoints = function(t) {
                            return this.pointSelection.isSelected = t, this.pointSelection.set || (this.pointSelection.set = this.parent.set(), this.drawPoints()), this
                        }, t.prototype.getPointArray = function() {
                            var t = this.el.bbox();
                            return this.el.array().valueOf().map((function(e) {
                                return [e[0] - t.x, e[1] - t.y]
                            }))
                        }, t.prototype.drawPoints = function() {
                            for (var t = this, e = this.getPointArray(), i = 0, a = e.length; i < a; ++i) {
                                var s = function(e) {
                                        return function(i) {
                                            (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation();
                                            var a = i.pageX || i.touches[0].pageX,
                                                s = i.pageY || i.touches[0].pageY;
                                            t.el.fire("point", {
                                                x: a,
                                                y: s,
                                                i: e,
                                                event: i
                                            })
                                        }
                                    }(i),
                                    n = this.drawPoint(e[i][0], e[i][1]).addClass(this.options.classPoints).addClass(this.options.classPoints + "_point").on("touchstart", s).on("mousedown", s);
                                this.pointSelection.set.add(n)
                            }
                        }, t.prototype.drawPoint = function(t, e) {
                            var i = this.options.pointType;
                            switch (i) {
                                case "circle":
                                    return this.drawCircle(t, e);
                                case "rect":
                                    return this.drawRect(t, e);
                                default:
                                    if ("function" == typeof i) return i.call(this, t, e);
                                    throw new Error("Unknown " + i + " point type!")
                            }
                        }, t.prototype.drawCircle = function(t, e) {
                            return this.nested.circle(this.options.pointSize).center(t, e)
                        }, t.prototype.drawRect = function(t, e) {
                            return this.nested.rect(this.options.pointSize, this.options.pointSize).center(t, e)
                        }, t.prototype.updatePointSelection = function() {
                            var t = this.getPointArray();
                            this.pointSelection.set.each((function(e) {
                                this.cx() === t[e][0] && this.cy() === t[e][1] || this.center(t[e][0], t[e][1])
                            }))
                        }, t.prototype.updateRectSelection = function() {
                            var t = this,
                                e = this.el.bbox();
                            if (this.rectSelection.set.get(0).attr({
                                    width: e.width,
                                    height: e.height
                                }), this.options.points.length && this.options.points.map((function(i, a) {
                                    var s = t.pointCoords(i, e);
                                    t.rectSelection.set.get(a + 1).center(s.x, s.y)
                                })), this.options.rotationPoint) {
                                var i = this.rectSelection.set.length();
                                this.rectSelection.set.get(i - 1).center(e.width / 2, 20)
                            }
                        }, t.prototype.selectRect = function(t) {
                            var e = this,
                                i = this.el.bbox();

                            function a(t) {
                                return function(i) {
                                    (i = i || window.event).preventDefault ? i.preventDefault() : i.returnValue = !1, i.stopPropagation();
                                    var a = i.pageX || i.touches[0].pageX,
                                        s = i.pageY || i.touches[0].pageY;
                                    e.el.fire(t, {
                                        x: a,
                                        y: s,
                                        event: i
                                    })
                                }
                            }
                            if (this.rectSelection.isSelected = t, this.rectSelection.set = this.rectSelection.set || this.parent.set(), this.rectSelection.set.get(0) || this.rectSelection.set.add(this.nested.rect(i.width, i.height).addClass(this.options.classRect)), this.options.points.length && this.rectSelection.set.length() < 2 && (this.options.points.map((function(t, s) {
                                    var n = e.pointCoords(t, i),
                                        r = e.drawPoint(n.x, n.y).attr("class", e.options.classPoints + "_" + t).on("mousedown", a(t)).on("touchstart", a(t));
                                    e.rectSelection.set.add(r)
                                })), this.rectSelection.set.each((function() {
                                    this.addClass(e.options.classPoints)
                                }))), this.options.rotationPoint && (this.options.points && !this.rectSelection.set.get(9) || !this.options.points && !this.rectSelection.set.get(1))) {
                                var s = function(t) {
                                        (t = t || window.event).preventDefault ? t.preventDefault() : t.returnValue = !1, t.stopPropagation();
                                        var i = t.pageX || t.touches[0].pageX,
                                            a = t.pageY || t.touches[0].pageY;
                                        e.el.fire("rot", {
                                            x: i,
                                            y: a,
                                            event: t
                                        })
                                    },
                                    n = this.drawPoint(i.width / 2, 20).attr("class", this.options.classPoints + "_rot").on("touchstart", s).on("mousedown", s);
                                this.rectSelection.set.add(n)
                            }
                        }, t.prototype.handler = function() {
                            var t = this.el.bbox();
                            this.nested.matrix(new SVG.Matrix(this.el).translate(t.x, t.y)), this.rectSelection.isSelected && this.updateRectSelection(), this.pointSelection.isSelected && this.updatePointSelection()
                        }, t.prototype.observe = function() {
                            var t = this;
                            if (MutationObserver)
                                if (this.rectSelection.isSelected || this.pointSelection.isSelected) this.observerInst = this.observerInst || new MutationObserver((function() {
                                    t.handler()
                                })), this.observerInst.observe(this.el.node, {
                                    attributes: !0
                                });
                                else try {
                                    this.observerInst.disconnect(), delete this.observerInst
                                } catch (t) {} else this.el.off("DOMAttrModified.select"), (this.rectSelection.isSelected || this.pointSelection.isSelected) && this.el.on("DOMAttrModified.select", (function() {
                                    t.handler()
                                }))
                        }, t.prototype.cleanup = function() {
                            !this.rectSelection.isSelected && this.rectSelection.set && (this.rectSelection.set.each((function() {
                                this.remove()
                            })), this.rectSelection.set.clear(), delete this.rectSelection.set), !this.pointSelection.isSelected && this.pointSelection.set && (this.pointSelection.set.each((function() {
                                this.remove()
                            })), this.pointSelection.set.clear(), delete this.pointSelection.set), this.pointSelection.isSelected || this.rectSelection.isSelected || (this.nested.remove(), delete this.nested)
                        }, SVG.extend(SVG.Element, {
                            selectize: function(e, i) {
                                return "object" == typeof e && (i = e, e = !0), (this.remember("_selectHandler") || new t(this)).init(void 0 === e || e, i || {}), this
                            }
                        }), SVG.Element.prototype.selectize.defaults = {
                            points: ["lt", "rt", "rb", "lb", "t", "r", "b", "l"],
                            pointsExclude: [],
                            classRect: "svg_select_boundingRect",
                            classPoints: "svg_select_points",
                            pointSize: 7,
                            rotationPoint: !0,
                            deepSelect: !1,
                            pointType: "circle"
                        }
                    }(),
                    function() {
                        (function() {
                            function t(t) {
                                t.remember("_resizeHandler", this), this.el = t, this.parameters = {}, this.lastUpdateCall = null, this.p = t.doc().node.createSVGPoint()
                            }
                            t.prototype.transformPoint = function(t, e, i) {
                                return this.p.x = t - (this.offset.x - window.pageXOffset), this.p.y = e - (this.offset.y - window.pageYOffset), this.p.matrixTransform(i || this.m)
                            }, t.prototype._extractPosition = function(t) {
                                return {
                                    x: null != t.clientX ? t.clientX : t.touches[0].clientX,
                                    y: null != t.clientY ? t.clientY : t.touches[0].clientY
                                }
                            }, t.prototype.init = function(t) {
                                var e = this;
                                if (this.stop(), "stop" !== t) {
                                    for (var i in this.options = {}, this.el.resize.defaults) this.options[i] = this.el.resize.defaults[i], void 0 !== t[i] && (this.options[i] = t[i]);
                                    this.el.on("lt.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("rt.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("rb.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("lb.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("t.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("r.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("b.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("l.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("rot.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.el.on("point.resize", (function(t) {
                                        e.resize(t || window.event)
                                    })), this.update()
                                }
                            }, t.prototype.stop = function() {
                                return this.el.off("lt.resize"), this.el.off("rt.resize"), this.el.off("rb.resize"), this.el.off("lb.resize"), this.el.off("t.resize"), this.el.off("r.resize"), this.el.off("b.resize"), this.el.off("l.resize"), this.el.off("rot.resize"), this.el.off("point.resize"), this
                            }, t.prototype.resize = function(t) {
                                var e = this;
                                this.m = this.el.node.getScreenCTM().inverse(), this.offset = {
                                    x: window.pageXOffset,
                                    y: window.pageYOffset
                                };
                                var i = this._extractPosition(t.detail.event);
                                if (this.parameters = {
                                        type: this.el.type,
                                        p: this.transformPoint(i.x, i.y),
                                        x: t.detail.x,
                                        y: t.detail.y,
                                        box: this.el.bbox(),
                                        rotation: this.el.transform().rotation
                                    }, "text" === this.el.type && (this.parameters.fontSize = this.el.attr()["font-size"]), void 0 !== t.detail.i) {
                                    var a = this.el.array().valueOf();
                                    this.parameters.i = t.detail.i, this.parameters.pointCoords = [a[t.detail.i][0], a[t.detail.i][1]]
                                }
                                switch (t.type) {
                                    case "lt":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e);
                                            if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
                                                i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y + i[1]).size(this.parameters.box.width - i[0], this.parameters.box.height - i[1])
                                            }
                                        };
                                        break;
                                    case "rt":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 2);
                                            if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height - i[1] > 0) {
                                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
                                                i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).size(this.parameters.box.width + i[0], this.parameters.box.height - i[1])
                                            }
                                        };
                                        break;
                                    case "rb":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 0);
                                            if (this.parameters.box.width + i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x - i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize + i[0]);
                                                i = this.checkAspectRatio(i), this.el.move(this.parameters.box.x, this.parameters.box.y).size(this.parameters.box.width + i[0], this.parameters.box.height + i[1])
                                            }
                                        };
                                        break;
                                    case "lb":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 1);
                                            if (this.parameters.box.width - i[0] > 0 && this.parameters.box.height + i[1] > 0) {
                                                if ("text" === this.parameters.type) return this.el.move(this.parameters.box.x + i[0], this.parameters.box.y), void this.el.attr("font-size", this.parameters.fontSize - i[0]);
                                                i = this.checkAspectRatio(i, !0), this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).size(this.parameters.box.width - i[0], this.parameters.box.height + i[1])
                                            }
                                        };
                                        break;
                                    case "t":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 2);
                                            if (this.parameters.box.height - i[1] > 0) {
                                                if ("text" === this.parameters.type) return;
                                                this.el.move(this.parameters.box.x, this.parameters.box.y + i[1]).height(this.parameters.box.height - i[1])
                                            }
                                        };
                                        break;
                                    case "r":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 0);
                                            if (this.parameters.box.width + i[0] > 0) {
                                                if ("text" === this.parameters.type) return;
                                                this.el.move(this.parameters.box.x, this.parameters.box.y).width(this.parameters.box.width + i[0])
                                            }
                                        };
                                        break;
                                    case "b":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 0);
                                            if (this.parameters.box.height + i[1] > 0) {
                                                if ("text" === this.parameters.type) return;
                                                this.el.move(this.parameters.box.x, this.parameters.box.y).height(this.parameters.box.height + i[1])
                                            }
                                        };
                                        break;
                                    case "l":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, 1);
                                            if (this.parameters.box.width - i[0] > 0) {
                                                if ("text" === this.parameters.type) return;
                                                this.el.move(this.parameters.box.x + i[0], this.parameters.box.y).width(this.parameters.box.width - i[0])
                                            }
                                        };
                                        break;
                                    case "rot":
                                        this.calc = function(t, e) {
                                            var i = t + this.parameters.p.x,
                                                a = e + this.parameters.p.y,
                                                s = Math.atan2(this.parameters.p.y - this.parameters.box.y - this.parameters.box.height / 2, this.parameters.p.x - this.parameters.box.x - this.parameters.box.width / 2),
                                                n = Math.atan2(a - this.parameters.box.y - this.parameters.box.height / 2, i - this.parameters.box.x - this.parameters.box.width / 2),
                                                r = this.parameters.rotation + 180 * (n - s) / Math.PI + this.options.snapToAngle / 2;
                                            this.el.center(this.parameters.box.cx, this.parameters.box.cy).rotate(r - r % this.options.snapToAngle, this.parameters.box.cx, this.parameters.box.cy)
                                        };
                                        break;
                                    case "point":
                                        this.calc = function(t, e) {
                                            var i = this.snapToGrid(t, e, this.parameters.pointCoords[0], this.parameters.pointCoords[1]),
                                                a = this.el.array().valueOf();
                                            a[this.parameters.i][0] = this.parameters.pointCoords[0] + i[0], a[this.parameters.i][1] = this.parameters.pointCoords[1] + i[1], this.el.plot(a)
                                        }
                                }
                                this.el.fire("resizestart", {
                                    dx: this.parameters.x,
                                    dy: this.parameters.y,
                                    event: t
                                }), SVG.on(window, "touchmove.resize", (function(t) {
                                    e.update(t || window.event)
                                })), SVG.on(window, "touchend.resize", (function() {
                                    e.done()
                                })), SVG.on(window, "mousemove.resize", (function(t) {
                                    e.update(t || window.event)
                                })), SVG.on(window, "mouseup.resize", (function() {
                                    e.done()
                                }))
                            }, t.prototype.update = function(t) {
                                if (t) {
                                    var e = this._extractPosition(t),
                                        i = this.transformPoint(e.x, e.y),
                                        a = i.x - this.parameters.p.x,
                                        s = i.y - this.parameters.p.y;
                                    this.lastUpdateCall = [a, s], this.calc(a, s), this.el.fire("resizing", {
                                        dx: a,
                                        dy: s,
                                        event: t
                                    })
                                } else this.lastUpdateCall && this.calc(this.lastUpdateCall[0], this.lastUpdateCall[1])
                            }, t.prototype.done = function() {
                                this.lastUpdateCall = null, SVG.off(window, "mousemove.resize"), SVG.off(window, "mouseup.resize"), SVG.off(window, "touchmove.resize"), SVG.off(window, "touchend.resize"), this.el.fire("resizedone")
                            }, t.prototype.snapToGrid = function(t, e, i, a) {
                                var s;
                                return void 0 !== a ? s = [(i + t) % this.options.snapToGrid, (a + e) % this.options.snapToGrid] : (i = null == i ? 3 : i, s = [(this.parameters.box.x + t + (1 & i ? 0 : this.parameters.box.width)) % this.options.snapToGrid, (this.parameters.box.y + e + (2 & i ? 0 : this.parameters.box.height)) % this.options.snapToGrid]), t < 0 && (s[0] -= this.options.snapToGrid), e < 0 && (s[1] -= this.options.snapToGrid), t -= Math.abs(s[0]) < this.options.snapToGrid / 2 ? s[0] : s[0] - (t < 0 ? -this.options.snapToGrid : this.options.snapToGrid), e -= Math.abs(s[1]) < this.options.snapToGrid / 2 ? s[1] : s[1] - (e < 0 ? -this.options.snapToGrid : this.options.snapToGrid), this.constraintToBox(t, e, i, a)
                            }, t.prototype.constraintToBox = function(t, e, i, a) {
                                var s, n, r = this.options.constraint || {};
                                return void 0 !== a ? (s = i, n = a) : (s = this.parameters.box.x + (1 & i ? 0 : this.parameters.box.width), n = this.parameters.box.y + (2 & i ? 0 : this.parameters.box.height)), void 0 !== r.minX && s + t < r.minX && (t = r.minX - s), void 0 !== r.maxX && s + t > r.maxX && (t = r.maxX - s), void 0 !== r.minY && n + e < r.minY && (e = r.minY - n), void 0 !== r.maxY && n + e > r.maxY && (e = r.maxY - n), [t, e]
                            }, t.prototype.checkAspectRatio = function(t, e) {
                                if (!this.options.saveAspectRatio) return t;
                                var i = t.slice(),
                                    a = this.parameters.box.width / this.parameters.box.height,
                                    s = this.parameters.box.width + t[0],
                                    n = this.parameters.box.height - t[1],
                                    r = s / n;
                                return r < a ? (i[1] = s / a - this.parameters.box.height, e && (i[1] = -i[1])) : r > a && (i[0] = this.parameters.box.width - n * a, e && (i[0] = -i[0])), i
                            }, SVG.extend(SVG.Element, {
                                resize: function(e) {
                                    return (this.remember("_resizeHandler") || new t(this)).init(e || {}), this
                                }
                            }), SVG.Element.prototype.resize.defaults = {
                                snapToAngle: .1,
                                snapToGrid: 1,
                                constraint: {},
                                saveAspectRatio: !1
                            }
                        }).call(this)
                    }(), void 0 === window.Apex && (window.Apex = {});
                var Ft = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "initModules",
                            value: function() {
                                this.ctx.publicMethods = ["updateOptions", "updateSeries", "appendData", "appendSeries", "toggleSeries", "showSeries", "hideSeries", "setLocale", "resetSeries", "zoomX", "toggleDataPointSelection", "dataURI", "exportToCSV", "addXaxisAnnotation", "addYaxisAnnotation", "addPointAnnotation", "clearAnnotations", "removeAnnotation", "paper", "destroy"], this.ctx.eventList = ["click", "mousedown", "mousemove", "mouseleave", "touchstart", "touchmove", "touchleave", "mouseup", "touchend"], this.ctx.animations = new y(this.ctx), this.ctx.axes = new it(this.ctx), this.ctx.core = new Nt(this.ctx.el, this.ctx), this.ctx.config = new W({}), this.ctx.data = new G(this.ctx), this.ctx.grid = new Z(this.ctx), this.ctx.graphics = new S(this.ctx), this.ctx.coreUtils = new C(this.ctx), this.ctx.crosshairs = new at(this.ctx), this.ctx.events = new tt(this.ctx), this.ctx.exports = new U(this.ctx), this.ctx.localization = new et(this.ctx), this.ctx.options = new M, this.ctx.responsive = new st(this.ctx), this.ctx.series = new O(this.ctx), this.ctx.theme = new nt(this.ctx), this.ctx.formatters = new V(this.ctx), this.ctx.titleSubtitle = new rt(this.ctx), this.ctx.legend = new pt(this.ctx), this.ctx.toolbar = new gt(this.ctx), this.ctx.dimensions = new dt(this.ctx), this.ctx.updateHelpers = new Yt(this.ctx), this.ctx.zoomPanSelection = new ft(this.ctx), this.ctx.w.globals.tooltip = new St(this.ctx)
                            }
                        }]), t
                    }(),
                    Rt = function() {
                        function t(e) {
                            o(this, t), this.ctx = e, this.w = e.w
                        }
                        return c(t, [{
                            key: "clear",
                            value: function(t) {
                                var e = t.isUpdating;
                                this.ctx.zoomPanSelection && this.ctx.zoomPanSelection.destroy(), this.ctx.toolbar && this.ctx.toolbar.destroy(), this.ctx.animations = null, this.ctx.axes = null, this.ctx.annotations = null, this.ctx.core = null, this.ctx.data = null, this.ctx.grid = null, this.ctx.series = null, this.ctx.responsive = null, this.ctx.theme = null, this.ctx.formatters = null, this.ctx.titleSubtitle = null, this.ctx.legend = null, this.ctx.dimensions = null, this.ctx.options = null, this.ctx.crosshairs = null, this.ctx.zoomPanSelection = null, this.ctx.updateHelpers = null, this.ctx.toolbar = null, this.ctx.localization = null, this.ctx.w.globals.tooltip = null, this.clearDomElements({
                                    isUpdating: e
                                })
                            }
                        }, {
                            key: "killSVG",
                            value: function(t) {
                                t.each((function(t, e) {
                                    this.removeClass("*"), this.off(), this.stop()
                                }), !0), t.ungroup(), t.clear()
                            }
                        }, {
                            key: "clearDomElements",
                            value: function(t) {
                                var e = this,
                                    i = t.isUpdating,
                                    a = this.w.globals.dom.Paper.node;
                                a.parentNode && a.parentNode.parentNode && !i && (a.parentNode.parentNode.style.minHeight = "unset");
                                var s = this.w.globals.dom.baseEl;
                                s && this.ctx.eventList.forEach((function(t) {
                                    s.removeEventListener(t, e.ctx.events.documentEvent)
                                }));
                                var n = this.w.globals.dom;
                                if (null !== this.ctx.el)
                                    for (; this.ctx.el.firstChild;) this.ctx.el.removeChild(this.ctx.el.firstChild);
                                this.killSVG(n.Paper), n.Paper.remove(), n.elWrap = null, n.elGraphical = null, n.elAnnotations = null, n.elLegendWrap = null, n.baseEl = null, n.elGridRect = null, n.elGridRectMask = null, n.elGridRectMarkerMask = null, n.elForecastMask = null, n.elNonForecastMask = null, n.elDefs = null
                            }
                        }]), t
                    }(),
                    Ht = new WeakMap,
                    Wt = function() {
                        function t(e, i) {
                            o(this, t), this.opts = i, this.ctx = this, this.w = new $(i).init(), this.el = e, this.w.globals.cuid = b.randomId(), this.w.globals.chartID = this.w.config.chart.id ? b.escapeString(this.w.config.chart.id) : this.w.globals.cuid, new Ft(this).initModules(), this.create = b.bind(this.create, this), this.windowResizeHandler = this._windowResizeHandler.bind(this), this.parentResizeHandler = this._parentResizeCallback.bind(this)
                        }
                        return c(t, [{
                            key: "render",
                            value: function() {
                                var t = this;
                                return new Promise((function(e, i) {
                                    if (null !== t.el) {
                                        void 0 === Apex._chartInstances && (Apex._chartInstances = []), t.w.config.chart.id && Apex._chartInstances.push({
                                            id: t.w.globals.chartID,
                                            group: t.w.config.chart.group,
                                            chart: t
                                        }), t.setLocale(t.w.config.chart.defaultLocale);
                                        var a = t.w.config.chart.events.beforeMount;
                                        if ("function" == typeof a && a(t, t.w), t.events.fireEvent("beforeMount", [t, t.w]), window.addEventListener("resize", t.windowResizeHandler), function(t, e) {
                                                var i = !1;
                                                if (t.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {
                                                    var a = t.getBoundingClientRect();
                                                    "none" !== t.style.display && 0 !== a.width || (i = !0)
                                                }
                                                var s = new ResizeObserver((function(a) {
                                                    i && e.call(t, a), i = !0
                                                }));
                                                t.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Array.from(t.children).forEach((function(t) {
                                                    return s.observe(t)
                                                })) : s.observe(t), Ht.set(e, s)
                                            }(t.el.parentNode, t.parentResizeHandler), !t.css) {
                                            var s = t.el.getRootNode && t.el.getRootNode(),
                                                n = b.is("ShadowRoot", s),
                                                r = t.el.ownerDocument,
                                                o = r.getElementById("apexcharts-css");
                                            !n && o || (t.css = document.createElement("style"), t.css.id = "apexcharts-css", t.css.textContent = '.apexcharts-canvas {\n  position: relative;\n  user-select: none;\n  /* cannot give overflow: hidden as it will crop tooltips which overflow outside chart area */\n}\n\n\n/* scrollbar is not visible by default for legend, hence forcing the visibility */\n.apexcharts-canvas ::-webkit-scrollbar {\n  -webkit-appearance: none;\n  width: 6px;\n}\n\n.apexcharts-canvas ::-webkit-scrollbar-thumb {\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, .5);\n  box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n  -webkit-box-shadow: 0 0 1px rgba(255, 255, 255, .5);\n}\n\n\n.apexcharts-inner {\n  position: relative;\n}\n\n.apexcharts-text tspan {\n  font-family: inherit;\n}\n\n.legend-mouseover-inactive {\n  transition: 0.15s ease all;\n  opacity: 0.20;\n}\n\n.apexcharts-series-collapsed {\n  opacity: 0;\n}\n\n.apexcharts-tooltip {\n  border-radius: 5px;\n  box-shadow: 2px 2px 6px -4px #999;\n  cursor: default;\n  font-size: 14px;\n  left: 62px;\n  opacity: 0;\n  pointer-events: none;\n  position: absolute;\n  top: 20px;\n  display: flex;\n  flex-direction: column;\n  overflow: hidden;\n  white-space: nowrap;\n  z-index: 12;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light {\n  border: 1px solid #e3e3e3;\n  background: rgba(255, 255, 255, 0.96);\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark {\n  color: #fff;\n  background: rgba(30, 30, 30, 0.8);\n}\n\n.apexcharts-tooltip * {\n  font-family: inherit;\n}\n\n\n.apexcharts-tooltip-title {\n  padding: 6px;\n  font-size: 15px;\n  margin-bottom: 4px;\n}\n\n.apexcharts-tooltip.apexcharts-theme-light .apexcharts-tooltip-title {\n  background: #ECEFF1;\n  border-bottom: 1px solid #ddd;\n}\n\n.apexcharts-tooltip.apexcharts-theme-dark .apexcharts-tooltip-title {\n  background: rgba(0, 0, 0, 0.7);\n  border-bottom: 1px solid #333;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  display: inline-block;\n  font-weight: 600;\n  margin-left: 5px;\n}\n\n.apexcharts-tooltip-title:empty,\n.apexcharts-tooltip-text-y-label:empty,\n.apexcharts-tooltip-text-y-value:empty,\n.apexcharts-tooltip-text-goals-label:empty,\n.apexcharts-tooltip-text-goals-value:empty,\n.apexcharts-tooltip-text-z-value:empty {\n  display: none;\n}\n\n.apexcharts-tooltip-text-y-value,\n.apexcharts-tooltip-text-goals-value,\n.apexcharts-tooltip-text-z-value {\n  font-weight: 600;\n}\n\n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-goals-group, \n.apexcharts-tooltip-text-goals-label, \n.apexcharts-tooltip-text-goals-value {\n  display: flex;\n}\n.apexcharts-tooltip-text-goals-label:not(:empty),\n.apexcharts-tooltip-text-goals-value:not(:empty) {\n  margin-top: -6px;\n}\n\n.apexcharts-tooltip-marker {\n  width: 12px;\n  height: 12px;\n  position: relative;\n  top: 0px;\n  margin-right: 10px;\n  border-radius: 50%;\n}\n\n.apexcharts-tooltip-series-group {\n  padding: 0 10px;\n  display: none;\n  text-align: left;\n  justify-content: left;\n  align-items: center;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active .apexcharts-tooltip-marker {\n  opacity: 1;\n}\n\n.apexcharts-tooltip-series-group.apexcharts-active,\n.apexcharts-tooltip-series-group:last-child {\n  padding-bottom: 4px;\n}\n\n.apexcharts-tooltip-series-group-hidden {\n  opacity: 0;\n  height: 0;\n  line-height: 0;\n  padding: 0 !important;\n}\n\n.apexcharts-tooltip-y-group {\n  padding: 6px 0 5px;\n}\n\n.apexcharts-tooltip-box, .apexcharts-custom-tooltip {\n  padding: 4px 8px;\n}\n\n.apexcharts-tooltip-boxPlot {\n  display: flex;\n  flex-direction: column-reverse;\n}\n\n.apexcharts-tooltip-box>div {\n  margin: 4px 0;\n}\n\n.apexcharts-tooltip-box span.value {\n  font-weight: bold;\n}\n\n.apexcharts-tooltip-rangebar {\n  padding: 5px 8px;\n}\n\n.apexcharts-tooltip-rangebar .category {\n  font-weight: 600;\n  color: #777;\n}\n\n.apexcharts-tooltip-rangebar .series-name {\n  font-weight: bold;\n  display: block;\n  margin-bottom: 5px;\n}\n\n.apexcharts-xaxistooltip {\n  opacity: 0;\n  padding: 9px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-xaxistooltip:after,\n.apexcharts-xaxistooltip:before {\n  left: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-xaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-left: -6px;\n}\n\n.apexcharts-xaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-left: -7px;\n}\n\n.apexcharts-xaxistooltip-bottom:after,\n.apexcharts-xaxistooltip-bottom:before {\n  bottom: 100%;\n}\n\n.apexcharts-xaxistooltip-top:after,\n.apexcharts-xaxistooltip-top:before {\n  top: 100%;\n}\n\n.apexcharts-xaxistooltip-bottom:after {\n  border-bottom-color: #ECEFF1;\n}\n\n.apexcharts-xaxistooltip-bottom:before {\n  border-bottom-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:after {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-bottom.apexcharts-theme-dark:before {\n  border-bottom-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top:after {\n  border-top-color: #ECEFF1\n}\n\n.apexcharts-xaxistooltip-top:before {\n  border-top-color: #90A4AE;\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:after {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip-top.apexcharts-theme-dark:before {\n  border-top-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-xaxistooltip.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-yaxistooltip {\n  opacity: 0;\n  padding: 4px 10px;\n  pointer-events: none;\n  color: #373d3f;\n  font-size: 13px;\n  text-align: center;\n  border-radius: 2px;\n  position: absolute;\n  z-index: 10;\n  background: #ECEFF1;\n  border: 1px solid #90A4AE;\n}\n\n.apexcharts-yaxistooltip.apexcharts-theme-dark {\n  background: rgba(0, 0, 0, 0.7);\n  border: 1px solid rgba(0, 0, 0, 0.5);\n  color: #fff;\n}\n\n.apexcharts-yaxistooltip:after,\n.apexcharts-yaxistooltip:before {\n  top: 50%;\n  border: solid transparent;\n  content: " ";\n  height: 0;\n  width: 0;\n  position: absolute;\n  pointer-events: none;\n}\n\n.apexcharts-yaxistooltip:after {\n  border-color: rgba(236, 239, 241, 0);\n  border-width: 6px;\n  margin-top: -6px;\n}\n\n.apexcharts-yaxistooltip:before {\n  border-color: rgba(144, 164, 174, 0);\n  border-width: 7px;\n  margin-top: -7px;\n}\n\n.apexcharts-yaxistooltip-left:after,\n.apexcharts-yaxistooltip-left:before {\n  left: 100%;\n}\n\n.apexcharts-yaxistooltip-right:after,\n.apexcharts-yaxistooltip-right:before {\n  right: 100%;\n}\n\n.apexcharts-yaxistooltip-left:after {\n  border-left-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-left:before {\n  border-left-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:after {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-left.apexcharts-theme-dark:before {\n  border-left-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right:after {\n  border-right-color: #ECEFF1;\n}\n\n.apexcharts-yaxistooltip-right:before {\n  border-right-color: #90A4AE;\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:after {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip-right.apexcharts-theme-dark:before {\n  border-right-color: rgba(0, 0, 0, 0.5);\n}\n\n.apexcharts-yaxistooltip.apexcharts-active {\n  opacity: 1;\n}\n\n.apexcharts-yaxistooltip-hidden {\n  display: none;\n}\n\n.apexcharts-xcrosshairs,\n.apexcharts-ycrosshairs {\n  pointer-events: none;\n  opacity: 0;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-xcrosshairs.apexcharts-active,\n.apexcharts-ycrosshairs.apexcharts-active {\n  opacity: 1;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-ycrosshairs-hidden {\n  opacity: 0;\n}\n\n.apexcharts-selection-rect {\n  cursor: move;\n}\n\n.svg_select_boundingRect, .svg_select_points_rot {\n  pointer-events: none;\n  opacity: 0;\n  visibility: hidden;\n}\n.apexcharts-selection-rect + g .svg_select_boundingRect,\n.apexcharts-selection-rect + g .svg_select_points_rot {\n  opacity: 0;\n  visibility: hidden;\n}\n\n.apexcharts-selection-rect + g .svg_select_points_l,\n.apexcharts-selection-rect + g .svg_select_points_r {\n  cursor: ew-resize;\n  opacity: 1;\n  visibility: visible;\n}\n\n.svg_select_points {\n  fill: #efefef;\n  stroke: #333;\n  rx: 2;\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-zoom {\n  cursor: crosshair\n}\n\n.apexcharts-svg.apexcharts-zoomable.hovering-pan {\n  cursor: move\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon,\n.apexcharts-reset-icon,\n.apexcharts-pan-icon,\n.apexcharts-selection-icon,\n.apexcharts-menu-icon,\n.apexcharts-toolbar-custom-icon {\n  cursor: pointer;\n  width: 20px;\n  height: 20px;\n  line-height: 24px;\n  color: #6E8192;\n  text-align: center;\n}\n\n.apexcharts-zoom-icon svg,\n.apexcharts-zoomin-icon svg,\n.apexcharts-zoomout-icon svg,\n.apexcharts-reset-icon svg,\n.apexcharts-menu-icon svg {\n  fill: #6E8192;\n}\n\n.apexcharts-selection-icon svg {\n  fill: #444;\n  transform: scale(0.76)\n}\n\n.apexcharts-theme-dark .apexcharts-zoom-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomin-icon svg,\n.apexcharts-theme-dark .apexcharts-zoomout-icon svg,\n.apexcharts-theme-dark .apexcharts-reset-icon svg,\n.apexcharts-theme-dark .apexcharts-pan-icon svg,\n.apexcharts-theme-dark .apexcharts-selection-icon svg,\n.apexcharts-theme-dark .apexcharts-menu-icon svg,\n.apexcharts-theme-dark .apexcharts-toolbar-custom-icon svg {\n  fill: #f3f4f5;\n}\n\n.apexcharts-canvas .apexcharts-zoom-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-selection-icon.apexcharts-selected svg,\n.apexcharts-canvas .apexcharts-reset-zoom-icon.apexcharts-selected svg {\n  fill: #008FFB;\n}\n\n.apexcharts-theme-light .apexcharts-selection-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoom-icon:not(.apexcharts-selected):hover svg,\n.apexcharts-theme-light .apexcharts-zoomin-icon:hover svg,\n.apexcharts-theme-light .apexcharts-zoomout-icon:hover svg,\n.apexcharts-theme-light .apexcharts-reset-icon:hover svg,\n.apexcharts-theme-light .apexcharts-menu-icon:hover svg {\n  fill: #333;\n}\n\n.apexcharts-selection-icon,\n.apexcharts-menu-icon {\n  position: relative;\n}\n\n.apexcharts-reset-icon {\n  margin-left: 5px;\n}\n\n.apexcharts-zoom-icon,\n.apexcharts-reset-icon,\n.apexcharts-menu-icon {\n  transform: scale(0.85);\n}\n\n.apexcharts-zoomin-icon,\n.apexcharts-zoomout-icon {\n  transform: scale(0.7)\n}\n\n.apexcharts-zoomout-icon {\n  margin-right: 3px;\n}\n\n.apexcharts-pan-icon {\n  transform: scale(0.62);\n  position: relative;\n  left: 1px;\n  top: 0px;\n}\n\n.apexcharts-pan-icon svg {\n  fill: #fff;\n  stroke: #6E8192;\n  stroke-width: 2;\n}\n\n.apexcharts-pan-icon.apexcharts-selected svg {\n  stroke: #008FFB;\n}\n\n.apexcharts-pan-icon:not(.apexcharts-selected):hover svg {\n  stroke: #333;\n}\n\n.apexcharts-toolbar {\n  position: absolute;\n  z-index: 11;\n  max-width: 176px;\n  text-align: right;\n  border-radius: 3px;\n  padding: 0px 6px 2px 6px;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.apexcharts-menu {\n  background: #fff;\n  position: absolute;\n  top: 100%;\n  border: 1px solid #ddd;\n  border-radius: 3px;\n  padding: 3px;\n  right: 10px;\n  opacity: 0;\n  min-width: 110px;\n  transition: 0.15s ease all;\n  pointer-events: none;\n}\n\n.apexcharts-menu.apexcharts-menu-open {\n  opacity: 1;\n  pointer-events: all;\n  transition: 0.15s ease all;\n}\n\n.apexcharts-menu-item {\n  padding: 6px 7px;\n  font-size: 12px;\n  cursor: pointer;\n}\n\n.apexcharts-theme-light .apexcharts-menu-item:hover {\n  background: #eee;\n}\n\n.apexcharts-theme-dark .apexcharts-menu {\n  background: rgba(0, 0, 0, 0.7);\n  color: #fff;\n}\n\n@media screen and (min-width: 768px) {\n  .apexcharts-canvas:hover .apexcharts-toolbar {\n    opacity: 1;\n  }\n}\n\n.apexcharts-datalabel.apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-pie-label,\n.apexcharts-datalabels,\n.apexcharts-datalabel,\n.apexcharts-datalabel-label,\n.apexcharts-datalabel-value {\n  cursor: default;\n  pointer-events: none;\n}\n\n.apexcharts-pie-label-delay {\n  opacity: 0;\n  animation-name: opaque;\n  animation-duration: 0.3s;\n  animation-fill-mode: forwards;\n  animation-timing-function: ease;\n}\n\n.apexcharts-canvas .apexcharts-element-hidden {\n  opacity: 0;\n}\n\n.apexcharts-hide .apexcharts-series-points {\n  opacity: 0;\n}\n\n.apexcharts-gridline,\n.apexcharts-annotation-rect,\n.apexcharts-xaxis-annotation-label,\n.apexcharts-yaxis-annotation-label,\n.apexcharts-point-annotation-label,\n.apexcharts-tooltip .apexcharts-marker,\n.apexcharts-area-series .apexcharts-area,\n.apexcharts-line,\n.apexcharts-zoom-rect,\n.apexcharts-toolbar svg,\n.apexcharts-area-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-line-series .apexcharts-series-markers .apexcharts-marker.no-pointer-events,\n.apexcharts-radar-series path,\n.apexcharts-radar-series polygon {\n  pointer-events: none;\n}\n\n\n/* markers */\n\n.apexcharts-marker {\n  transition: 0.15s ease all;\n}\n\n@keyframes opaque {\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\n\n/* Resize generated styles */\n\n@keyframes resizeanim {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.resize-triggers {\n  animation: 1ms resizeanim;\n  visibility: hidden;\n  opacity: 0;\n}\n\n.resize-triggers,\n.resize-triggers>div,\n.contract-trigger:before {\n  content: " ";\n  display: block;\n  position: absolute;\n  top: 0;\n  left: 0;\n  height: 100%;\n  width: 100%;\n  overflow: hidden;\n}\n\n.resize-triggers>div {\n  background: #eee;\n  overflow: auto;\n}\n\n.contract-trigger:before {\n  width: 200%;\n  height: 200%;\n}', n ? s.prepend(t.css) : r.head.appendChild(t.css))
                                        }
                                        var l = t.create(t.w.config.series, {});
                                        if (!l) return e(t);
                                        t.mount(l).then((function() {
                                            "function" == typeof t.w.config.chart.events.mounted && t.w.config.chart.events.mounted(t, t.w), t.events.fireEvent("mounted", [t, t.w]), e(l)
                                        })).catch((function(t) {
                                            i(t)
                                        }))
                                    } else i(new Error("Element not found"))
                                }))
                            }
                        }, {
                            key: "create",
                            value: function(t, e) {
                                var i = this.w;
                                new Ft(this).initModules();
                                var a = this.w.globals;
                                if (a.noData = !1, a.animationEnded = !1, this.responsive.checkResponsiveConfig(e), i.config.xaxis.convertedCatToNumeric && new H(i.config).convertCatToNumericXaxis(i.config, this.ctx), null === this.el) return a.animationEnded = !0, null;
                                if (this.core.setupElements(), "treemap" === i.config.chart.type && (i.config.grid.show = !1, i.config.yaxis[0].show = !1), 0 === a.svgWidth) return a.animationEnded = !0, null;
                                var s = C.checkComboSeries(t);
                                a.comboCharts = s.comboCharts, a.comboBarCount = s.comboBarCount;
                                var n = t.every((function(t) {
                                    return t.data && 0 === t.data.length
                                }));
                                (0 === t.length || n) && this.series.handleNoData(), this.events.setupEventHandlers(), this.data.parseData(t), this.theme.init(), new _(this).setGlobalMarkerSize(), this.formatters.setLabelFormatters(), this.titleSubtitle.draw(), a.noData && a.collapsedSeries.length !== a.series.length && !i.config.legend.showForSingleSeries || this.legend.init(), this.series.hasAllSeriesEqualX(), a.axisCharts && (this.core.coreCalculations(), "category" !== i.config.xaxis.type && this.formatters.setLabelFormatters(), this.ctx.toolbar.minX = i.globals.minX, this.ctx.toolbar.maxX = i.globals.maxX), this.formatters.heatmapLabelFormatters(), new C(this).getLargestMarkerSize(), this.dimensions.plotCoords();
                                var r = this.core.xySettings();
                                this.grid.createGridMask();
                                var o = this.core.plotChartType(t, r),
                                    l = new D(this);
                                l.bringForward(), i.config.dataLabels.background.enabled && l.dataLabelsBackground(), this.core.shiftGraphPosition();
                                var c = {
                                    plot: {
                                        left: i.globals.translateX,
                                        top: i.globals.translateY,
                                        width: i.globals.gridWidth,
                                        height: i.globals.gridHeight
                                    }
                                };
                                return {
                                    elGraph: o,
                                    xyRatios: r,
                                    elInner: i.globals.dom.elGraphical,
                                    dimensions: c
                                }
                            }
                        }, {
                            key: "mount",
                            value: function() {
                                var t = this,
                                    e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                                    i = this,
                                    a = i.w;
                                return new Promise((function(s, n) {
                                    if (null === i.el) return n(new Error("Not enough data to display or target element not found"));
                                    (null === e || a.globals.allSeriesCollapsed) && i.series.handleNoData(), "treemap" !== a.config.chart.type && i.axes.drawAxis(a.config.chart.type, e.xyRatios), i.grid = new Z(i);
                                    var r = i.grid.drawGrid();
                                    i.annotations = new L(i), i.annotations.drawImageAnnos(), i.annotations.drawTextAnnos(), "back" === a.config.grid.position && r && a.globals.dom.elGraphical.add(r.el);
                                    var o = new q(t.ctx),
                                        l = new J(t.ctx);
                                    if (null !== r && (o.xAxisLabelCorrections(r.xAxisTickWidth), l.setYAxisTextAlignments(), a.config.yaxis.map((function(t, e) {
                                            -1 === a.globals.ignoreYAxisIndexes.indexOf(e) && l.yAxisTitleRotate(e, t.opposite)
                                        }))), "back" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), Array.isArray(e.elGraph))
                                        for (var c = 0; c < e.elGraph.length; c++) a.globals.dom.elGraphical.add(e.elGraph[c]);
                                    else a.globals.dom.elGraphical.add(e.elGraph);
                                    if ("front" === a.config.grid.position && r && a.globals.dom.elGraphical.add(r.el), "front" === a.config.xaxis.crosshairs.position && i.crosshairs.drawXCrosshairs(), "front" === a.config.yaxis[0].crosshairs.position && i.crosshairs.drawYCrosshairs(), "front" === a.config.annotations.position && (a.globals.dom.Paper.add(a.globals.dom.elAnnotations), i.annotations.drawAxesAnnotations()), !a.globals.noData) {
                                        if (a.config.tooltip.enabled && !a.globals.noData && i.w.globals.tooltip.drawTooltip(e.xyRatios), a.globals.axisCharts && (a.globals.isXNumeric || a.config.xaxis.convertedCatToNumeric || a.globals.isRangeBar))(a.config.chart.zoom.enabled || a.config.chart.selection && a.config.chart.selection.enabled || a.config.chart.pan && a.config.chart.pan.enabled) && i.zoomPanSelection.init({
                                            xyRatios: e.xyRatios
                                        });
                                        else {
                                            var h = a.config.chart.toolbar.tools;
                                            ["zoom", "zoomin", "zoomout", "selection", "pan", "reset"].forEach((function(t) {
                                                h[t] = !1
                                            }))
                                        }
                                        a.config.chart.toolbar.show && !a.globals.allSeriesCollapsed && i.toolbar.createToolbar()
                                    }
                                    a.globals.memory.methodsToExec.length > 0 && a.globals.memory.methodsToExec.forEach((function(t) {
                                        t.method(t.params, !1, t.context)
                                    })), a.globals.axisCharts || a.globals.noData || i.core.resizeNonAxisCharts(), s(i)
                                }))
                            }
                        }, {
                            key: "destroy",
                            value: function() {
                                var t, e;
                                window.removeEventListener("resize", this.windowResizeHandler), this.el.parentNode, t = this.parentResizeHandler, (e = Ht.get(t)) && (e.disconnect(), Ht.delete(t));
                                var i = this.w.config.chart.id;
                                i && Apex._chartInstances.forEach((function(t, e) {
                                    t.id === b.escapeString(i) && Apex._chartInstances.splice(e, 1)
                                })), new Rt(this.ctx).clear({
                                    isUpdating: !1
                                })
                            }
                        }, {
                            key: "updateOptions",
                            value: function(t) {
                                var e = this,
                                    i = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                    a = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                    s = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
                                    n = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4],
                                    r = this.w;
                                return r.globals.selection = void 0, t.series && (this.series.resetSeries(!1, !0, !1), t.series.length && t.series[0].data && (t.series = t.series.map((function(t, i) {
                                    return e.updateHelpers._extendSeries(t, i)
                                }))), this.updateHelpers.revertDefaultAxisMinMax()), t.xaxis && (t = this.updateHelpers.forceXAxisUpdate(t)), t.yaxis && (t = this.updateHelpers.forceYAxisUpdate(t)), r.globals.collapsedSeriesIndices.length > 0 && this.series.clearPreviousPaths(), t.theme && (t = this.theme.updateThemeOptions(t)), this.updateHelpers._updateOptions(t, i, a, s, n)
                            }
                        }, {
                            key: "updateSeries",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
                                return this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(t, e, i)
                            }
                        }, {
                            key: "appendSeries",
                            value: function(t) {
                                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
                                    a = this.w.config.series.slice();
                                return a.push(t), this.series.resetSeries(!1), this.updateHelpers.revertDefaultAxisMinMax(), this.updateHelpers._updateSeries(a, e, i)
                            }
                        }, {
                            key: "appendData",
                            value: function(t) {
                                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = this;
                                i.w.globals.dataChanged = !0, i.series.getPreviousPaths();
                                for (var a = i.w.config.series.slice(), s = 0; s < a.length; s++)
                                    if (null !== t[s] && void 0 !== t[s])
                                        for (var n = 0; n < t[s].data.length; n++) a[s].data.push(t[s].data[n]);
                                return i.w.config.series = a, e && (i.w.globals.initialSeries = b.clone(i.w.config.series)), this.update()
                            }
                        }, {
                            key: "update",
                            value: function(t) {
                                var e = this;
                                return new Promise((function(i, a) {
                                    new Rt(e.ctx).clear({
                                        isUpdating: !0
                                    });
                                    var s = e.create(e.w.config.series, t);
                                    if (!s) return i(e);
                                    e.mount(s).then((function() {
                                        "function" == typeof e.w.config.chart.events.updated && e.w.config.chart.events.updated(e, e.w), e.events.fireEvent("updated", [e, e.w]), e.w.globals.isDirty = !0, i(e)
                                    })).catch((function(t) {
                                        a(t)
                                    }))
                                }))
                            }
                        }, {
                            key: "getSyncedCharts",
                            value: function() {
                                var t = this.getGroupedCharts(),
                                    e = [this];
                                return t.length && (e = [], t.forEach((function(t) {
                                    e.push(t)
                                }))), e
                            }
                        }, {
                            key: "getGroupedCharts",
                            value: function() {
                                var t = this;
                                return Apex._chartInstances.filter((function(t) {
                                    if (t.group) return !0
                                })).map((function(e) {
                                    return t.w.config.chart.group === e.group ? e.chart : t
                                }))
                            }
                        }, {
                            key: "toggleSeries",
                            value: function(t) {
                                return this.series.toggleSeries(t)
                            }
                        }, {
                            key: "highlightSeriesOnLegendHover",
                            value: function(t, e) {
                                return this.series.toggleSeriesOnHover(t, e)
                            }
                        }, {
                            key: "showSeries",
                            value: function(t) {
                                this.series.showSeries(t)
                            }
                        }, {
                            key: "hideSeries",
                            value: function(t) {
                                this.series.hideSeries(t)
                            }
                        }, {
                            key: "resetSeries",
                            value: function() {
                                var t = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0],
                                    e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
                                this.series.resetSeries(t, e)
                            }
                        }, {
                            key: "addEventListener",
                            value: function(t, e) {
                                this.events.addEventListener(t, e)
                            }
                        }, {
                            key: "removeEventListener",
                            value: function(t, e) {
                                this.events.removeEventListener(t, e)
                            }
                        }, {
                            key: "addXaxisAnnotation",
                            value: function(t) {
                                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                    a = this;
                                i && (a = i), a.annotations.addXaxisAnnotationExternal(t, e, a)
                            }
                        }, {
                            key: "addYaxisAnnotation",
                            value: function(t) {
                                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                    a = this;
                                i && (a = i), a.annotations.addYaxisAnnotationExternal(t, e, a)
                            }
                        }, {
                            key: "addPointAnnotation",
                            value: function(t) {
                                var e = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                                    i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0,
                                    a = this;
                                i && (a = i), a.annotations.addPointAnnotationExternal(t, e, a)
                            }
                        }, {
                            key: "clearAnnotations",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : void 0,
                                    e = this;
                                t && (e = t), e.annotations.clearAnnotations(e)
                            }
                        }, {
                            key: "removeAnnotation",
                            value: function(t) {
                                var e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : void 0,
                                    i = this;
                                e && (i = e), i.annotations.removeAnnotation(i, t)
                            }
                        }, {
                            key: "getChartArea",
                            value: function() {
                                return this.w.globals.dom.baseEl.querySelector(".apexcharts-inner")
                            }
                        }, {
                            key: "getSeriesTotalXRange",
                            value: function(t, e) {
                                return this.coreUtils.getSeriesTotalsXRange(t, e)
                            }
                        }, {
                            key: "getHighestValueInSeries",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                    e = new Q(this.ctx);
                                return e.getMinYMaxY(t).highestY
                            }
                        }, {
                            key: "getLowestValueInSeries",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0,
                                    e = new Q(this.ctx);
                                return e.getMinYMaxY(t).lowestY
                            }
                        }, {
                            key: "getSeriesTotal",
                            value: function() {
                                return this.w.globals.seriesTotals
                            }
                        }, {
                            key: "toggleDataPointSelection",
                            value: function(t, e) {
                                return this.updateHelpers.toggleDataPointSelection(t, e)
                            }
                        }, {
                            key: "zoomX",
                            value: function(t, e) {
                                this.ctx.toolbar.zoomUpdateOptions(t, e)
                            }
                        }, {
                            key: "setLocale",
                            value: function(t) {
                                this.localization.setCurrentLocaleValues(t)
                            }
                        }, {
                            key: "dataURI",
                            value: function(t) {
                                return new U(this.ctx).dataURI(t)
                            }
                        }, {
                            key: "exportToCSV",
                            value: function() {
                                var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
                                    e = new U(this.ctx);
                                return e.exportToCSV(t)
                            }
                        }, {
                            key: "paper",
                            value: function() {
                                return this.w.globals.dom.Paper
                            }
                        }, {
                            key: "_parentResizeCallback",
                            value: function() {
                                this.w.globals.animationEnded && this.w.config.chart.redrawOnParentResize && this._windowResize()
                            }
                        }, {
                            key: "_windowResize",
                            value: function() {
                                var t = this;
                                clearTimeout(this.w.globals.resizeTimer), this.w.globals.resizeTimer = window.setTimeout((function() {
                                    t.w.globals.resized = !0, t.w.globals.dataChanged = !1, t.ctx.update()
                                }), 150)
                            }
                        }, {
                            key: "_windowResizeHandler",
                            value: function() {
                                var t = this.w.config.chart.redrawOnWindowResize;
                                "function" == typeof t && (t = t()), t && this._windowResize()
                            }
                        }], [{
                            key: "getChartByID",
                            value: function(t) {
                                var e = b.escapeString(t),
                                    i = Apex._chartInstances.filter((function(t) {
                                        return t.id === e
                                    }))[0];
                                return i && i.chart
                            }
                        }, {
                            key: "initOnLoad",
                            value: function() {
                                for (var e = document.querySelectorAll("[data-apexcharts]"), i = 0; i < e.length; i++) new t(e[i], JSON.parse(e[i].getAttribute("data-options"))).render()
                            }
                        }, {
                            key: "exec",
                            value: function(t, e) {
                                var i = this.getChartByID(t);
                                if (i) {
                                    i.w.globals.isExecCalled = !0;
                                    var a = null;
                                    if (-1 !== i.publicMethods.indexOf(e)) {
                                        for (var s = arguments.length, n = new Array(s > 2 ? s - 2 : 0), r = 2; r < s; r++) n[r - 2] = arguments[r];
                                        a = i[e].apply(i, n)
                                    }
                                    return a
                                }
                            }
                        }, {
                            key: "merge",
                            value: function(t, e) {
                                return b.extend(t, e)
                            }
                        }]), t
                    }();
                t.exports = Wt
            }
        },
        e = {};

    function i(a) {
        var s = e[a];
        if (void 0 !== s) return s.exports;
        var n = e[a] = {
            exports: {}
        };
        return t[a](n, n.exports, i), n.exports
    }
    i.n = t => {
        var e = t && t.__esModule ? () => t.default : () => t;
        return i.d(e, {
            a: e
        }), e
    }, i.d = (t, e) => {
        for (var a in e) i.o(e, a) && !i.o(t, a) && Object.defineProperty(t, a, {
            enumerable: !0,
            get: e[a]
        })
    }, i.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), i.r = t => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        })
    }, (() => {
        var t = {};

        function e(t) {
            return null !== t && "object" == typeof t && "constructor" in t && t.constructor === Object
        }

        function a(t = {}, i = {}) {
            Object.keys(i).forEach((s => {
                void 0 === t[s] ? t[s] = i[s] : e(i[s]) && e(t[s]) && Object.keys(i[s]).length > 0 && a(t[s], i[s])
            }))
        }
        i.r(t), i.d(t, {
            BaseActions: () => Ta,
            BaseComponent: () => ua,
            BaseStore: () => Aa,
            Cell: () => ma,
            Component: () => Bi,
            Config: () => ns,
            Dispatcher: () => Ba,
            Grid: () => Es,
            PluginBaseComponent: () => Ia,
            PluginPosition: () => ka,
            Row: () => xa,
            className: () => Sa,
            createElement: () => Fi,
            createRef: () => Hi,
            h: () => Fi,
            html: () => ga,
            useEffect: () => Os,
            useRef: () => Ns
        });
        const s = {
            body: {},
            addEventListener() {},
            removeEventListener() {},
            activeElement: {
                blur() {},
                nodeName: ""
            },
            querySelector: () => null,
            querySelectorAll: () => [],
            getElementById: () => null,
            createEvent: () => ({
                initEvent() {}
            }),
            createElement: () => ({
                children: [],
                childNodes: [],
                style: {},
                setAttribute() {},
                getElementsByTagName: () => []
            }),
            createElementNS: () => ({}),
            importNode: () => null,
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            }
        };

        function n() {
            const t = "undefined" != typeof document ? document : {};
            return a(t, s), t
        }
        const r = {
            document: s,
            navigator: {
                userAgent: ""
            },
            location: {
                hash: "",
                host: "",
                hostname: "",
                href: "",
                origin: "",
                pathname: "",
                protocol: "",
                search: ""
            },
            history: {
                replaceState() {},
                pushState() {},
                go() {},
                back() {}
            },
            CustomEvent: function() {
                return this
            },
            addEventListener() {},
            removeEventListener() {},
            getComputedStyle: () => ({
                getPropertyValue: () => ""
            }),
            Image() {},
            Date() {},
            screen: {},
            setTimeout() {},
            clearTimeout() {},
            matchMedia: () => ({}),
            requestAnimationFrame: t => "undefined" == typeof setTimeout ? (t(), null) : setTimeout(t, 0),
            cancelAnimationFrame(t) {
                "undefined" != typeof setTimeout && clearTimeout(t)
            }
        };

        function o() {
            const t = "undefined" != typeof window ? window : {};
            return a(t, r), t
        }
        class l extends Array {
            constructor(t) {
                "number" == typeof t ? super(t) : (super(...t || []), function(t) {
                    const e = t.__proto__;
                    Object.defineProperty(t, "__proto__", {
                        get: () => e,
                        set(t) {
                            e.__proto__ = t
                        }
                    })
                }(this))
            }
        }

        function c(t = []) {
            const e = [];
            return t.forEach((t => {
                Array.isArray(t) ? e.push(...c(t)) : e.push(t)
            })), e
        }

        function h(t, e) {
            return Array.prototype.filter.call(t, e)
        }

        function d(t, e) {
            const i = o(),
                a = n();
            let s = [];
            if (!e && t instanceof l) return t;
            if (!t) return new l(s);
            if ("string" == typeof t) {
                const i = t.trim();
                if (i.indexOf("<") >= 0 && i.indexOf(">") >= 0) {
                    let t = "div";
                    0 === i.indexOf("<li") && (t = "ul"), 0 === i.indexOf("<tr") && (t = "tbody"), 0 !== i.indexOf("<td") && 0 !== i.indexOf("<th") || (t = "tr"), 0 === i.indexOf("<tbody") && (t = "table"), 0 === i.indexOf("<option") && (t = "select");
                    const e = a.createElement(t);
                    e.innerHTML = i;
                    for (let t = 0; t < e.childNodes.length; t += 1) s.push(e.childNodes[t])
                } else s = function(t, e) {
                    if ("string" != typeof t) return [t];
                    const i = [],
                        a = e.querySelectorAll(t);
                    for (let t = 0; t < a.length; t += 1) i.push(a[t]);
                    return i
                }(t.trim(), e || a)
            } else if (t.nodeType || t === i || t === a) s.push(t);
            else if (Array.isArray(t)) {
                if (t instanceof l) return t;
                s = t
            }
            return new l(function(t) {
                const e = [];
                for (let i = 0; i < t.length; i += 1) - 1 === e.indexOf(t[i]) && e.push(t[i]);
                return e
            }(s))
        }
        d.fn = l.prototype;
        const u = "resize scroll".split(" ");

        function p(t) {
            return function(...e) {
                if (void 0 === e[0]) {
                    for (let e = 0; e < this.length; e += 1) u.indexOf(t) < 0 && (t in this[e] ? this[e][t]() : d(this[e]).trigger(t));
                    return this
                }
                return this.on(t, ...e)
            }
        }
        p("click"), p("blur"), p("focus"), p("focusin"), p("focusout"), p("keyup"), p("keydown"), p("keypress"), p("submit"), p("change"), p("mousedown"), p("mousemove"), p("mouseup"), p("mouseenter"), p("mouseleave"), p("mouseout"), p("mouseover"), p("touchstart"), p("touchend"), p("touchmove"), p("resize"), p("scroll");
        const g = {
            addClass: function(...t) {
                const e = c(t.map((t => t.split(" "))));
                return this.forEach((t => {
                    t.classList.add(...e)
                })), this
            },
            removeClass: function(...t) {
                const e = c(t.map((t => t.split(" "))));
                return this.forEach((t => {
                    t.classList.remove(...e)
                })), this
            },
            hasClass: function(...t) {
                const e = c(t.map((t => t.split(" "))));
                return h(this, (t => e.filter((e => t.classList.contains(e))).length > 0)).length > 0
            },
            toggleClass: function(...t) {
                const e = c(t.map((t => t.split(" "))));
                this.forEach((t => {
                    e.forEach((e => {
                        t.classList.toggle(e)
                    }))
                }))
            },
            attr: function(t, e) {
                if (1 === arguments.length && "string" == typeof t) return this[0] ? this[0].getAttribute(t) : void 0;
                for (let i = 0; i < this.length; i += 1)
                    if (2 === arguments.length) this[i].setAttribute(t, e);
                    else
                        for (const e in t) this[i][e] = t[e], this[i].setAttribute(e, t[e]);
                return this
            },
            removeAttr: function(t) {
                for (let e = 0; e < this.length; e += 1) this[e].removeAttribute(t);
                return this
            },
            transform: function(t) {
                for (let e = 0; e < this.length; e += 1) this[e].style.transform = t;
                return this
            },
            transition: function(t) {
                for (let e = 0; e < this.length; e += 1) this[e].style.transitionDuration = "string" != typeof t ? `${t}ms` : t;
                return this
            },
            on: function(...t) {
                let [e, i, a, s] = t;

                function n(t) {
                    const e = t.target;
                    if (!e) return;
                    const s = t.target.dom7EventData || [];
                    if (s.indexOf(t) < 0 && s.unshift(t), d(e).is(i)) a.apply(e, s);
                    else {
                        const t = d(e).parents();
                        for (let e = 0; e < t.length; e += 1) d(t[e]).is(i) && a.apply(t[e], s)
                    }
                }

                function r(t) {
                    const e = t && t.target && t.target.dom7EventData || [];
                    e.indexOf(t) < 0 && e.unshift(t), a.apply(this, e)
                }
                "function" == typeof t[1] && ([e, a, s] = t, i = void 0), s || (s = !1);
                const o = e.split(" ");
                let l;
                for (let t = 0; t < this.length; t += 1) {
                    const e = this[t];
                    if (i)
                        for (l = 0; l < o.length; l += 1) {
                            const t = o[l];
                            e.dom7LiveListeners || (e.dom7LiveListeners = {}), e.dom7LiveListeners[t] || (e.dom7LiveListeners[t] = []), e.dom7LiveListeners[t].push({
                                listener: a,
                                proxyListener: n
                            }), e.addEventListener(t, n, s)
                        } else
                            for (l = 0; l < o.length; l += 1) {
                                const t = o[l];
                                e.dom7Listeners || (e.dom7Listeners = {}), e.dom7Listeners[t] || (e.dom7Listeners[t] = []), e.dom7Listeners[t].push({
                                    listener: a,
                                    proxyListener: r
                                }), e.addEventListener(t, r, s)
                            }
                }
                return this
            },
            off: function(...t) {
                let [e, i, a, s] = t;
                "function" == typeof t[1] && ([e, a, s] = t, i = void 0), s || (s = !1);
                const n = e.split(" ");
                for (let t = 0; t < n.length; t += 1) {
                    const e = n[t];
                    for (let t = 0; t < this.length; t += 1) {
                        const n = this[t];
                        let r;
                        if (!i && n.dom7Listeners ? r = n.dom7Listeners[e] : i && n.dom7LiveListeners && (r = n.dom7LiveListeners[e]), r && r.length)
                            for (let t = r.length - 1; t >= 0; t -= 1) {
                                const i = r[t];
                                a && i.listener === a || a && i.listener && i.listener.dom7proxy && i.listener.dom7proxy === a ? (n.removeEventListener(e, i.proxyListener, s), r.splice(t, 1)) : a || (n.removeEventListener(e, i.proxyListener, s), r.splice(t, 1))
                            }
                    }
                }
                return this
            },
            trigger: function(...t) {
                const e = o(),
                    i = t[0].split(" "),
                    a = t[1];
                for (let s = 0; s < i.length; s += 1) {
                    const n = i[s];
                    for (let i = 0; i < this.length; i += 1) {
                        const s = this[i];
                        if (e.CustomEvent) {
                            const i = new e.CustomEvent(n, {
                                detail: a,
                                bubbles: !0,
                                cancelable: !0
                            });
                            s.dom7EventData = t.filter(((t, e) => e > 0)), s.dispatchEvent(i), s.dom7EventData = [], delete s.dom7EventData
                        }
                    }
                }
                return this
            },
            transitionEnd: function(t) {
                const e = this;
                return t && e.on("transitionend", (function i(a) {
                    a.target === this && (t.call(this, a), e.off("transitionend", i))
                })), this
            },
            outerWidth: function(t) {
                if (this.length > 0) {
                    if (t) {
                        const t = this.styles();
                        return this[0].offsetWidth + parseFloat(t.getPropertyValue("margin-right")) + parseFloat(t.getPropertyValue("margin-left"))
                    }
                    return this[0].offsetWidth
                }
                return null
            },
            outerHeight: function(t) {
                if (this.length > 0) {
                    if (t) {
                        const t = this.styles();
                        return this[0].offsetHeight + parseFloat(t.getPropertyValue("margin-top")) + parseFloat(t.getPropertyValue("margin-bottom"))
                    }
                    return this[0].offsetHeight
                }
                return null
            },
            styles: function() {
                const t = o();
                return this[0] ? t.getComputedStyle(this[0], null) : {}
            },
            offset: function() {
                if (this.length > 0) {
                    const t = o(),
                        e = n(),
                        i = this[0],
                        a = i.getBoundingClientRect(),
                        s = e.body,
                        r = i.clientTop || s.clientTop || 0,
                        l = i.clientLeft || s.clientLeft || 0,
                        c = i === t ? t.scrollY : i.scrollTop,
                        h = i === t ? t.scrollX : i.scrollLeft;
                    return {
                        top: a.top + c - r,
                        left: a.left + h - l
                    }
                }
                return null
            },
            css: function(t, e) {
                const i = o();
                let a;
                if (1 === arguments.length) {
                    if ("string" != typeof t) {
                        for (a = 0; a < this.length; a += 1)
                            for (const e in t) this[a].style[e] = t[e];
                        return this
                    }
                    if (this[0]) return i.getComputedStyle(this[0], null).getPropertyValue(t)
                }
                if (2 === arguments.length && "string" == typeof t) {
                    for (a = 0; a < this.length; a += 1) this[a].style[t] = e;
                    return this
                }
                return this
            },
            each: function(t) {
                return t ? (this.forEach(((e, i) => {
                    t.apply(e, [e, i])
                })), this) : this
            },
            html: function(t) {
                if (void 0 === t) return this[0] ? this[0].innerHTML : null;
                for (let e = 0; e < this.length; e += 1) this[e].innerHTML = t;
                return this
            },
            text: function(t) {
                if (void 0 === t) return this[0] ? this[0].textContent.trim() : null;
                for (let e = 0; e < this.length; e += 1) this[e].textContent = t;
                return this
            },
            is: function(t) {
                const e = o(),
                    i = n(),
                    a = this[0];
                let s, r;
                if (!a || void 0 === t) return !1;
                if ("string" == typeof t) {
                    if (a.matches) return a.matches(t);
                    if (a.webkitMatchesSelector) return a.webkitMatchesSelector(t);
                    if (a.msMatchesSelector) return a.msMatchesSelector(t);
                    for (s = d(t), r = 0; r < s.length; r += 1)
                        if (s[r] === a) return !0;
                    return !1
                }
                if (t === i) return a === i;
                if (t === e) return a === e;
                if (t.nodeType || t instanceof l) {
                    for (s = t.nodeType ? [t] : t, r = 0; r < s.length; r += 1)
                        if (s[r] === a) return !0;
                    return !1
                }
                return !1
            },
            index: function() {
                let t, e = this[0];
                if (e) {
                    for (t = 0; null !== (e = e.previousSibling);) 1 === e.nodeType && (t += 1);
                    return t
                }
            },
            eq: function(t) {
                if (void 0 === t) return this;
                const e = this.length;
                if (t > e - 1) return d([]);
                if (t < 0) {
                    const i = e + t;
                    return d(i < 0 ? [] : [this[i]])
                }
                return d([this[t]])
            },
            append: function(...t) {
                let e;
                const i = n();
                for (let a = 0; a < t.length; a += 1) {
                    e = t[a];
                    for (let t = 0; t < this.length; t += 1)
                        if ("string" == typeof e) {
                            const a = i.createElement("div");
                            for (a.innerHTML = e; a.firstChild;) this[t].appendChild(a.firstChild)
                        } else if (e instanceof l)
                        for (let i = 0; i < e.length; i += 1) this[t].appendChild(e[i]);
                    else this[t].appendChild(e)
                }
                return this
            },
            prepend: function(t) {
                const e = n();
                let i, a;
                for (i = 0; i < this.length; i += 1)
                    if ("string" == typeof t) {
                        const s = e.createElement("div");
                        for (s.innerHTML = t, a = s.childNodes.length - 1; a >= 0; a -= 1) this[i].insertBefore(s.childNodes[a], this[i].childNodes[0])
                    } else if (t instanceof l)
                    for (a = 0; a < t.length; a += 1) this[i].insertBefore(t[a], this[i].childNodes[0]);
                else this[i].insertBefore(t, this[i].childNodes[0]);
                return this
            },
            next: function(t) {
                return this.length > 0 ? t ? this[0].nextElementSibling && d(this[0].nextElementSibling).is(t) ? d([this[0].nextElementSibling]) : d([]) : this[0].nextElementSibling ? d([this[0].nextElementSibling]) : d([]) : d([])
            },
            nextAll: function(t) {
                const e = [];
                let i = this[0];
                if (!i) return d([]);
                for (; i.nextElementSibling;) {
                    const a = i.nextElementSibling;
                    t ? d(a).is(t) && e.push(a) : e.push(a), i = a
                }
                return d(e)
            },
            prev: function(t) {
                if (this.length > 0) {
                    const e = this[0];
                    return t ? e.previousElementSibling && d(e.previousElementSibling).is(t) ? d([e.previousElementSibling]) : d([]) : e.previousElementSibling ? d([e.previousElementSibling]) : d([])
                }
                return d([])
            },
            prevAll: function(t) {
                const e = [];
                let i = this[0];
                if (!i) return d([]);
                for (; i.previousElementSibling;) {
                    const a = i.previousElementSibling;
                    t ? d(a).is(t) && e.push(a) : e.push(a), i = a
                }
                return d(e)
            },
            parent: function(t) {
                const e = [];
                for (let i = 0; i < this.length; i += 1) null !== this[i].parentNode && (t ? d(this[i].parentNode).is(t) && e.push(this[i].parentNode) : e.push(this[i].parentNode));
                return d(e)
            },
            parents: function(t) {
                const e = [];
                for (let i = 0; i < this.length; i += 1) {
                    let a = this[i].parentNode;
                    for (; a;) t ? d(a).is(t) && e.push(a) : e.push(a), a = a.parentNode
                }
                return d(e)
            },
            closest: function(t) {
                let e = this;
                return void 0 === t ? d([]) : (e.is(t) || (e = e.parents(t).eq(0)), e)
            },
            find: function(t) {
                const e = [];
                for (let i = 0; i < this.length; i += 1) {
                    const a = this[i].querySelectorAll(t);
                    for (let t = 0; t < a.length; t += 1) e.push(a[t])
                }
                return d(e)
            },
            children: function(t) {
                const e = [];
                for (let i = 0; i < this.length; i += 1) {
                    const a = this[i].children;
                    for (let i = 0; i < a.length; i += 1) t && !d(a[i]).is(t) || e.push(a[i])
                }
                return d(e)
            },
            filter: function(t) {
                return d(h(this, t))
            },
            remove: function() {
                for (let t = 0; t < this.length; t += 1) this[t].parentNode && this[t].parentNode.removeChild(this[t]);
                return this
            }
        };
        Object.keys(g).forEach((t => {
            Object.defineProperty(d.fn, t, {
                value: g[t],
                writable: !0
            })
        }));
        const f = d;

        function m(t, e = 0) {
            return setTimeout(t, e)
        }

        function x() {
            return Date.now()
        }

        function v(t, e = "x") {
            const i = o();
            let a, s, n;
            const r = function(t) {
                const e = o();
                let i;
                return e.getComputedStyle && (i = e.getComputedStyle(t, null)), !i && t.currentStyle && (i = t.currentStyle), i || (i = t.style), i
            }(t);
            return i.WebKitCSSMatrix ? (s = r.transform || r.webkitTransform, s.split(",").length > 6 && (s = s.split(", ").map((t => t.replace(",", "."))).join(", ")), n = new i.WebKitCSSMatrix("none" === s ? "" : s)) : (n = r.MozTransform || r.OTransform || r.MsTransform || r.msTransform || r.transform || r.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), a = n.toString().split(",")), "x" === e && (s = i.WebKitCSSMatrix ? n.m41 : 16 === a.length ? parseFloat(a[12]) : parseFloat(a[4])), "y" === e && (s = i.WebKitCSSMatrix ? n.m42 : 16 === a.length ? parseFloat(a[13]) : parseFloat(a[5])), s || 0
        }

        function b(t) {
            return "object" == typeof t && null !== t && t.constructor && "Object" === Object.prototype.toString.call(t).slice(8, -1)
        }

        function y(...t) {
            const e = Object(t[0]),
                i = ["__proto__", "constructor", "prototype"];
            for (let s = 1; s < t.length; s += 1) {
                const n = t[s];
                if (null != n && (a = n, !("undefined" != typeof window && void 0 !== window.HTMLElement ? a instanceof HTMLElement : a && (1 === a.nodeType || 11 === a.nodeType)))) {
                    const t = Object.keys(Object(n)).filter((t => i.indexOf(t) < 0));
                    for (let i = 0, a = t.length; i < a; i += 1) {
                        const a = t[i],
                            s = Object.getOwnPropertyDescriptor(n, a);
                        void 0 !== s && s.enumerable && (b(e[a]) && b(n[a]) ? n[a].__swiper__ ? e[a] = n[a] : y(e[a], n[a]) : !b(e[a]) && b(n[a]) ? (e[a] = {}, n[a].__swiper__ ? e[a] = n[a] : y(e[a], n[a])) : e[a] = n[a])
                    }
                }
            }
            var a;
            return e
        }

        function w(t, e, i) {
            t.style.setProperty(e, i)
        }

        function S({
            swiper: t,
            targetPosition: e,
            side: i
        }) {
            const a = o(),
                s = -t.translate;
            let n, r = null;
            const l = t.params.speed;
            t.wrapperEl.style.scrollSnapType = "none", a.cancelAnimationFrame(t.cssModeFrameID);
            const c = e > s ? "next" : "prev",
                h = (t, e) => "next" === c && t >= e || "prev" === c && t <= e,
                d = () => {
                    n = (new Date).getTime(), null === r && (r = n);
                    const o = Math.max(Math.min((n - r) / l, 1), 0),
                        c = .5 - Math.cos(o * Math.PI) / 2;
                    let u = s + c * (e - s);
                    if (h(u, e) && (u = e), t.wrapperEl.scrollTo({
                            [i]: u
                        }), h(u, e)) return t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.scrollSnapType = "", setTimeout((() => {
                        t.wrapperEl.style.overflow = "", t.wrapperEl.scrollTo({
                            [i]: u
                        })
                    })), void a.cancelAnimationFrame(t.cssModeFrameID);
                    t.cssModeFrameID = a.requestAnimationFrame(d)
                };
            d()
        }
        let C, k, A;

        function E() {
            return C || (C = function() {
                const t = o(),
                    e = n();
                return {
                    smoothScroll: e.documentElement && "scrollBehavior" in e.documentElement.style,
                    touch: !!("ontouchstart" in t || t.DocumentTouch && e instanceof t.DocumentTouch),
                    passiveListener: function() {
                        let e = !1;
                        try {
                            const i = Object.defineProperty({}, "passive", {
                                get() {
                                    e = !0
                                }
                            });
                            t.addEventListener("testPassiveListener", null, i)
                        } catch (t) {}
                        return e
                    }(),
                    gestures: "ongesturestart" in t
                }
            }()), C
        }

        function T(t = {}) {
            return k || (k = function({
                userAgent: t
            } = {}) {
                const e = E(),
                    i = o(),
                    a = i.navigator.platform,
                    s = t || i.navigator.userAgent,
                    n = {
                        ios: !1,
                        android: !1
                    },
                    r = i.screen.width,
                    l = i.screen.height,
                    c = s.match(/(Android);?[\s\/]+([\d.]+)?/);
                let h = s.match(/(iPad).*OS\s([\d_]+)/);
                const d = s.match(/(iPod)(.*OS\s([\d_]+))?/),
                    u = !h && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/),
                    p = "Win32" === a;
                let g = "MacIntel" === a;
                return !h && g && e.touch && ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"].indexOf(`${r}x${l}`) >= 0 && (h = s.match(/(Version)\/([\d.]+)/), h || (h = [0, 1, "13_0_0"]), g = !1), c && !p && (n.os = "android", n.android = !0), (h || u || d) && (n.os = "ios", n.ios = !0), n
            }(t)), k
        }

        function P() {
            return A || (A = function() {
                const t = o();
                return {
                    isSafari: function() {
                        const e = t.navigator.userAgent.toLowerCase();
                        return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0
                    }(),
                    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(t.navigator.userAgent)
                }
            }()), A
        }
        const M = {
            on(t, e, i) {
                const a = this;
                if (!a.eventsListeners || a.destroyed) return a;
                if ("function" != typeof e) return a;
                const s = i ? "unshift" : "push";
                return t.split(" ").forEach((t => {
                    a.eventsListeners[t] || (a.eventsListeners[t] = []), a.eventsListeners[t][s](e)
                })), a
            },
            once(t, e, i) {
                const a = this;
                if (!a.eventsListeners || a.destroyed) return a;
                if ("function" != typeof e) return a;

                function s(...i) {
                    a.off(t, s), s.__emitterProxy && delete s.__emitterProxy, e.apply(a, i)
                }
                return s.__emitterProxy = e, a.on(t, s, i)
            },
            onAny(t, e) {
                const i = this;
                if (!i.eventsListeners || i.destroyed) return i;
                if ("function" != typeof t) return i;
                const a = e ? "unshift" : "push";
                return i.eventsAnyListeners.indexOf(t) < 0 && i.eventsAnyListeners[a](t), i
            },
            offAny(t) {
                const e = this;
                if (!e.eventsListeners || e.destroyed) return e;
                if (!e.eventsAnyListeners) return e;
                const i = e.eventsAnyListeners.indexOf(t);
                return i >= 0 && e.eventsAnyListeners.splice(i, 1), e
            },
            off(t, e) {
                const i = this;
                return !i.eventsListeners || i.destroyed ? i : i.eventsListeners ? (t.split(" ").forEach((t => {
                    void 0 === e ? i.eventsListeners[t] = [] : i.eventsListeners[t] && i.eventsListeners[t].forEach(((a, s) => {
                        (a === e || a.__emitterProxy && a.__emitterProxy === e) && i.eventsListeners[t].splice(s, 1)
                    }))
                })), i) : i
            },
            emit(...t) {
                const e = this;
                if (!e.eventsListeners || e.destroyed) return e;
                if (!e.eventsListeners) return e;
                let i, a, s;
                "string" == typeof t[0] || Array.isArray(t[0]) ? (i = t[0], a = t.slice(1, t.length), s = e) : (i = t[0].events, a = t[0].data, s = t[0].context || e), a.unshift(s);
                return (Array.isArray(i) ? i : i.split(" ")).forEach((t => {
                    e.eventsAnyListeners && e.eventsAnyListeners.length && e.eventsAnyListeners.forEach((e => {
                        e.apply(s, [t, ...a])
                    })), e.eventsListeners && e.eventsListeners[t] && e.eventsListeners[t].forEach((t => {
                        t.apply(s, a)
                    }))
                })), e
            }
        };
        const L = {
            updateSize: function() {
                const t = this;
                let e, i;
                const a = t.$el;
                e = void 0 !== t.params.width && null !== t.params.width ? t.params.width : a[0].clientWidth, i = void 0 !== t.params.height && null !== t.params.height ? t.params.height : a[0].clientHeight, 0 === e && t.isHorizontal() || 0 === i && t.isVertical() || (e = e - parseInt(a.css("padding-left") || 0, 10) - parseInt(a.css("padding-right") || 0, 10), i = i - parseInt(a.css("padding-top") || 0, 10) - parseInt(a.css("padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(i) && (i = 0), Object.assign(t, {
                    width: e,
                    height: i,
                    size: t.isHorizontal() ? e : i
                }))
            },
            updateSlides: function() {
                const t = this;

                function e(e) {
                    return t.isHorizontal() ? e : {
                        width: "height",
                        "margin-top": "margin-left",
                        "margin-bottom ": "margin-right",
                        "margin-left": "margin-top",
                        "margin-right": "margin-bottom",
                        "padding-left": "padding-top",
                        "padding-right": "padding-bottom",
                        marginRight: "marginBottom"
                    }[e]
                }

                function i(t, i) {
                    return parseFloat(t.getPropertyValue(e(i)) || 0)
                }
                const a = t.params,
                    {
                        $wrapperEl: s,
                        size: n,
                        rtlTranslate: r,
                        wrongRTL: o
                    } = t,
                    l = t.virtual && a.virtual.enabled,
                    c = l ? t.virtual.slides.length : t.slides.length,
                    h = s.children(`.${t.params.slideClass}`),
                    d = l ? t.virtual.slides.length : h.length;
                let u = [];
                const p = [],
                    g = [];
                let f = a.slidesOffsetBefore;
                "function" == typeof f && (f = a.slidesOffsetBefore.call(t));
                let m = a.slidesOffsetAfter;
                "function" == typeof m && (m = a.slidesOffsetAfter.call(t));
                const x = t.snapGrid.length,
                    v = t.slidesGrid.length;
                let b = a.spaceBetween,
                    y = -f,
                    S = 0,
                    C = 0;
                if (void 0 === n) return;
                "string" == typeof b && b.indexOf("%") >= 0 && (b = parseFloat(b.replace("%", "")) / 100 * n), t.virtualSize = -b, r ? h.css({
                    marginLeft: "",
                    marginBottom: "",
                    marginTop: ""
                }) : h.css({
                    marginRight: "",
                    marginBottom: "",
                    marginTop: ""
                }), a.centeredSlides && a.cssMode && (w(t.wrapperEl, "--swiper-centered-offset-before", ""), w(t.wrapperEl, "--swiper-centered-offset-after", ""));
                const k = a.grid && a.grid.rows > 1 && t.grid;
                let A;
                k && t.grid.initSlides(d);
                const E = "auto" === a.slidesPerView && a.breakpoints && Object.keys(a.breakpoints).filter((t => void 0 !== a.breakpoints[t].slidesPerView)).length > 0;
                for (let s = 0; s < d; s += 1) {
                    A = 0;
                    const r = h.eq(s);
                    if (k && t.grid.updateSlide(s, r, d, e), "none" !== r.css("display")) {
                        if ("auto" === a.slidesPerView) {
                            E && (h[s].style[e("width")] = "");
                            const n = getComputedStyle(r[0]),
                                o = r[0].style.transform,
                                l = r[0].style.webkitTransform;
                            if (o && (r[0].style.transform = "none"), l && (r[0].style.webkitTransform = "none"), a.roundLengths) A = t.isHorizontal() ? r.outerWidth(!0) : r.outerHeight(!0);
                            else {
                                const t = i(n, "width"),
                                    e = i(n, "padding-left"),
                                    a = i(n, "padding-right"),
                                    s = i(n, "margin-left"),
                                    o = i(n, "margin-right"),
                                    l = n.getPropertyValue("box-sizing");
                                if (l && "border-box" === l) A = t + s + o;
                                else {
                                    const {
                                        clientWidth: i,
                                        offsetWidth: n
                                    } = r[0];
                                    A = t + e + a + s + o + (n - i)
                                }
                            }
                            o && (r[0].style.transform = o), l && (r[0].style.webkitTransform = l), a.roundLengths && (A = Math.floor(A))
                        } else A = (n - (a.slidesPerView - 1) * b) / a.slidesPerView, a.roundLengths && (A = Math.floor(A)), h[s] && (h[s].style[e("width")] = `${A}px`);
                        h[s] && (h[s].swiperSlideSize = A), g.push(A), a.centeredSlides ? (y = y + A / 2 + S / 2 + b, 0 === S && 0 !== s && (y = y - n / 2 - b), 0 === s && (y = y - n / 2 - b), Math.abs(y) < .001 && (y = 0), a.roundLengths && (y = Math.floor(y)), C % a.slidesPerGroup == 0 && u.push(y), p.push(y)) : (a.roundLengths && (y = Math.floor(y)), (C - Math.min(t.params.slidesPerGroupSkip, C)) % t.params.slidesPerGroup == 0 && u.push(y), p.push(y), y = y + A + b), t.virtualSize += A + b, S = A, C += 1
                    }
                }
                if (t.virtualSize = Math.max(t.virtualSize, n) + m, r && o && ("slide" === a.effect || "coverflow" === a.effect) && s.css({
                        width: `${t.virtualSize+a.spaceBetween}px`
                    }), a.setWrapperSize && s.css({
                        [e("width")]: `${t.virtualSize+a.spaceBetween}px`
                    }), k && t.grid.updateWrapperSize(A, u, e), !a.centeredSlides) {
                    const e = [];
                    for (let i = 0; i < u.length; i += 1) {
                        let s = u[i];
                        a.roundLengths && (s = Math.floor(s)), u[i] <= t.virtualSize - n && e.push(s)
                    }
                    u = e, Math.floor(t.virtualSize - n) - Math.floor(u[u.length - 1]) > 1 && u.push(t.virtualSize - n)
                }
                if (0 === u.length && (u = [0]), 0 !== a.spaceBetween) {
                    const i = t.isHorizontal() && r ? "marginLeft" : e("marginRight");
                    h.filter(((t, e) => !a.cssMode || e !== h.length - 1)).css({
                        [i]: `${b}px`
                    })
                }
                if (a.centeredSlides && a.centeredSlidesBounds) {
                    let t = 0;
                    g.forEach((e => {
                        t += e + (a.spaceBetween ? a.spaceBetween : 0)
                    })), t -= a.spaceBetween;
                    const e = t - n;
                    u = u.map((t => t < 0 ? -f : t > e ? e + m : t))
                }
                if (a.centerInsufficientSlides) {
                    let t = 0;
                    if (g.forEach((e => {
                            t += e + (a.spaceBetween ? a.spaceBetween : 0)
                        })), t -= a.spaceBetween, t < n) {
                        const e = (n - t) / 2;
                        u.forEach(((t, i) => {
                            u[i] = t - e
                        })), p.forEach(((t, i) => {
                            p[i] = t + e
                        }))
                    }
                }
                if (Object.assign(t, {
                        slides: h,
                        snapGrid: u,
                        slidesGrid: p,
                        slidesSizesGrid: g
                    }), a.centeredSlides && a.cssMode && !a.centeredSlidesBounds) {
                    w(t.wrapperEl, "--swiper-centered-offset-before", -u[0] + "px"), w(t.wrapperEl, "--swiper-centered-offset-after", t.size / 2 - g[g.length - 1] / 2 + "px");
                    const e = -t.snapGrid[0],
                        i = -t.slidesGrid[0];
                    t.snapGrid = t.snapGrid.map((t => t + e)), t.slidesGrid = t.slidesGrid.map((t => t + i))
                }
                if (d !== c && t.emit("slidesLengthChange"), u.length !== x && (t.params.watchOverflow && t.checkOverflow(), t.emit("snapGridLengthChange")), p.length !== v && t.emit("slidesGridLengthChange"), a.watchSlidesProgress && t.updateSlidesOffset(), !(l || a.cssMode || "slide" !== a.effect && "fade" !== a.effect)) {
                    const e = `${a.containerModifierClass}backface-hidden`,
                        i = t.$el.hasClass(e);
                    d <= a.maxBackfaceHiddenSlides ? i || t.$el.addClass(e) : i && t.$el.removeClass(e)
                }
            },
            updateAutoHeight: function(t) {
                const e = this,
                    i = [],
                    a = e.virtual && e.params.virtual.enabled;
                let s, n = 0;
                "number" == typeof t ? e.setTransition(t) : !0 === t && e.setTransition(e.params.speed);
                const r = t => a ? e.slides.filter((e => parseInt(e.getAttribute("data-swiper-slide-index"), 10) === t))[0] : e.slides.eq(t)[0];
                if ("auto" !== e.params.slidesPerView && e.params.slidesPerView > 1)
                    if (e.params.centeredSlides)(e.visibleSlides || f([])).each((t => {
                        i.push(t)
                    }));
                    else
                        for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) {
                            const t = e.activeIndex + s;
                            if (t > e.slides.length && !a) break;
                            i.push(r(t))
                        } else i.push(r(e.activeIndex));
                for (s = 0; s < i.length; s += 1)
                    if (void 0 !== i[s]) {
                        const t = i[s].offsetHeight;
                        n = t > n ? t : n
                    }(n || 0 === n) && e.$wrapperEl.css("height", `${n}px`)
            },
            updateSlidesOffset: function() {
                const t = this,
                    e = t.slides;
                for (let i = 0; i < e.length; i += 1) e[i].swiperSlideOffset = t.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop
            },
            updateSlidesProgress: function(t = this && this.translate || 0) {
                const e = this,
                    i = e.params,
                    {
                        slides: a,
                        rtlTranslate: s,
                        snapGrid: n
                    } = e;
                if (0 === a.length) return;
                void 0 === a[0].swiperSlideOffset && e.updateSlidesOffset();
                let r = -t;
                s && (r = t), a.removeClass(i.slideVisibleClass), e.visibleSlidesIndexes = [], e.visibleSlides = [];
                for (let t = 0; t < a.length; t += 1) {
                    const o = a[t];
                    let l = o.swiperSlideOffset;
                    i.cssMode && i.centeredSlides && (l -= a[0].swiperSlideOffset);
                    const c = (r + (i.centeredSlides ? e.minTranslate() : 0) - l) / (o.swiperSlideSize + i.spaceBetween),
                        h = (r - n[0] + (i.centeredSlides ? e.minTranslate() : 0) - l) / (o.swiperSlideSize + i.spaceBetween),
                        d = -(r - l),
                        u = d + e.slidesSizesGrid[t];
                    (d >= 0 && d < e.size - 1 || u > 1 && u <= e.size || d <= 0 && u >= e.size) && (e.visibleSlides.push(o), e.visibleSlidesIndexes.push(t), a.eq(t).addClass(i.slideVisibleClass)), o.progress = s ? -c : c, o.originalProgress = s ? -h : h
                }
                e.visibleSlides = f(e.visibleSlides)
            },
            updateProgress: function(t) {
                const e = this;
                if (void 0 === t) {
                    const i = e.rtlTranslate ? -1 : 1;
                    t = e && e.translate && e.translate * i || 0
                }
                const i = e.params,
                    a = e.maxTranslate() - e.minTranslate();
                let {
                    progress: s,
                    isBeginning: n,
                    isEnd: r
                } = e;
                const o = n,
                    l = r;
                0 === a ? (s = 0, n = !0, r = !0) : (s = (t - e.minTranslate()) / a, n = s <= 0, r = s >= 1), Object.assign(e, {
                    progress: s,
                    isBeginning: n,
                    isEnd: r
                }), (i.watchSlidesProgress || i.centeredSlides && i.autoHeight) && e.updateSlidesProgress(t), n && !o && e.emit("reachBeginning toEdge"), r && !l && e.emit("reachEnd toEdge"), (o && !n || l && !r) && e.emit("fromEdge"), e.emit("progress", s)
            },
            updateSlidesClasses: function() {
                const t = this,
                    {
                        slides: e,
                        params: i,
                        $wrapperEl: a,
                        activeIndex: s,
                        realIndex: n
                    } = t,
                    r = t.virtual && i.virtual.enabled;
                let o;
                e.removeClass(`${i.slideActiveClass} ${i.slideNextClass} ${i.slidePrevClass} ${i.slideDuplicateActiveClass} ${i.slideDuplicateNextClass} ${i.slideDuplicatePrevClass}`), o = r ? t.$wrapperEl.find(`.${i.slideClass}[data-swiper-slide-index="${s}"]`) : e.eq(s), o.addClass(i.slideActiveClass), i.loop && (o.hasClass(i.slideDuplicateClass) ? a.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${n}"]`).addClass(i.slideDuplicateActiveClass) : a.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${n}"]`).addClass(i.slideDuplicateActiveClass));
                let l = o.nextAll(`.${i.slideClass}`).eq(0).addClass(i.slideNextClass);
                i.loop && 0 === l.length && (l = e.eq(0), l.addClass(i.slideNextClass));
                let c = o.prevAll(`.${i.slideClass}`).eq(0).addClass(i.slidePrevClass);
                i.loop && 0 === c.length && (c = e.eq(-1), c.addClass(i.slidePrevClass)), i.loop && (l.hasClass(i.slideDuplicateClass) ? a.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass) : a.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${l.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicateNextClass), c.hasClass(i.slideDuplicateClass) ? a.children(`.${i.slideClass}:not(.${i.slideDuplicateClass})[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass) : a.children(`.${i.slideClass}.${i.slideDuplicateClass}[data-swiper-slide-index="${c.attr("data-swiper-slide-index")}"]`).addClass(i.slideDuplicatePrevClass)), t.emitSlidesClasses()
            },
            updateActiveIndex: function(t) {
                const e = this,
                    i = e.rtlTranslate ? e.translate : -e.translate,
                    {
                        slidesGrid: a,
                        snapGrid: s,
                        params: n,
                        activeIndex: r,
                        realIndex: o,
                        snapIndex: l
                    } = e;
                let c, h = t;
                if (void 0 === h) {
                    for (let t = 0; t < a.length; t += 1) void 0 !== a[t + 1] ? i >= a[t] && i < a[t + 1] - (a[t + 1] - a[t]) / 2 ? h = t : i >= a[t] && i < a[t + 1] && (h = t + 1) : i >= a[t] && (h = t);
                    n.normalizeSlideIndex && (h < 0 || void 0 === h) && (h = 0)
                }
                if (s.indexOf(i) >= 0) c = s.indexOf(i);
                else {
                    const t = Math.min(n.slidesPerGroupSkip, h);
                    c = t + Math.floor((h - t) / n.slidesPerGroup)
                }
                if (c >= s.length && (c = s.length - 1), h === r) return void(c !== l && (e.snapIndex = c, e.emit("snapIndexChange")));
                const d = parseInt(e.slides.eq(h).attr("data-swiper-slide-index") || h, 10);
                Object.assign(e, {
                    snapIndex: c,
                    realIndex: d,
                    previousIndex: r,
                    activeIndex: h
                }), e.emit("activeIndexChange"), e.emit("snapIndexChange"), o !== d && e.emit("realIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && e.emit("slideChange")
            },
            updateClickedSlide: function(t) {
                const e = this,
                    i = e.params,
                    a = f(t).closest(`.${i.slideClass}`)[0];
                let s, n = !1;
                if (a)
                    for (let t = 0; t < e.slides.length; t += 1)
                        if (e.slides[t] === a) {
                            n = !0, s = t;
                            break
                        }
                if (!a || !n) return e.clickedSlide = void 0, void(e.clickedIndex = void 0);
                e.clickedSlide = a, e.virtual && e.params.virtual.enabled ? e.clickedIndex = parseInt(f(a).attr("data-swiper-slide-index"), 10) : e.clickedIndex = s, i.slideToClickedSlide && void 0 !== e.clickedIndex && e.clickedIndex !== e.activeIndex && e.slideToClickedSlide()
            }
        };
        const I = {
            getTranslate: function(t = (this.isHorizontal() ? "x" : "y")) {
                const {
                    params: e,
                    rtlTranslate: i,
                    translate: a,
                    $wrapperEl: s
                } = this;
                if (e.virtualTranslate) return i ? -a : a;
                if (e.cssMode) return a;
                let n = v(s[0], t);
                return i && (n = -n), n || 0
            },
            setTranslate: function(t, e) {
                const i = this,
                    {
                        rtlTranslate: a,
                        params: s,
                        $wrapperEl: n,
                        wrapperEl: r,
                        progress: o
                    } = i;
                let l, c = 0,
                    h = 0;
                i.isHorizontal() ? c = a ? -t : t : h = t, s.roundLengths && (c = Math.floor(c), h = Math.floor(h)), s.cssMode ? r[i.isHorizontal() ? "scrollLeft" : "scrollTop"] = i.isHorizontal() ? -c : -h : s.virtualTranslate || n.transform(`translate3d(${c}px, ${h}px, 0px)`), i.previousTranslate = i.translate, i.translate = i.isHorizontal() ? c : h;
                const d = i.maxTranslate() - i.minTranslate();
                l = 0 === d ? 0 : (t - i.minTranslate()) / d, l !== o && i.updateProgress(t), i.emit("setTranslate", i.translate, e)
            },
            minTranslate: function() {
                return -this.snapGrid[0]
            },
            maxTranslate: function() {
                return -this.snapGrid[this.snapGrid.length - 1]
            },
            translateTo: function(t = 0, e = this.params.speed, i = !0, a = !0, s) {
                const n = this,
                    {
                        params: r,
                        wrapperEl: o
                    } = n;
                if (n.animating && r.preventInteractionOnTransition) return !1;
                const l = n.minTranslate(),
                    c = n.maxTranslate();
                let h;
                if (h = a && t > l ? l : a && t < c ? c : t, n.updateProgress(h), r.cssMode) {
                    const t = n.isHorizontal();
                    if (0 === e) o[t ? "scrollLeft" : "scrollTop"] = -h;
                    else {
                        if (!n.support.smoothScroll) return S({
                            swiper: n,
                            targetPosition: -h,
                            side: t ? "left" : "top"
                        }), !0;
                        o.scrollTo({
                            [t ? "left" : "top"]: -h,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return 0 === e ? (n.setTransition(0), n.setTranslate(h), i && (n.emit("beforeTransitionStart", e, s), n.emit("transitionEnd"))) : (n.setTransition(e), n.setTranslate(h), i && (n.emit("beforeTransitionStart", e, s), n.emit("transitionStart")), n.animating || (n.animating = !0, n.onTranslateToWrapperTransitionEnd || (n.onTranslateToWrapperTransitionEnd = function(t) {
                    n && !n.destroyed && t.target === this && (n.$wrapperEl[0].removeEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener("webkitTransitionEnd", n.onTranslateToWrapperTransitionEnd), n.onTranslateToWrapperTransitionEnd = null, delete n.onTranslateToWrapperTransitionEnd, i && n.emit("transitionEnd"))
                }), n.$wrapperEl[0].addEventListener("transitionend", n.onTranslateToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener("webkitTransitionEnd", n.onTranslateToWrapperTransitionEnd))), !0
            }
        };

        function _({
            swiper: t,
            runCallbacks: e,
            direction: i,
            step: a
        }) {
            const {
                activeIndex: s,
                previousIndex: n
            } = t;
            let r = i;
            if (r || (r = s > n ? "next" : s < n ? "prev" : "reset"), t.emit(`transition${a}`), e && s !== n) {
                if ("reset" === r) return void t.emit(`slideResetTransition${a}`);
                t.emit(`slideChangeTransition${a}`), "next" === r ? t.emit(`slideNextTransition${a}`) : t.emit(`slidePrevTransition${a}`)
            }
        }
        const z = {
            slideTo: function(t = 0, e = this.params.speed, i = !0, a, s) {
                if ("number" != typeof t && "string" != typeof t) throw new Error(`The 'index' argument cannot have type other than 'number' or 'string'. [${typeof t}] given.`);
                if ("string" == typeof t) {
                    const e = parseInt(t, 10);
                    if (!isFinite(e)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
                    t = e
                }
                const n = this;
                let r = t;
                r < 0 && (r = 0);
                const {
                    params: o,
                    snapGrid: l,
                    slidesGrid: c,
                    previousIndex: h,
                    activeIndex: d,
                    rtlTranslate: u,
                    wrapperEl: p,
                    enabled: g
                } = n;
                if (n.animating && o.preventInteractionOnTransition || !g && !a && !s) return !1;
                const f = Math.min(n.params.slidesPerGroupSkip, r);
                let m = f + Math.floor((r - f) / n.params.slidesPerGroup);
                m >= l.length && (m = l.length - 1);
                const x = -l[m];
                if (o.normalizeSlideIndex)
                    for (let t = 0; t < c.length; t += 1) {
                        const e = -Math.floor(100 * x),
                            i = Math.floor(100 * c[t]),
                            a = Math.floor(100 * c[t + 1]);
                        void 0 !== c[t + 1] ? e >= i && e < a - (a - i) / 2 ? r = t : e >= i && e < a && (r = t + 1) : e >= i && (r = t)
                    }
                if (n.initialized && r !== d) {
                    if (!n.allowSlideNext && x < n.translate && x < n.minTranslate()) return !1;
                    if (!n.allowSlidePrev && x > n.translate && x > n.maxTranslate() && (d || 0) !== r) return !1
                }
                let v;
                if (r !== (h || 0) && i && n.emit("beforeSlideChangeStart"), n.updateProgress(x), v = r > d ? "next" : r < d ? "prev" : "reset", u && -x === n.translate || !u && x === n.translate) return n.updateActiveIndex(r), o.autoHeight && n.updateAutoHeight(), n.updateSlidesClasses(), "slide" !== o.effect && n.setTranslate(x), "reset" !== v && (n.transitionStart(i, v), n.transitionEnd(i, v)), !1;
                if (o.cssMode) {
                    const t = n.isHorizontal(),
                        i = u ? x : -x;
                    if (0 === e) {
                        const e = n.virtual && n.params.virtual.enabled;
                        e && (n.wrapperEl.style.scrollSnapType = "none", n._immediateVirtual = !0), p[t ? "scrollLeft" : "scrollTop"] = i, e && requestAnimationFrame((() => {
                            n.wrapperEl.style.scrollSnapType = "", n._swiperImmediateVirtual = !1
                        }))
                    } else {
                        if (!n.support.smoothScroll) return S({
                            swiper: n,
                            targetPosition: i,
                            side: t ? "left" : "top"
                        }), !0;
                        p.scrollTo({
                            [t ? "left" : "top"]: i,
                            behavior: "smooth"
                        })
                    }
                    return !0
                }
                return n.setTransition(e), n.setTranslate(x), n.updateActiveIndex(r), n.updateSlidesClasses(), n.emit("beforeTransitionStart", e, a), n.transitionStart(i, v), 0 === e ? n.transitionEnd(i, v) : n.animating || (n.animating = !0, n.onSlideToWrapperTransitionEnd || (n.onSlideToWrapperTransitionEnd = function(t) {
                    n && !n.destroyed && t.target === this && (n.$wrapperEl[0].removeEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.$wrapperEl[0].removeEventListener("webkitTransitionEnd", n.onSlideToWrapperTransitionEnd), n.onSlideToWrapperTransitionEnd = null, delete n.onSlideToWrapperTransitionEnd, n.transitionEnd(i, v))
                }), n.$wrapperEl[0].addEventListener("transitionend", n.onSlideToWrapperTransitionEnd), n.$wrapperEl[0].addEventListener("webkitTransitionEnd", n.onSlideToWrapperTransitionEnd)), !0
            },
            slideToLoop: function(t = 0, e = this.params.speed, i = !0, a) {
                if ("string" == typeof t) {
                    const e = parseInt(t, 10);
                    if (!isFinite(e)) throw new Error(`The passed-in 'index' (string) couldn't be converted to 'number'. [${t}] given.`);
                    t = e
                }
                const s = this;
                let n = t;
                return s.params.loop && (n += s.loopedSlides), s.slideTo(n, e, i, a)
            },
            slideNext: function(t = this.params.speed, e = !0, i) {
                const a = this,
                    {
                        animating: s,
                        enabled: n,
                        params: r
                    } = a;
                if (!n) return a;
                let o = r.slidesPerGroup;
                "auto" === r.slidesPerView && 1 === r.slidesPerGroup && r.slidesPerGroupAuto && (o = Math.max(a.slidesPerViewDynamic("current", !0), 1));
                const l = a.activeIndex < r.slidesPerGroupSkip ? 1 : o;
                if (r.loop) {
                    if (s && r.loopPreventsSlide) return !1;
                    a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
                }
                return r.rewind && a.isEnd ? a.slideTo(0, t, e, i) : a.slideTo(a.activeIndex + l, t, e, i)
            },
            slidePrev: function(t = this.params.speed, e = !0, i) {
                const a = this,
                    {
                        params: s,
                        animating: n,
                        snapGrid: r,
                        slidesGrid: o,
                        rtlTranslate: l,
                        enabled: c
                    } = a;
                if (!c) return a;
                if (s.loop) {
                    if (n && s.loopPreventsSlide) return !1;
                    a.loopFix(), a._clientLeft = a.$wrapperEl[0].clientLeft
                }

                function h(t) {
                    return t < 0 ? -Math.floor(Math.abs(t)) : Math.floor(t)
                }
                const d = h(l ? a.translate : -a.translate),
                    u = r.map((t => h(t)));
                let p = r[u.indexOf(d) - 1];
                if (void 0 === p && s.cssMode) {
                    let t;
                    r.forEach(((e, i) => {
                        d >= e && (t = i)
                    })), void 0 !== t && (p = r[t > 0 ? t - 1 : t])
                }
                let g = 0;
                if (void 0 !== p && (g = o.indexOf(p), g < 0 && (g = a.activeIndex - 1), "auto" === s.slidesPerView && 1 === s.slidesPerGroup && s.slidesPerGroupAuto && (g = g - a.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), s.rewind && a.isBeginning) {
                    const s = a.params.virtual && a.params.virtual.enabled && a.virtual ? a.virtual.slides.length - 1 : a.slides.length - 1;
                    return a.slideTo(s, t, e, i)
                }
                return a.slideTo(g, t, e, i)
            },
            slideReset: function(t = this.params.speed, e = !0, i) {
                return this.slideTo(this.activeIndex, t, e, i)
            },
            slideToClosest: function(t = this.params.speed, e = !0, i, a = .5) {
                const s = this;
                let n = s.activeIndex;
                const r = Math.min(s.params.slidesPerGroupSkip, n),
                    o = r + Math.floor((n - r) / s.params.slidesPerGroup),
                    l = s.rtlTranslate ? s.translate : -s.translate;
                if (l >= s.snapGrid[o]) {
                    const t = s.snapGrid[o];
                    l - t > (s.snapGrid[o + 1] - t) * a && (n += s.params.slidesPerGroup)
                } else {
                    const t = s.snapGrid[o - 1];
                    l - t <= (s.snapGrid[o] - t) * a && (n -= s.params.slidesPerGroup)
                }
                return n = Math.max(n, 0), n = Math.min(n, s.slidesGrid.length - 1), s.slideTo(n, t, e, i)
            },
            slideToClickedSlide: function() {
                const t = this,
                    {
                        params: e,
                        $wrapperEl: i
                    } = t,
                    a = "auto" === e.slidesPerView ? t.slidesPerViewDynamic() : e.slidesPerView;
                let s, n = t.clickedIndex;
                if (e.loop) {
                    if (t.animating) return;
                    s = parseInt(f(t.clickedSlide).attr("data-swiper-slide-index"), 10), e.centeredSlides ? n < t.loopedSlides - a / 2 || n > t.slides.length - t.loopedSlides + a / 2 ? (t.loopFix(), n = i.children(`.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), m((() => {
                        t.slideTo(n)
                    }))) : t.slideTo(n) : n > t.slides.length - a ? (t.loopFix(), n = i.children(`.${e.slideClass}[data-swiper-slide-index="${s}"]:not(.${e.slideDuplicateClass})`).eq(0).index(), m((() => {
                        t.slideTo(n)
                    }))) : t.slideTo(n)
                } else t.slideTo(n)
            }
        };
        const D = {
            loopCreate: function() {
                const t = this,
                    e = n(),
                    {
                        params: i,
                        $wrapperEl: a
                    } = t,
                    s = a.children().length > 0 ? f(a.children()[0].parentNode) : a;
                s.children(`.${i.slideClass}.${i.slideDuplicateClass}`).remove();
                let r = s.children(`.${i.slideClass}`);
                if (i.loopFillGroupWithBlank) {
                    const t = i.slidesPerGroup - r.length % i.slidesPerGroup;
                    if (t !== i.slidesPerGroup) {
                        for (let a = 0; a < t; a += 1) {
                            const t = f(e.createElement("div")).addClass(`${i.slideClass} ${i.slideBlankClass}`);
                            s.append(t)
                        }
                        r = s.children(`.${i.slideClass}`)
                    }
                }
                "auto" !== i.slidesPerView || i.loopedSlides || (i.loopedSlides = r.length), t.loopedSlides = Math.ceil(parseFloat(i.loopedSlides || i.slidesPerView, 10)), t.loopedSlides += i.loopAdditionalSlides, t.loopedSlides > r.length && t.params.loopedSlidesLimit && (t.loopedSlides = r.length);
                const o = [],
                    l = [];
                r.each(((t, e) => {
                    f(t).attr("data-swiper-slide-index", e)
                }));
                for (let e = 0; e < t.loopedSlides; e += 1) {
                    const t = e - Math.floor(e / r.length) * r.length;
                    l.push(r.eq(t)[0]), o.unshift(r.eq(r.length - t - 1)[0])
                }
                for (let t = 0; t < l.length; t += 1) s.append(f(l[t].cloneNode(!0)).addClass(i.slideDuplicateClass));
                for (let t = o.length - 1; t >= 0; t -= 1) s.prepend(f(o[t].cloneNode(!0)).addClass(i.slideDuplicateClass))
            },
            loopFix: function() {
                const t = this;
                t.emit("beforeLoopFix");
                const {
                    activeIndex: e,
                    slides: i,
                    loopedSlides: a,
                    allowSlidePrev: s,
                    allowSlideNext: n,
                    snapGrid: r,
                    rtlTranslate: o
                } = t;
                let l;
                t.allowSlidePrev = !0, t.allowSlideNext = !0;
                const c = -r[e] - t.getTranslate();
                if (e < a) {
                    l = i.length - 3 * a + e, l += a;
                    t.slideTo(l, 0, !1, !0) && 0 !== c && t.setTranslate((o ? -t.translate : t.translate) - c)
                } else if (e >= i.length - a) {
                    l = -i.length + e + a, l += a;
                    t.slideTo(l, 0, !1, !0) && 0 !== c && t.setTranslate((o ? -t.translate : t.translate) - c)
                }
                t.allowSlidePrev = s, t.allowSlideNext = n, t.emit("loopFix")
            },
            loopDestroy: function() {
                const {
                    $wrapperEl: t,
                    params: e,
                    slides: i
                } = this;
                t.children(`.${e.slideClass}.${e.slideDuplicateClass},.${e.slideClass}.${e.slideBlankClass}`).remove(), i.removeAttr("data-swiper-slide-index")
            }
        };

        function X(t) {
            const e = this,
                i = n(),
                a = o(),
                s = e.touchEventsData,
                {
                    params: r,
                    touches: l,
                    enabled: c
                } = e;
            if (!c) return;
            if (e.animating && r.preventInteractionOnTransition) return;
            !e.animating && r.cssMode && r.loop && e.loopFix();
            let h = t;
            h.originalEvent && (h = h.originalEvent);
            let d = f(h.target);
            if ("wrapper" === r.touchEventsTarget && !d.closest(e.wrapperEl).length) return;
            if (s.isTouchEvent = "touchstart" === h.type, !s.isTouchEvent && "which" in h && 3 === h.which) return;
            if (!s.isTouchEvent && "button" in h && h.button > 0) return;
            if (s.isTouched && s.isMoved) return;
            const u = !!r.noSwipingClass && "" !== r.noSwipingClass,
                p = t.composedPath ? t.composedPath() : t.path;
            u && h.target && h.target.shadowRoot && p && (d = f(p[0]));
            const g = r.noSwipingSelector ? r.noSwipingSelector : `.${r.noSwipingClass}`,
                m = !(!h.target || !h.target.shadowRoot);
            if (r.noSwiping && (m ? function(t, e = this) {
                    return function e(i) {
                        if (!i || i === n() || i === o()) return null;
                        i.assignedSlot && (i = i.assignedSlot);
                        const a = i.closest(t);
                        return a || i.getRootNode ? a || e(i.getRootNode().host) : null
                    }(e)
                }(g, d[0]) : d.closest(g)[0])) return void(e.allowClick = !0);
            if (r.swipeHandler && !d.closest(r.swipeHandler)[0]) return;
            l.currentX = "touchstart" === h.type ? h.targetTouches[0].pageX : h.pageX, l.currentY = "touchstart" === h.type ? h.targetTouches[0].pageY : h.pageY;
            const v = l.currentX,
                b = l.currentY,
                y = r.edgeSwipeDetection || r.iOSEdgeSwipeDetection,
                w = r.edgeSwipeThreshold || r.iOSEdgeSwipeThreshold;
            if (y && (v <= w || v >= a.innerWidth - w)) {
                if ("prevent" !== y) return;
                t.preventDefault()
            }
            if (Object.assign(s, {
                    isTouched: !0,
                    isMoved: !1,
                    allowTouchCallbacks: !0,
                    isScrolling: void 0,
                    startMoving: void 0
                }), l.startX = v, l.startY = b, s.touchStartTime = x(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, r.threshold > 0 && (s.allowThresholdMove = !1), "touchstart" !== h.type) {
                let t = !0;
                d.is(s.focusableElements) && (t = !1, "SELECT" === d[0].nodeName && (s.isTouched = !1)), i.activeElement && f(i.activeElement).is(s.focusableElements) && i.activeElement !== d[0] && i.activeElement.blur();
                const a = t && e.allowTouchMove && r.touchStartPreventDefault;
                !r.touchStartForcePreventDefault && !a || d[0].isContentEditable || h.preventDefault()
            }
            e.params.freeMode && e.params.freeMode.enabled && e.freeMode && e.animating && !r.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", h)
        }

        function O(t) {
            const e = n(),
                i = this,
                a = i.touchEventsData,
                {
                    params: s,
                    touches: r,
                    rtlTranslate: o,
                    enabled: l
                } = i;
            if (!l) return;
            let c = t;
            if (c.originalEvent && (c = c.originalEvent), !a.isTouched) return void(a.startMoving && a.isScrolling && i.emit("touchMoveOpposite", c));
            if (a.isTouchEvent && "touchmove" !== c.type) return;
            const h = "touchmove" === c.type && c.targetTouches && (c.targetTouches[0] || c.changedTouches[0]),
                d = "touchmove" === c.type ? h.pageX : c.pageX,
                u = "touchmove" === c.type ? h.pageY : c.pageY;
            if (c.preventedByNestedSwiper) return r.startX = d, void(r.startY = u);
            if (!i.allowTouchMove) return f(c.target).is(a.focusableElements) || (i.allowClick = !1), void(a.isTouched && (Object.assign(r, {
                startX: d,
                startY: u,
                currentX: d,
                currentY: u
            }), a.touchStartTime = x()));
            if (a.isTouchEvent && s.touchReleaseOnEdges && !s.loop)
                if (i.isVertical()) {
                    if (u < r.startY && i.translate <= i.maxTranslate() || u > r.startY && i.translate >= i.minTranslate()) return a.isTouched = !1, void(a.isMoved = !1)
                } else if (d < r.startX && i.translate <= i.maxTranslate() || d > r.startX && i.translate >= i.minTranslate()) return;
            if (a.isTouchEvent && e.activeElement && c.target === e.activeElement && f(c.target).is(a.focusableElements)) return a.isMoved = !0, void(i.allowClick = !1);
            if (a.allowTouchCallbacks && i.emit("touchMove", c), c.targetTouches && c.targetTouches.length > 1) return;
            r.currentX = d, r.currentY = u;
            const p = r.currentX - r.startX,
                g = r.currentY - r.startY;
            if (i.params.threshold && Math.sqrt(p ** 2 + g ** 2) < i.params.threshold) return;
            if (void 0 === a.isScrolling) {
                let t;
                i.isHorizontal() && r.currentY === r.startY || i.isVertical() && r.currentX === r.startX ? a.isScrolling = !1 : p * p + g * g >= 25 && (t = 180 * Math.atan2(Math.abs(g), Math.abs(p)) / Math.PI, a.isScrolling = i.isHorizontal() ? t > s.touchAngle : 90 - t > s.touchAngle)
            }
            if (a.isScrolling && i.emit("touchMoveOpposite", c), void 0 === a.startMoving && (r.currentX === r.startX && r.currentY === r.startY || (a.startMoving = !0)), a.isScrolling) return void(a.isTouched = !1);
            if (!a.startMoving) return;
            i.allowClick = !1, !s.cssMode && c.cancelable && c.preventDefault(), s.touchMoveStopPropagation && !s.nested && c.stopPropagation(), a.isMoved || (s.loop && !s.cssMode && i.loopFix(), a.startTranslate = i.getTranslate(), i.setTransition(0), i.animating && i.$wrapperEl.trigger("webkitTransitionEnd transitionend"), a.allowMomentumBounce = !1, !s.grabCursor || !0 !== i.allowSlideNext && !0 !== i.allowSlidePrev || i.setGrabCursor(!0), i.emit("sliderFirstMove", c)), i.emit("sliderMove", c), a.isMoved = !0;
            let m = i.isHorizontal() ? p : g;
            r.diff = m, m *= s.touchRatio, o && (m = -m), i.swipeDirection = m > 0 ? "prev" : "next", a.currentTranslate = m + a.startTranslate;
            let v = !0,
                b = s.resistanceRatio;
            if (s.touchReleaseOnEdges && (b = 0), m > 0 && a.currentTranslate > i.minTranslate() ? (v = !1, s.resistance && (a.currentTranslate = i.minTranslate() - 1 + (-i.minTranslate() + a.startTranslate + m) ** b)) : m < 0 && a.currentTranslate < i.maxTranslate() && (v = !1, s.resistance && (a.currentTranslate = i.maxTranslate() + 1 - (i.maxTranslate() - a.startTranslate - m) ** b)), v && (c.preventedByNestedSwiper = !0), !i.allowSlideNext && "next" === i.swipeDirection && a.currentTranslate < a.startTranslate && (a.currentTranslate = a.startTranslate), !i.allowSlidePrev && "prev" === i.swipeDirection && a.currentTranslate > a.startTranslate && (a.currentTranslate = a.startTranslate), i.allowSlidePrev || i.allowSlideNext || (a.currentTranslate = a.startTranslate), s.threshold > 0) {
                if (!(Math.abs(m) > s.threshold || a.allowThresholdMove)) return void(a.currentTranslate = a.startTranslate);
                if (!a.allowThresholdMove) return a.allowThresholdMove = !0, r.startX = r.currentX, r.startY = r.currentY, a.currentTranslate = a.startTranslate, void(r.diff = i.isHorizontal() ? r.currentX - r.startX : r.currentY - r.startY)
            }
            s.followFinger && !s.cssMode && ((s.freeMode && s.freeMode.enabled && i.freeMode || s.watchSlidesProgress) && (i.updateActiveIndex(), i.updateSlidesClasses()), i.params.freeMode && s.freeMode.enabled && i.freeMode && i.freeMode.onTouchMove(), i.updateProgress(a.currentTranslate), i.setTranslate(a.currentTranslate))
        }

        function N(t) {
            const e = this,
                i = e.touchEventsData,
                {
                    params: a,
                    touches: s,
                    rtlTranslate: n,
                    slidesGrid: r,
                    enabled: o
                } = e;
            if (!o) return;
            let l = t;
            if (l.originalEvent && (l = l.originalEvent), i.allowTouchCallbacks && e.emit("touchEnd", l), i.allowTouchCallbacks = !1, !i.isTouched) return i.isMoved && a.grabCursor && e.setGrabCursor(!1), i.isMoved = !1, void(i.startMoving = !1);
            a.grabCursor && i.isMoved && i.isTouched && (!0 === e.allowSlideNext || !0 === e.allowSlidePrev) && e.setGrabCursor(!1);
            const c = x(),
                h = c - i.touchStartTime;
            if (e.allowClick) {
                const t = l.path || l.composedPath && l.composedPath();
                e.updateClickedSlide(t && t[0] || l.target), e.emit("tap click", l), h < 300 && c - i.lastClickTime < 300 && e.emit("doubleTap doubleClick", l)
            }
            if (i.lastClickTime = x(), m((() => {
                    e.destroyed || (e.allowClick = !0)
                })), !i.isTouched || !i.isMoved || !e.swipeDirection || 0 === s.diff || i.currentTranslate === i.startTranslate) return i.isTouched = !1, i.isMoved = !1, void(i.startMoving = !1);
            let d;
            if (i.isTouched = !1, i.isMoved = !1, i.startMoving = !1, d = a.followFinger ? n ? e.translate : -e.translate : -i.currentTranslate, a.cssMode) return;
            if (e.params.freeMode && a.freeMode.enabled) return void e.freeMode.onTouchEnd({
                currentPos: d
            });
            let u = 0,
                p = e.slidesSizesGrid[0];
            for (let t = 0; t < r.length; t += t < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
                const e = t < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
                void 0 !== r[t + e] ? d >= r[t] && d < r[t + e] && (u = t, p = r[t + e] - r[t]) : d >= r[t] && (u = t, p = r[r.length - 1] - r[r.length - 2])
            }
            let g = null,
                f = null;
            a.rewind && (e.isBeginning ? f = e.params.virtual && e.params.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (g = 0));
            const v = (d - r[u]) / p,
                b = u < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
            if (h > a.longSwipesMs) {
                if (!a.longSwipes) return void e.slideTo(e.activeIndex);
                "next" === e.swipeDirection && (v >= a.longSwipesRatio ? e.slideTo(a.rewind && e.isEnd ? g : u + b) : e.slideTo(u)), "prev" === e.swipeDirection && (v > 1 - a.longSwipesRatio ? e.slideTo(u + b) : null !== f && v < 0 && Math.abs(v) > a.longSwipesRatio ? e.slideTo(f) : e.slideTo(u))
            } else {
                if (!a.shortSwipes) return void e.slideTo(e.activeIndex);
                e.navigation && (l.target === e.navigation.nextEl || l.target === e.navigation.prevEl) ? l.target === e.navigation.nextEl ? e.slideTo(u + b) : e.slideTo(u) : ("next" === e.swipeDirection && e.slideTo(null !== g ? g : u + b), "prev" === e.swipeDirection && e.slideTo(null !== f ? f : u))
            }
        }

        function Y() {
            const t = this,
                {
                    params: e,
                    el: i
                } = t;
            if (i && 0 === i.offsetWidth) return;
            e.breakpoints && t.setBreakpoint();
            const {
                allowSlideNext: a,
                allowSlidePrev: s,
                snapGrid: n
            } = t;
            t.allowSlideNext = !0, t.allowSlidePrev = !0, t.updateSize(), t.updateSlides(), t.updateSlidesClasses(), ("auto" === e.slidesPerView || e.slidesPerView > 1) && t.isEnd && !t.isBeginning && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), t.autoplay && t.autoplay.running && t.autoplay.paused && t.autoplay.run(), t.allowSlidePrev = s, t.allowSlideNext = a, t.params.watchOverflow && n !== t.snapGrid && t.checkOverflow()
        }

        function F(t) {
            const e = this;
            e.enabled && (e.allowClick || (e.params.preventClicks && t.preventDefault(), e.params.preventClicksPropagation && e.animating && (t.stopPropagation(), t.stopImmediatePropagation())))
        }

        function R() {
            const t = this,
                {
                    wrapperEl: e,
                    rtlTranslate: i,
                    enabled: a
                } = t;
            if (!a) return;
            let s;
            t.previousTranslate = t.translate, t.isHorizontal() ? t.translate = -e.scrollLeft : t.translate = -e.scrollTop, 0 === t.translate && (t.translate = 0), t.updateActiveIndex(), t.updateSlidesClasses();
            const n = t.maxTranslate() - t.minTranslate();
            s = 0 === n ? 0 : (t.translate - t.minTranslate()) / n, s !== t.progress && t.updateProgress(i ? -t.translate : t.translate), t.emit("setTranslate", t.translate, !1)
        }
        let H = !1;

        function W() {}
        const B = (t, e) => {
            const i = n(),
                {
                    params: a,
                    touchEvents: s,
                    el: r,
                    wrapperEl: o,
                    device: l,
                    support: c
                } = t,
                h = !!a.nested,
                d = "on" === e ? "addEventListener" : "removeEventListener",
                u = e;
            if (c.touch) {
                const e = !("touchstart" !== s.start || !c.passiveListener || !a.passiveListeners) && {
                    passive: !0,
                    capture: !1
                };
                r[d](s.start, t.onTouchStart, e), r[d](s.move, t.onTouchMove, c.passiveListener ? {
                    passive: !1,
                    capture: h
                } : h), r[d](s.end, t.onTouchEnd, e), s.cancel && r[d](s.cancel, t.onTouchEnd, e)
            } else r[d](s.start, t.onTouchStart, !1), i[d](s.move, t.onTouchMove, h), i[d](s.end, t.onTouchEnd, !1);
            (a.preventClicks || a.preventClicksPropagation) && r[d]("click", t.onClick, !0), a.cssMode && o[d]("scroll", t.onScroll), a.updateOnWindowResize ? t[u](l.ios || l.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Y, !0) : t[u]("observerUpdate", Y, !0)
        };
        const $ = {
                attachEvents: function() {
                    const t = this,
                        e = n(),
                        {
                            params: i,
                            support: a
                        } = t;
                    t.onTouchStart = X.bind(t), t.onTouchMove = O.bind(t), t.onTouchEnd = N.bind(t), i.cssMode && (t.onScroll = R.bind(t)), t.onClick = F.bind(t), a.touch && !H && (e.addEventListener("touchstart", W), H = !0), B(t, "on")
                },
                detachEvents: function() {
                    B(this, "off")
                }
            },
            G = (t, e) => t.grid && e.grid && e.grid.rows > 1;
        const V = {
            setBreakpoint: function() {
                const t = this,
                    {
                        activeIndex: e,
                        initialized: i,
                        loopedSlides: a = 0,
                        params: s,
                        $el: n
                    } = t,
                    r = s.breakpoints;
                if (!r || r && 0 === Object.keys(r).length) return;
                const o = t.getBreakpoint(r, t.params.breakpointsBase, t.el);
                if (!o || t.currentBreakpoint === o) return;
                const l = (o in r ? r[o] : void 0) || t.originalParams,
                    c = G(t, s),
                    h = G(t, l),
                    d = s.enabled;
                c && !h ? (n.removeClass(`${s.containerModifierClass}grid ${s.containerModifierClass}grid-column`), t.emitContainerClasses()) : !c && h && (n.addClass(`${s.containerModifierClass}grid`), (l.grid.fill && "column" === l.grid.fill || !l.grid.fill && "column" === s.grid.fill) && n.addClass(`${s.containerModifierClass}grid-column`), t.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((e => {
                    const i = s[e] && s[e].enabled,
                        a = l[e] && l[e].enabled;
                    i && !a && t[e].disable(), !i && a && t[e].enable()
                }));
                const u = l.direction && l.direction !== s.direction,
                    p = s.loop && (l.slidesPerView !== s.slidesPerView || u);
                u && i && t.changeDirection(), y(t.params, l);
                const g = t.params.enabled;
                Object.assign(t, {
                    allowTouchMove: t.params.allowTouchMove,
                    allowSlideNext: t.params.allowSlideNext,
                    allowSlidePrev: t.params.allowSlidePrev
                }), d && !g ? t.disable() : !d && g && t.enable(), t.currentBreakpoint = o, t.emit("_beforeBreakpoint", l), p && i && (t.loopDestroy(), t.loopCreate(), t.updateSlides(), t.slideTo(e - a + t.loopedSlides, 0, !1)), t.emit("breakpoint", l)
            },
            getBreakpoint: function(t, e = "window", i) {
                if (!t || "container" === e && !i) return;
                let a = !1;
                const s = o(),
                    n = "window" === e ? s.innerHeight : i.clientHeight,
                    r = Object.keys(t).map((t => {
                        if ("string" == typeof t && 0 === t.indexOf("@")) {
                            const e = parseFloat(t.substr(1));
                            return {
                                value: n * e,
                                point: t
                            }
                        }
                        return {
                            value: t,
                            point: t
                        }
                    }));
                r.sort(((t, e) => parseInt(t.value, 10) - parseInt(e.value, 10)));
                for (let t = 0; t < r.length; t += 1) {
                    const {
                        point: n,
                        value: o
                    } = r[t];
                    "window" === e ? s.matchMedia(`(min-width: ${o}px)`).matches && (a = n) : o <= i.clientWidth && (a = n)
                }
                return a || "max"
            }
        };
        const j = {
            addClasses: function() {
                const t = this,
                    {
                        classNames: e,
                        params: i,
                        rtl: a,
                        $el: s,
                        device: n,
                        support: r
                    } = t,
                    o = function(t, e) {
                        const i = [];
                        return t.forEach((t => {
                            "object" == typeof t ? Object.keys(t).forEach((a => {
                                t[a] && i.push(e + a)
                            })) : "string" == typeof t && i.push(e + t)
                        })), i
                    }(["initialized", i.direction, {
                        "pointer-events": !r.touch
                    }, {
                        "free-mode": t.params.freeMode && i.freeMode.enabled
                    }, {
                        autoheight: i.autoHeight
                    }, {
                        rtl: a
                    }, {
                        grid: i.grid && i.grid.rows > 1
                    }, {
                        "grid-column": i.grid && i.grid.rows > 1 && "column" === i.grid.fill
                    }, {
                        android: n.android
                    }, {
                        ios: n.ios
                    }, {
                        "css-mode": i.cssMode
                    }, {
                        centered: i.cssMode && i.centeredSlides
                    }, {
                        "watch-progress": i.watchSlidesProgress
                    }], i.containerModifierClass);
                e.push(...o), s.addClass([...e].join(" ")), t.emitContainerClasses()
            },
            removeClasses: function() {
                const {
                    $el: t,
                    classNames: e
                } = this;
                t.removeClass(e.join(" ")), this.emitContainerClasses()
            }
        };
        const U = {
            loadImage: function(t, e, i, a, s, n) {
                const r = o();
                let l;

                function c() {
                    n && n()
                }
                f(t).parent("picture")[0] || t.complete && s ? c() : e ? (l = new r.Image, l.onload = c, l.onerror = c, a && (l.sizes = a), i && (l.srcset = i), e && (l.src = e)) : c()
            },
            preloadImages: function() {
                const t = this;

                function e() {
                    null != t && t && !t.destroyed && (void 0 !== t.imagesLoaded && (t.imagesLoaded += 1), t.imagesLoaded === t.imagesToLoad.length && (t.params.updateOnImagesReady && t.update(), t.emit("imagesReady")))
                }
                t.imagesToLoad = t.$el.find("img");
                for (let i = 0; i < t.imagesToLoad.length; i += 1) {
                    const a = t.imagesToLoad[i];
                    t.loadImage(a, a.currentSrc || a.getAttribute("src"), a.srcset || a.getAttribute("srcset"), a.sizes || a.getAttribute("sizes"), !0, e)
                }
            }
        };
        const q = {
            init: !0,
            direction: "horizontal",
            touchEventsTarget: "wrapper",
            initialSlide: 0,
            speed: 300,
            cssMode: !1,
            updateOnWindowResize: !0,
            resizeObserver: !0,
            nested: !1,
            createElements: !1,
            enabled: !0,
            focusableElements: "input, select, option, textarea, button, video, label",
            width: null,
            height: null,
            preventInteractionOnTransition: !1,
            userAgent: null,
            url: null,
            edgeSwipeDetection: !1,
            edgeSwipeThreshold: 20,
            autoHeight: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: "slide",
            breakpoints: void 0,
            breakpointsBase: "window",
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerGroup: 1,
            slidesPerGroupSkip: 0,
            slidesPerGroupAuto: !1,
            centeredSlides: !1,
            centeredSlidesBounds: !1,
            slidesOffsetBefore: 0,
            slidesOffsetAfter: 0,
            normalizeSlideIndex: !0,
            centerInsufficientSlides: !1,
            watchOverflow: !0,
            roundLengths: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: !0,
            allowTouchMove: !0,
            threshold: 0,
            touchMoveStopPropagation: !1,
            touchStartPreventDefault: !0,
            touchStartForcePreventDefault: !1,
            touchReleaseOnEdges: !1,
            uniqueNavElements: !0,
            resistance: !0,
            resistanceRatio: .85,
            watchSlidesProgress: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            preloadImages: !0,
            updateOnImagesReady: !0,
            loop: !1,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            loopedSlidesLimit: !0,
            loopFillGroupWithBlank: !1,
            loopPreventsSlide: !0,
            rewind: !1,
            allowSlidePrev: !0,
            allowSlideNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: "swiper-no-swiping",
            noSwipingSelector: null,
            passiveListeners: !0,
            maxBackfaceHiddenSlides: 10,
            containerModifierClass: "swiper-",
            slideClass: "swiper-slide",
            slideBlankClass: "swiper-slide-invisible-blank",
            slideActiveClass: "swiper-slide-active",
            slideDuplicateActiveClass: "swiper-slide-duplicate-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slideDuplicateNextClass: "swiper-slide-duplicate-next",
            slidePrevClass: "swiper-slide-prev",
            slideDuplicatePrevClass: "swiper-slide-duplicate-prev",
            wrapperClass: "swiper-wrapper",
            runCallbacksOnInit: !0,
            _emitClasses: !1
        };

        function Z(t, e) {
            return function(i = {}) {
                const a = Object.keys(i)[0],
                    s = i[a];
                "object" == typeof s && null !== s ? (["navigation", "pagination", "scrollbar"].indexOf(a) >= 0 && !0 === t[a] && (t[a] = {
                    auto: !0
                }), a in t && "enabled" in s ? (!0 === t[a] && (t[a] = {
                    enabled: !0
                }), "object" != typeof t[a] || "enabled" in t[a] || (t[a].enabled = !0), t[a] || (t[a] = {
                    enabled: !1
                }), y(e, i)) : y(e, i)) : y(e, i)
            }
        }
        const K = {
                eventsEmitter: M,
                update: L,
                translate: I,
                transition: {
                    setTransition: function(t, e) {
                        const i = this;
                        i.params.cssMode || i.$wrapperEl.transition(t), i.emit("setTransition", t, e)
                    },
                    transitionStart: function(t = !0, e) {
                        const i = this,
                            {
                                params: a
                            } = i;
                        a.cssMode || (a.autoHeight && i.updateAutoHeight(), _({
                            swiper: i,
                            runCallbacks: t,
                            direction: e,
                            step: "Start"
                        }))
                    },
                    transitionEnd: function(t = !0, e) {
                        const i = this,
                            {
                                params: a
                            } = i;
                        i.animating = !1, a.cssMode || (i.setTransition(0), _({
                            swiper: i,
                            runCallbacks: t,
                            direction: e,
                            step: "End"
                        }))
                    }
                },
                slide: z,
                loop: D,
                grabCursor: {
                    setGrabCursor: function(t) {
                        const e = this;
                        if (e.support.touch || !e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return;
                        const i = "container" === e.params.touchEventsTarget ? e.el : e.wrapperEl;
                        i.style.cursor = "move", i.style.cursor = t ? "grabbing" : "grab"
                    },
                    unsetGrabCursor: function() {
                        const t = this;
                        t.support.touch || t.params.watchOverflow && t.isLocked || t.params.cssMode || (t["container" === t.params.touchEventsTarget ? "el" : "wrapperEl"].style.cursor = "")
                    }
                },
                events: $,
                breakpoints: V,
                checkOverflow: {
                    checkOverflow: function() {
                        const t = this,
                            {
                                isLocked: e,
                                params: i
                            } = t,
                            {
                                slidesOffsetBefore: a
                            } = i;
                        if (a) {
                            const e = t.slides.length - 1,
                                i = t.slidesGrid[e] + t.slidesSizesGrid[e] + 2 * a;
                            t.isLocked = t.size > i
                        } else t.isLocked = 1 === t.snapGrid.length;
                        !0 === i.allowSlideNext && (t.allowSlideNext = !t.isLocked), !0 === i.allowSlidePrev && (t.allowSlidePrev = !t.isLocked), e && e !== t.isLocked && (t.isEnd = !1), e !== t.isLocked && t.emit(t.isLocked ? "lock" : "unlock")
                    }
                },
                classes: j,
                images: U
            },
            Q = {};
        class J {
            constructor(...t) {
                let e, i;
                if (1 === t.length && t[0].constructor && "Object" === Object.prototype.toString.call(t[0]).slice(8, -1) ? i = t[0] : [e, i] = t, i || (i = {}), i = y({}, i), e && !i.el && (i.el = e), i.el && f(i.el).length > 1) {
                    const t = [];
                    return f(i.el).each((e => {
                        const a = y({}, i, {
                            el: e
                        });
                        t.push(new J(a))
                    })), t
                }
                const a = this;
                a.__swiper__ = !0, a.support = E(), a.device = T({
                    userAgent: i.userAgent
                }), a.browser = P(), a.eventsListeners = {}, a.eventsAnyListeners = [], a.modules = [...a.__modules__], i.modules && Array.isArray(i.modules) && a.modules.push(...i.modules);
                const s = {};
                a.modules.forEach((t => {
                    t({
                        swiper: a,
                        extendParams: Z(i, s),
                        on: a.on.bind(a),
                        once: a.once.bind(a),
                        off: a.off.bind(a),
                        emit: a.emit.bind(a)
                    })
                }));
                const n = y({}, q, s);
                return a.params = y({}, n, Q, i), a.originalParams = y({}, a.params), a.passedParams = y({}, i), a.params && a.params.on && Object.keys(a.params.on).forEach((t => {
                    a.on(t, a.params.on[t])
                })), a.params && a.params.onAny && a.onAny(a.params.onAny), a.$ = f, Object.assign(a, {
                    enabled: a.params.enabled,
                    el: e,
                    classNames: [],
                    slides: f(),
                    slidesGrid: [],
                    snapGrid: [],
                    slidesSizesGrid: [],
                    isHorizontal: () => "horizontal" === a.params.direction,
                    isVertical: () => "vertical" === a.params.direction,
                    activeIndex: 0,
                    realIndex: 0,
                    isBeginning: !0,
                    isEnd: !1,
                    translate: 0,
                    previousTranslate: 0,
                    progress: 0,
                    velocity: 0,
                    animating: !1,
                    allowSlideNext: a.params.allowSlideNext,
                    allowSlidePrev: a.params.allowSlidePrev,
                    touchEvents: function() {
                        const t = ["touchstart", "touchmove", "touchend", "touchcancel"],
                            e = ["pointerdown", "pointermove", "pointerup"];
                        return a.touchEventsTouch = {
                            start: t[0],
                            move: t[1],
                            end: t[2],
                            cancel: t[3]
                        }, a.touchEventsDesktop = {
                            start: e[0],
                            move: e[1],
                            end: e[2]
                        }, a.support.touch || !a.params.simulateTouch ? a.touchEventsTouch : a.touchEventsDesktop
                    }(),
                    touchEventsData: {
                        isTouched: void 0,
                        isMoved: void 0,
                        allowTouchCallbacks: void 0,
                        touchStartTime: void 0,
                        isScrolling: void 0,
                        currentTranslate: void 0,
                        startTranslate: void 0,
                        allowThresholdMove: void 0,
                        focusableElements: a.params.focusableElements,
                        lastClickTime: x(),
                        clickTimeout: void 0,
                        velocities: [],
                        allowMomentumBounce: void 0,
                        isTouchEvent: void 0,
                        startMoving: void 0
                    },
                    allowClick: !0,
                    allowTouchMove: a.params.allowTouchMove,
                    touches: {
                        startX: 0,
                        startY: 0,
                        currentX: 0,
                        currentY: 0,
                        diff: 0
                    },
                    imagesToLoad: [],
                    imagesLoaded: 0
                }), a.emit("_swiper"), a.params.init && a.init(), a
            }
            enable() {
                const t = this;
                t.enabled || (t.enabled = !0, t.params.grabCursor && t.setGrabCursor(), t.emit("enable"))
            }
            disable() {
                const t = this;
                t.enabled && (t.enabled = !1, t.params.grabCursor && t.unsetGrabCursor(), t.emit("disable"))
            }
            setProgress(t, e) {
                const i = this;
                t = Math.min(Math.max(t, 0), 1);
                const a = i.minTranslate(),
                    s = (i.maxTranslate() - a) * t + a;
                i.translateTo(s, void 0 === e ? 0 : e), i.updateActiveIndex(), i.updateSlidesClasses()
            }
            emitContainerClasses() {
                const t = this;
                if (!t.params._emitClasses || !t.el) return;
                const e = t.el.className.split(" ").filter((e => 0 === e.indexOf("swiper") || 0 === e.indexOf(t.params.containerModifierClass)));
                t.emit("_containerClasses", e.join(" "))
            }
            getSlideClasses(t) {
                const e = this;
                return e.destroyed ? "" : t.className.split(" ").filter((t => 0 === t.indexOf("swiper-slide") || 0 === t.indexOf(e.params.slideClass))).join(" ")
            }
            emitSlidesClasses() {
                const t = this;
                if (!t.params._emitClasses || !t.el) return;
                const e = [];
                t.slides.each((i => {
                    const a = t.getSlideClasses(i);
                    e.push({
                        slideEl: i,
                        classNames: a
                    }), t.emit("_slideClass", i, a)
                })), t.emit("_slideClasses", e)
            }
            slidesPerViewDynamic(t = "current", e = !1) {
                const {
                    params: i,
                    slides: a,
                    slidesGrid: s,
                    slidesSizesGrid: n,
                    size: r,
                    activeIndex: o
                } = this;
                let l = 1;
                if (i.centeredSlides) {
                    let t, e = a[o].swiperSlideSize;
                    for (let i = o + 1; i < a.length; i += 1) a[i] && !t && (e += a[i].swiperSlideSize, l += 1, e > r && (t = !0));
                    for (let i = o - 1; i >= 0; i -= 1) a[i] && !t && (e += a[i].swiperSlideSize, l += 1, e > r && (t = !0))
                } else if ("current" === t)
                    for (let t = o + 1; t < a.length; t += 1) {
                        (e ? s[t] + n[t] - s[o] < r : s[t] - s[o] < r) && (l += 1)
                    } else
                        for (let t = o - 1; t >= 0; t -= 1) {
                            s[o] - s[t] < r && (l += 1)
                        }
                return l
            }
            update() {
                const t = this;
                if (!t || t.destroyed) return;
                const {
                    snapGrid: e,
                    params: i
                } = t;

                function a() {
                    const e = t.rtlTranslate ? -1 * t.translate : t.translate,
                        i = Math.min(Math.max(e, t.maxTranslate()), t.minTranslate());
                    t.setTranslate(i), t.updateActiveIndex(), t.updateSlidesClasses()
                }
                let s;
                i.breakpoints && t.setBreakpoint(), t.updateSize(), t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.params.freeMode && t.params.freeMode.enabled ? (a(), t.params.autoHeight && t.updateAutoHeight()) : (s = ("auto" === t.params.slidesPerView || t.params.slidesPerView > 1) && t.isEnd && !t.params.centeredSlides ? t.slideTo(t.slides.length - 1, 0, !1, !0) : t.slideTo(t.activeIndex, 0, !1, !0), s || a()), i.watchOverflow && e !== t.snapGrid && t.checkOverflow(), t.emit("update")
            }
            changeDirection(t, e = !0) {
                const i = this,
                    a = i.params.direction;
                return t || (t = "horizontal" === a ? "vertical" : "horizontal"), t === a || "horizontal" !== t && "vertical" !== t || (i.$el.removeClass(`${i.params.containerModifierClass}${a}`).addClass(`${i.params.containerModifierClass}${t}`), i.emitContainerClasses(), i.params.direction = t, i.slides.each((e => {
                    "vertical" === t ? e.style.width = "" : e.style.height = ""
                })), i.emit("changeDirection"), e && i.update()), i
            }
            changeLanguageDirection(t) {
                const e = this;
                e.rtl && "rtl" === t || !e.rtl && "ltr" === t || (e.rtl = "rtl" === t, e.rtlTranslate = "horizontal" === e.params.direction && e.rtl, e.rtl ? (e.$el.addClass(`${e.params.containerModifierClass}rtl`), e.el.dir = "rtl") : (e.$el.removeClass(`${e.params.containerModifierClass}rtl`), e.el.dir = "ltr"), e.update())
            }
            mount(t) {
                const e = this;
                if (e.mounted) return !0;
                const i = f(t || e.params.el);
                if (!(t = i[0])) return !1;
                t.swiper = e;
                const a = () => `.${(e.params.wrapperClass||"").trim().split(" ").join(".")}`;
                let s = (() => {
                    if (t && t.shadowRoot && t.shadowRoot.querySelector) {
                        const e = f(t.shadowRoot.querySelector(a()));
                        return e.children = t => i.children(t), e
                    }
                    return i.children ? i.children(a()) : f(i).children(a())
                })();
                if (0 === s.length && e.params.createElements) {
                    const t = n().createElement("div");
                    s = f(t), t.className = e.params.wrapperClass, i.append(t), i.children(`.${e.params.slideClass}`).each((t => {
                        s.append(t)
                    }))
                }
                return Object.assign(e, {
                    $el: i,
                    el: t,
                    $wrapperEl: s,
                    wrapperEl: s[0],
                    mounted: !0,
                    rtl: "rtl" === t.dir.toLowerCase() || "rtl" === i.css("direction"),
                    rtlTranslate: "horizontal" === e.params.direction && ("rtl" === t.dir.toLowerCase() || "rtl" === i.css("direction")),
                    wrongRTL: "-webkit-box" === s.css("display")
                }), !0
            }
            init(t) {
                const e = this;
                if (e.initialized) return e;
                return !1 === e.mount(t) || (e.emit("beforeInit"), e.params.breakpoints && e.setBreakpoint(), e.addClasses(), e.params.loop && e.loopCreate(), e.updateSize(), e.updateSlides(), e.params.watchOverflow && e.checkOverflow(), e.params.grabCursor && e.enabled && e.setGrabCursor(), e.params.preloadImages && e.preloadImages(), e.params.loop ? e.slideTo(e.params.initialSlide + e.loopedSlides, 0, e.params.runCallbacksOnInit, !1, !0) : e.slideTo(e.params.initialSlide, 0, e.params.runCallbacksOnInit, !1, !0), e.attachEvents(), e.initialized = !0, e.emit("init"), e.emit("afterInit")), e
            }
            destroy(t = !0, e = !0) {
                const i = this,
                    {
                        params: a,
                        $el: s,
                        $wrapperEl: n,
                        slides: r
                    } = i;
                return void 0 === i.params || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), a.loop && i.loopDestroy(), e && (i.removeClasses(), s.removeAttr("style"), n.removeAttr("style"), r && r.length && r.removeClass([a.slideVisibleClass, a.slideActiveClass, a.slideNextClass, a.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-slide-index")), i.emit("destroy"), Object.keys(i.eventsListeners).forEach((t => {
                    i.off(t)
                })), !1 !== t && (i.$el[0].swiper = null, function(t) {
                    const e = t;
                    Object.keys(e).forEach((t => {
                        try {
                            e[t] = null
                        } catch (t) {}
                        try {
                            delete e[t]
                        } catch (t) {}
                    }))
                }(i)), i.destroyed = !0), null
            }
            static extendDefaults(t) {
                y(Q, t)
            }
            static get extendedDefaults() {
                return Q
            }
            static get defaults() {
                return q
            }
            static installModule(t) {
                J.prototype.__modules__ || (J.prototype.__modules__ = []);
                const e = J.prototype.__modules__;
                "function" == typeof t && e.indexOf(t) < 0 && e.push(t)
            }
            static use(t) {
                return Array.isArray(t) ? (t.forEach((t => J.installModule(t))), J) : (J.installModule(t), J)
            }
        }
        Object.keys(K).forEach((t => {
            Object.keys(K[t]).forEach((e => {
                J.prototype[e] = K[t][e]
            }))
        })), J.use([function({
            swiper: t,
            on: e,
            emit: i
        }) {
            const a = o();
            let s = null,
                n = null;
            const r = () => {
                    t && !t.destroyed && t.initialized && (i("beforeResize"), i("resize"))
                },
                l = () => {
                    t && !t.destroyed && t.initialized && i("orientationchange")
                };
            e("init", (() => {
                t.params.resizeObserver && void 0 !== a.ResizeObserver ? t && !t.destroyed && t.initialized && (s = new ResizeObserver((e => {
                    n = a.requestAnimationFrame((() => {
                        const {
                            width: i,
                            height: a
                        } = t;
                        let s = i,
                            n = a;
                        e.forEach((({
                            contentBoxSize: e,
                            contentRect: i,
                            target: a
                        }) => {
                            a && a !== t.el || (s = i ? i.width : (e[0] || e).inlineSize, n = i ? i.height : (e[0] || e).blockSize)
                        })), s === i && n === a || r()
                    }))
                })), s.observe(t.el)) : (a.addEventListener("resize", r), a.addEventListener("orientationchange", l))
            })), e("destroy", (() => {
                n && a.cancelAnimationFrame(n), s && s.unobserve && t.el && (s.unobserve(t.el), s = null), a.removeEventListener("resize", r), a.removeEventListener("orientationchange", l)
            }))
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            const s = [],
                n = o(),
                r = (t, e = {}) => {
                    const i = new(n.MutationObserver || n.WebkitMutationObserver)((t => {
                        if (1 === t.length) return void a("observerUpdate", t[0]);
                        const e = function() {
                            a("observerUpdate", t[0])
                        };
                        n.requestAnimationFrame ? n.requestAnimationFrame(e) : n.setTimeout(e, 0)
                    }));
                    i.observe(t, {
                        attributes: void 0 === e.attributes || e.attributes,
                        childList: void 0 === e.childList || e.childList,
                        characterData: void 0 === e.characterData || e.characterData
                    }), s.push(i)
                };
            e({
                observer: !1,
                observeParents: !1,
                observeSlideChildren: !1
            }), i("init", (() => {
                if (t.params.observer) {
                    if (t.params.observeParents) {
                        const e = t.$el.parents();
                        for (let t = 0; t < e.length; t += 1) r(e[t])
                    }
                    r(t.$el[0], {
                        childList: t.params.observeSlideChildren
                    }), r(t.$wrapperEl[0], {
                        attributes: !1
                    })
                }
            })), i("destroy", (() => {
                s.forEach((t => {
                    t.disconnect()
                })), s.splice(0, s.length)
            }))
        }]);
        const tt = J;

        function et(t, e, i, a) {
            const s = n();
            return t.params.createElements && Object.keys(a).forEach((n => {
                if (!i[n] && !0 === i.auto) {
                    let r = t.$el.children(`.${a[n]}`)[0];
                    r || (r = s.createElement("div"), r.className = a[n], t.$el.append(r)), i[n] = r, e[n] = r
                }
            })), i
        }

        function it(t = "") {
            return `.${t.trim().replace(/([\.:!\/])/g,"\\$1").replace(/ /g,".")}`
        }

        function at(t) {
            const e = this,
                {
                    $wrapperEl: i,
                    params: a
                } = e;
            if (a.loop && e.loopDestroy(), "object" == typeof t && "length" in t)
                for (let e = 0; e < t.length; e += 1) t[e] && i.append(t[e]);
            else i.append(t);
            a.loop && e.loopCreate(), a.observer || e.update()
        }

        function st(t) {
            const e = this,
                {
                    params: i,
                    $wrapperEl: a,
                    activeIndex: s
                } = e;
            i.loop && e.loopDestroy();
            let n = s + 1;
            if ("object" == typeof t && "length" in t) {
                for (let e = 0; e < t.length; e += 1) t[e] && a.prepend(t[e]);
                n = s + t.length
            } else a.prepend(t);
            i.loop && e.loopCreate(), i.observer || e.update(), e.slideTo(n, 0, !1)
        }

        function nt(t, e) {
            const i = this,
                {
                    $wrapperEl: a,
                    params: s,
                    activeIndex: n
                } = i;
            let r = n;
            s.loop && (r -= i.loopedSlides, i.loopDestroy(), i.slides = a.children(`.${s.slideClass}`));
            const o = i.slides.length;
            if (t <= 0) return void i.prependSlide(e);
            if (t >= o) return void i.appendSlide(e);
            let l = r > t ? r + 1 : r;
            const c = [];
            for (let e = o - 1; e >= t; e -= 1) {
                const t = i.slides.eq(e);
                t.remove(), c.unshift(t)
            }
            if ("object" == typeof e && "length" in e) {
                for (let t = 0; t < e.length; t += 1) e[t] && a.append(e[t]);
                l = r > t ? r + e.length : r
            } else a.append(e);
            for (let t = 0; t < c.length; t += 1) a.append(c[t]);
            s.loop && i.loopCreate(), s.observer || i.update(), s.loop ? i.slideTo(l + i.loopedSlides, 0, !1) : i.slideTo(l, 0, !1)
        }

        function rt(t) {
            const e = this,
                {
                    params: i,
                    $wrapperEl: a,
                    activeIndex: s
                } = e;
            let n = s;
            i.loop && (n -= e.loopedSlides, e.loopDestroy(), e.slides = a.children(`.${i.slideClass}`));
            let r, o = n;
            if ("object" == typeof t && "length" in t) {
                for (let i = 0; i < t.length; i += 1) r = t[i], e.slides[r] && e.slides.eq(r).remove(), r < o && (o -= 1);
                o = Math.max(o, 0)
            } else r = t, e.slides[r] && e.slides.eq(r).remove(), r < o && (o -= 1), o = Math.max(o, 0);
            i.loop && e.loopCreate(), i.observer || e.update(), i.loop ? e.slideTo(o + e.loopedSlides, 0, !1) : e.slideTo(o, 0, !1)
        }

        function ot() {
            const t = this,
                e = [];
            for (let i = 0; i < t.slides.length; i += 1) e.push(i);
            t.removeSlide(e)
        }

        function lt(t) {
            const {
                effect: e,
                swiper: i,
                on: a,
                setTranslate: s,
                setTransition: n,
                overwriteParams: r,
                perspective: o,
                recreateShadows: l,
                getEffectParams: c
            } = t;
            let h;
            a("beforeInit", (() => {
                if (i.params.effect !== e) return;
                i.classNames.push(`${i.params.containerModifierClass}${e}`), o && o() && i.classNames.push(`${i.params.containerModifierClass}3d`);
                const t = r ? r() : {};
                Object.assign(i.params, t), Object.assign(i.originalParams, t)
            })), a("setTranslate", (() => {
                i.params.effect === e && s()
            })), a("setTransition", ((t, a) => {
                i.params.effect === e && n(a)
            })), a("transitionEnd", (() => {
                if (i.params.effect === e && l) {
                    if (!c || !c().slideShadows) return;
                    i.slides.each((t => {
                        i.$(t).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").remove()
                    })), l()
                }
            })), a("virtualUpdate", (() => {
                i.params.effect === e && (i.slides.length || (h = !0), requestAnimationFrame((() => {
                    h && i.slides && i.slides.length && (s(), h = !1)
                })))
            }))
        }

        function ct(t, e) {
            return t.transformEl ? e.find(t.transformEl).css({
                "backface-visibility": "hidden",
                "-webkit-backface-visibility": "hidden"
            }) : e
        }

        function ht({
            swiper: t,
            duration: e,
            transformEl: i,
            allSlides: a
        }) {
            const {
                slides: s,
                activeIndex: n,
                $wrapperEl: r
            } = t;
            if (t.params.virtualTranslate && 0 !== e) {
                let e, o = !1;
                e = a ? i ? s.find(i) : s : i ? s.eq(n).find(i) : s.eq(n), e.transitionEnd((() => {
                    if (o) return;
                    if (!t || t.destroyed) return;
                    o = !0, t.animating = !1;
                    const e = ["webkitTransitionEnd", "transitionend"];
                    for (let t = 0; t < e.length; t += 1) r.trigger(e[t])
                }))
            }
        }

        function dt(t, e, i) {
            const a = "swiper-slide-shadow" + (i ? `-${i}` : ""),
                s = t.transformEl ? e.find(t.transformEl) : e;
            let n = s.children(`.${a}`);
            return n.length || (n = f(`<div class="swiper-slide-shadow${i?`-${i}`:""}"></div>`), s.append(n)), n
        }
        const ut = [function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            let s;

            function n(e, i) {
                const a = t.params.virtual;
                if (a.cache && t.virtual.cache[i]) return t.virtual.cache[i];
                const s = a.renderSlide ? f(a.renderSlide.call(t, e, i)) : f(`<div class="${t.params.slideClass}" data-swiper-slide-index="${i}">${e}</div>`);
                return s.attr("data-swiper-slide-index") || s.attr("data-swiper-slide-index", i), a.cache && (t.virtual.cache[i] = s), s
            }

            function r(e) {
                const {
                    slidesPerView: i,
                    slidesPerGroup: s,
                    centeredSlides: r
                } = t.params, {
                    addSlidesBefore: o,
                    addSlidesAfter: l
                } = t.params.virtual, {
                    from: c,
                    to: h,
                    slides: d,
                    slidesGrid: u,
                    offset: p
                } = t.virtual;
                t.params.cssMode || t.updateActiveIndex();
                const g = t.activeIndex || 0;
                let f, m, x;
                f = t.rtlTranslate ? "right" : t.isHorizontal() ? "left" : "top", r ? (m = Math.floor(i / 2) + s + l, x = Math.floor(i / 2) + s + o) : (m = i + (s - 1) + l, x = s + o);
                const v = Math.max((g || 0) - x, 0),
                    b = Math.min((g || 0) + m, d.length - 1),
                    y = (t.slidesGrid[v] || 0) - (t.slidesGrid[0] || 0);

                function w() {
                    t.updateSlides(), t.updateProgress(), t.updateSlidesClasses(), t.lazy && t.params.lazy.enabled && t.lazy.load(), a("virtualUpdate")
                }
                if (Object.assign(t.virtual, {
                        from: v,
                        to: b,
                        offset: y,
                        slidesGrid: t.slidesGrid
                    }), c === v && h === b && !e) return t.slidesGrid !== u && y !== p && t.slides.css(f, `${y}px`), t.updateProgress(), void a("virtualUpdate");
                if (t.params.virtual.renderExternal) return t.params.virtual.renderExternal.call(t, {
                    offset: y,
                    from: v,
                    to: b,
                    slides: function() {
                        const t = [];
                        for (let e = v; e <= b; e += 1) t.push(d[e]);
                        return t
                    }()
                }), void(t.params.virtual.renderExternalUpdate ? w() : a("virtualUpdate"));
                const S = [],
                    C = [];
                if (e) t.$wrapperEl.find(`.${t.params.slideClass}`).remove();
                else
                    for (let e = c; e <= h; e += 1)(e < v || e > b) && t.$wrapperEl.find(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`).remove();
                for (let t = 0; t < d.length; t += 1) t >= v && t <= b && (void 0 === h || e ? C.push(t) : (t > h && C.push(t), t < c && S.push(t)));
                C.forEach((e => {
                    t.$wrapperEl.append(n(d[e], e))
                })), S.sort(((t, e) => e - t)).forEach((e => {
                    t.$wrapperEl.prepend(n(d[e], e))
                })), t.$wrapperEl.children(".swiper-slide").css(f, `${y}px`), w()
            }
            e({
                virtual: {
                    enabled: !1,
                    slides: [],
                    cache: !0,
                    renderSlide: null,
                    renderExternal: null,
                    renderExternalUpdate: !0,
                    addSlidesBefore: 0,
                    addSlidesAfter: 0
                }
            }), t.virtual = {
                cache: {},
                from: void 0,
                to: void 0,
                slides: [],
                offset: 0,
                slidesGrid: []
            }, i("beforeInit", (() => {
                t.params.virtual.enabled && (t.virtual.slides = t.params.virtual.slides, t.classNames.push(`${t.params.containerModifierClass}virtual`), t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0, t.params.initialSlide || r())
            })), i("setTranslate", (() => {
                t.params.virtual.enabled && (t.params.cssMode && !t._immediateVirtual ? (clearTimeout(s), s = setTimeout((() => {
                    r()
                }), 100)) : r())
            })), i("init update resize", (() => {
                t.params.virtual.enabled && t.params.cssMode && w(t.wrapperEl, "--swiper-virtual-size", `${t.virtualSize}px`)
            })), Object.assign(t.virtual, {
                appendSlide: function(e) {
                    if ("object" == typeof e && "length" in e)
                        for (let i = 0; i < e.length; i += 1) e[i] && t.virtual.slides.push(e[i]);
                    else t.virtual.slides.push(e);
                    r(!0)
                },
                prependSlide: function(e) {
                    const i = t.activeIndex;
                    let a = i + 1,
                        s = 1;
                    if (Array.isArray(e)) {
                        for (let i = 0; i < e.length; i += 1) e[i] && t.virtual.slides.unshift(e[i]);
                        a = i + e.length, s = e.length
                    } else t.virtual.slides.unshift(e);
                    if (t.params.virtual.cache) {
                        const e = t.virtual.cache,
                            i = {};
                        Object.keys(e).forEach((t => {
                            const a = e[t],
                                n = a.attr("data-swiper-slide-index");
                            n && a.attr("data-swiper-slide-index", parseInt(n, 10) + s), i[parseInt(t, 10) + s] = a
                        })), t.virtual.cache = i
                    }
                    r(!0), t.slideTo(a, 0)
                },
                removeSlide: function(e) {
                    if (null == e) return;
                    let i = t.activeIndex;
                    if (Array.isArray(e))
                        for (let a = e.length - 1; a >= 0; a -= 1) t.virtual.slides.splice(e[a], 1), t.params.virtual.cache && delete t.virtual.cache[e[a]], e[a] < i && (i -= 1), i = Math.max(i, 0);
                    else t.virtual.slides.splice(e, 1), t.params.virtual.cache && delete t.virtual.cache[e], e < i && (i -= 1), i = Math.max(i, 0);
                    r(!0), t.slideTo(i, 0)
                },
                removeAllSlides: function() {
                    t.virtual.slides = [], t.params.virtual.cache && (t.virtual.cache = {}), r(!0), t.slideTo(0, 0)
                },
                update: r
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            const s = n(),
                r = o();

            function l(e) {
                if (!t.enabled) return;
                const {
                    rtlTranslate: i
                } = t;
                let n = e;
                n.originalEvent && (n = n.originalEvent);
                const o = n.keyCode || n.charCode,
                    l = t.params.keyboard.pageUpDown,
                    c = l && 33 === o,
                    h = l && 34 === o,
                    d = 37 === o,
                    u = 39 === o,
                    p = 38 === o,
                    g = 40 === o;
                if (!t.allowSlideNext && (t.isHorizontal() && u || t.isVertical() && g || h)) return !1;
                if (!t.allowSlidePrev && (t.isHorizontal() && d || t.isVertical() && p || c)) return !1;
                if (!(n.shiftKey || n.altKey || n.ctrlKey || n.metaKey || s.activeElement && s.activeElement.nodeName && ("input" === s.activeElement.nodeName.toLowerCase() || "textarea" === s.activeElement.nodeName.toLowerCase()))) {
                    if (t.params.keyboard.onlyInViewport && (c || h || d || u || p || g)) {
                        let e = !1;
                        if (t.$el.parents(`.${t.params.slideClass}`).length > 0 && 0 === t.$el.parents(`.${t.params.slideActiveClass}`).length) return;
                        const a = t.$el,
                            s = a[0].clientWidth,
                            n = a[0].clientHeight,
                            o = r.innerWidth,
                            l = r.innerHeight,
                            c = t.$el.offset();
                        i && (c.left -= t.$el[0].scrollLeft);
                        const h = [
                            [c.left, c.top],
                            [c.left + s, c.top],
                            [c.left, c.top + n],
                            [c.left + s, c.top + n]
                        ];
                        for (let t = 0; t < h.length; t += 1) {
                            const i = h[t];
                            if (i[0] >= 0 && i[0] <= o && i[1] >= 0 && i[1] <= l) {
                                if (0 === i[0] && 0 === i[1]) continue;
                                e = !0
                            }
                        }
                        if (!e) return
                    }
                    t.isHorizontal() ? ((c || h || d || u) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), ((h || u) && !i || (c || d) && i) && t.slideNext(), ((c || d) && !i || (h || u) && i) && t.slidePrev()) : ((c || h || p || g) && (n.preventDefault ? n.preventDefault() : n.returnValue = !1), (h || g) && t.slideNext(), (c || p) && t.slidePrev()), a("keyPress", o)
                }
            }

            function c() {
                t.keyboard.enabled || (f(s).on("keydown", l), t.keyboard.enabled = !0)
            }

            function h() {
                t.keyboard.enabled && (f(s).off("keydown", l), t.keyboard.enabled = !1)
            }
            t.keyboard = {
                enabled: !1
            }, e({
                keyboard: {
                    enabled: !1,
                    onlyInViewport: !0,
                    pageUpDown: !0
                }
            }), i("init", (() => {
                t.params.keyboard.enabled && c()
            })), i("destroy", (() => {
                t.keyboard.enabled && h()
            })), Object.assign(t.keyboard, {
                enable: c,
                disable: h
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            const s = o();
            let n;
            e({
                mousewheel: {
                    enabled: !1,
                    releaseOnEdges: !1,
                    invert: !1,
                    forceToAxis: !1,
                    sensitivity: 1,
                    eventsTarget: "container",
                    thresholdDelta: null,
                    thresholdTime: null
                }
            }), t.mousewheel = {
                enabled: !1
            };
            let r, l = x();
            const c = [];

            function h() {
                t.enabled && (t.mouseEntered = !0)
            }

            function d() {
                t.enabled && (t.mouseEntered = !1)
            }

            function u(e) {
                return !(t.params.mousewheel.thresholdDelta && e.delta < t.params.mousewheel.thresholdDelta) && (!(t.params.mousewheel.thresholdTime && x() - l < t.params.mousewheel.thresholdTime) && (e.delta >= 6 && x() - l < 60 || (e.direction < 0 ? t.isEnd && !t.params.loop || t.animating || (t.slideNext(), a("scroll", e.raw)) : t.isBeginning && !t.params.loop || t.animating || (t.slidePrev(), a("scroll", e.raw)), l = (new s.Date).getTime(), !1)))
            }

            function p(e) {
                let i = e,
                    s = !0;
                if (!t.enabled) return;
                const o = t.params.mousewheel;
                t.params.cssMode && i.preventDefault();
                let l = t.$el;
                if ("container" !== t.params.mousewheel.eventsTarget && (l = f(t.params.mousewheel.eventsTarget)), !t.mouseEntered && !l[0].contains(i.target) && !o.releaseOnEdges) return !0;
                i.originalEvent && (i = i.originalEvent);
                let h = 0;
                const d = t.rtlTranslate ? -1 : 1,
                    p = function(t) {
                        let e = 0,
                            i = 0,
                            a = 0,
                            s = 0;
                        return "detail" in t && (i = t.detail), "wheelDelta" in t && (i = -t.wheelDelta / 120), "wheelDeltaY" in t && (i = -t.wheelDeltaY / 120), "wheelDeltaX" in t && (e = -t.wheelDeltaX / 120), "axis" in t && t.axis === t.HORIZONTAL_AXIS && (e = i, i = 0), a = 10 * e, s = 10 * i, "deltaY" in t && (s = t.deltaY), "deltaX" in t && (a = t.deltaX), t.shiftKey && !a && (a = s, s = 0), (a || s) && t.deltaMode && (1 === t.deltaMode ? (a *= 40, s *= 40) : (a *= 800, s *= 800)), a && !e && (e = a < 1 ? -1 : 1), s && !i && (i = s < 1 ? -1 : 1), {
                            spinX: e,
                            spinY: i,
                            pixelX: a,
                            pixelY: s
                        }
                    }(i);
                if (o.forceToAxis)
                    if (t.isHorizontal()) {
                        if (!(Math.abs(p.pixelX) > Math.abs(p.pixelY))) return !0;
                        h = -p.pixelX * d
                    } else {
                        if (!(Math.abs(p.pixelY) > Math.abs(p.pixelX))) return !0;
                        h = -p.pixelY
                    }
                else h = Math.abs(p.pixelX) > Math.abs(p.pixelY) ? -p.pixelX * d : -p.pixelY;
                if (0 === h) return !0;
                o.invert && (h = -h);
                let g = t.getTranslate() + h * o.sensitivity;
                if (g >= t.minTranslate() && (g = t.minTranslate()), g <= t.maxTranslate() && (g = t.maxTranslate()), s = !!t.params.loop || !(g === t.minTranslate() || g === t.maxTranslate()), s && t.params.nested && i.stopPropagation(), t.params.freeMode && t.params.freeMode.enabled) {
                    const e = {
                            time: x(),
                            delta: Math.abs(h),
                            direction: Math.sign(h)
                        },
                        s = r && e.time < r.time + 500 && e.delta <= r.delta && e.direction === r.direction;
                    if (!s) {
                        r = void 0, t.params.loop && t.loopFix();
                        let l = t.getTranslate() + h * o.sensitivity;
                        const d = t.isBeginning,
                            u = t.isEnd;
                        if (l >= t.minTranslate() && (l = t.minTranslate()), l <= t.maxTranslate() && (l = t.maxTranslate()), t.setTransition(0), t.setTranslate(l), t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses(), (!d && t.isBeginning || !u && t.isEnd) && t.updateSlidesClasses(), t.params.freeMode.sticky) {
                            clearTimeout(n), n = void 0, c.length >= 15 && c.shift();
                            const i = c.length ? c[c.length - 1] : void 0,
                                a = c[0];
                            if (c.push(e), i && (e.delta > i.delta || e.direction !== i.direction)) c.splice(0);
                            else if (c.length >= 15 && e.time - a.time < 500 && a.delta - e.delta >= 1 && e.delta <= 6) {
                                const i = h > 0 ? .8 : .2;
                                r = e, c.splice(0), n = m((() => {
                                    t.slideToClosest(t.params.speed, !0, void 0, i)
                                }), 0)
                            }
                            n || (n = m((() => {
                                r = e, c.splice(0), t.slideToClosest(t.params.speed, !0, void 0, .5)
                            }), 500))
                        }
                        if (s || a("scroll", i), t.params.autoplay && t.params.autoplayDisableOnInteraction && t.autoplay.stop(), l === t.minTranslate() || l === t.maxTranslate()) return !0
                    }
                } else {
                    const i = {
                        time: x(),
                        delta: Math.abs(h),
                        direction: Math.sign(h),
                        raw: e
                    };
                    c.length >= 2 && c.shift();
                    const a = c.length ? c[c.length - 1] : void 0;
                    if (c.push(i), a ? (i.direction !== a.direction || i.delta > a.delta || i.time > a.time + 150) && u(i) : u(i), function(e) {
                            const i = t.params.mousewheel;
                            if (e.direction < 0) {
                                if (t.isEnd && !t.params.loop && i.releaseOnEdges) return !0
                            } else if (t.isBeginning && !t.params.loop && i.releaseOnEdges) return !0;
                            return !1
                        }(i)) return !0
                }
                return i.preventDefault ? i.preventDefault() : i.returnValue = !1, !1
            }

            function g(e) {
                let i = t.$el;
                "container" !== t.params.mousewheel.eventsTarget && (i = f(t.params.mousewheel.eventsTarget)), i[e]("mouseenter", h), i[e]("mouseleave", d), i[e]("wheel", p)
            }

            function v() {
                return t.params.cssMode ? (t.wrapperEl.removeEventListener("wheel", p), !0) : !t.mousewheel.enabled && (g("on"), t.mousewheel.enabled = !0, !0)
            }

            function b() {
                return t.params.cssMode ? (t.wrapperEl.addEventListener(event, p), !0) : !!t.mousewheel.enabled && (g("off"), t.mousewheel.enabled = !1, !0)
            }
            i("init", (() => {
                !t.params.mousewheel.enabled && t.params.cssMode && b(), t.params.mousewheel.enabled && v()
            })), i("destroy", (() => {
                t.params.cssMode && v(), t.mousewheel.enabled && b()
            })), Object.assign(t.mousewheel, {
                enable: v,
                disable: b
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            function s(e) {
                let i;
                return e && (i = f(e), t.params.uniqueNavElements && "string" == typeof e && i.length > 1 && 1 === t.$el.find(e).length && (i = t.$el.find(e))), i
            }

            function n(e, i) {
                const a = t.params.navigation;
                e && e.length > 0 && (e[i ? "addClass" : "removeClass"](a.disabledClass), e[0] && "BUTTON" === e[0].tagName && (e[0].disabled = i), t.params.watchOverflow && t.enabled && e[t.isLocked ? "addClass" : "removeClass"](a.lockClass))
            }

            function r() {
                if (t.params.loop) return;
                const {
                    $nextEl: e,
                    $prevEl: i
                } = t.navigation;
                n(i, t.isBeginning && !t.params.rewind), n(e, t.isEnd && !t.params.rewind)
            }

            function o(e) {
                e.preventDefault(), (!t.isBeginning || t.params.loop || t.params.rewind) && (t.slidePrev(), a("navigationPrev"))
            }

            function l(e) {
                e.preventDefault(), (!t.isEnd || t.params.loop || t.params.rewind) && (t.slideNext(), a("navigationNext"))
            }

            function c() {
                const e = t.params.navigation;
                if (t.params.navigation = et(t, t.originalParams.navigation, t.params.navigation, {
                        nextEl: "swiper-button-next",
                        prevEl: "swiper-button-prev"
                    }), !e.nextEl && !e.prevEl) return;
                const i = s(e.nextEl),
                    a = s(e.prevEl);
                i && i.length > 0 && i.on("click", l), a && a.length > 0 && a.on("click", o), Object.assign(t.navigation, {
                    $nextEl: i,
                    nextEl: i && i[0],
                    $prevEl: a,
                    prevEl: a && a[0]
                }), t.enabled || (i && i.addClass(e.lockClass), a && a.addClass(e.lockClass))
            }

            function h() {
                const {
                    $nextEl: e,
                    $prevEl: i
                } = t.navigation;
                e && e.length && (e.off("click", l), e.removeClass(t.params.navigation.disabledClass)), i && i.length && (i.off("click", o), i.removeClass(t.params.navigation.disabledClass))
            }
            e({
                navigation: {
                    nextEl: null,
                    prevEl: null,
                    hideOnClick: !1,
                    disabledClass: "swiper-button-disabled",
                    hiddenClass: "swiper-button-hidden",
                    lockClass: "swiper-button-lock",
                    navigationDisabledClass: "swiper-navigation-disabled"
                }
            }), t.navigation = {
                nextEl: null,
                $nextEl: null,
                prevEl: null,
                $prevEl: null
            }, i("init", (() => {
                !1 === t.params.navigation.enabled ? d() : (c(), r())
            })), i("toEdge fromEdge lock unlock", (() => {
                r()
            })), i("destroy", (() => {
                h()
            })), i("enable disable", (() => {
                const {
                    $nextEl: e,
                    $prevEl: i
                } = t.navigation;
                e && e[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass), i && i[t.enabled ? "removeClass" : "addClass"](t.params.navigation.lockClass)
            })), i("click", ((e, i) => {
                const {
                    $nextEl: s,
                    $prevEl: n
                } = t.navigation, r = i.target;
                if (t.params.navigation.hideOnClick && !f(r).is(n) && !f(r).is(s)) {
                    if (t.pagination && t.params.pagination && t.params.pagination.clickable && (t.pagination.el === r || t.pagination.el.contains(r))) return;
                    let e;
                    s ? e = s.hasClass(t.params.navigation.hiddenClass) : n && (e = n.hasClass(t.params.navigation.hiddenClass)), a(!0 === e ? "navigationShow" : "navigationHide"), s && s.toggleClass(t.params.navigation.hiddenClass), n && n.toggleClass(t.params.navigation.hiddenClass)
                }
            }));
            const d = () => {
                t.$el.addClass(t.params.navigation.navigationDisabledClass), h()
            };
            Object.assign(t.navigation, {
                enable: () => {
                    t.$el.removeClass(t.params.navigation.navigationDisabledClass), c(), r()
                },
                disable: d,
                update: r,
                init: c,
                destroy: h
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            const s = "swiper-pagination";
            let n;
            e({
                pagination: {
                    el: null,
                    bulletElement: "span",
                    clickable: !1,
                    hideOnClick: !1,
                    renderBullet: null,
                    renderProgressbar: null,
                    renderFraction: null,
                    renderCustom: null,
                    progressbarOpposite: !1,
                    type: "bullets",
                    dynamicBullets: !1,
                    dynamicMainBullets: 1,
                    formatFractionCurrent: t => t,
                    formatFractionTotal: t => t,
                    bulletClass: `${s}-bullet`,
                    bulletActiveClass: `${s}-bullet-active`,
                    modifierClass: `${s}-`,
                    currentClass: `${s}-current`,
                    totalClass: `${s}-total`,
                    hiddenClass: `${s}-hidden`,
                    progressbarFillClass: `${s}-progressbar-fill`,
                    progressbarOppositeClass: `${s}-progressbar-opposite`,
                    clickableClass: `${s}-clickable`,
                    lockClass: `${s}-lock`,
                    horizontalClass: `${s}-horizontal`,
                    verticalClass: `${s}-vertical`,
                    paginationDisabledClass: `${s}-disabled`
                }
            }), t.pagination = {
                el: null,
                $el: null,
                bullets: []
            };
            let r = 0;

            function o() {
                return !t.params.pagination.el || !t.pagination.el || !t.pagination.$el || 0 === t.pagination.$el.length
            }

            function l(e, i) {
                const {
                    bulletActiveClass: a
                } = t.params.pagination;
                e[i]().addClass(`${a}-${i}`)[i]().addClass(`${a}-${i}-${i}`)
            }

            function c() {
                const e = t.rtl,
                    i = t.params.pagination;
                if (o()) return;
                const s = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                    c = t.pagination.$el;
                let h;
                const d = t.params.loop ? Math.ceil((s - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
                if (t.params.loop ? (h = Math.ceil((t.activeIndex - t.loopedSlides) / t.params.slidesPerGroup), h > s - 1 - 2 * t.loopedSlides && (h -= s - 2 * t.loopedSlides), h > d - 1 && (h -= d), h < 0 && "bullets" !== t.params.paginationType && (h = d + h)) : h = void 0 !== t.snapIndex ? t.snapIndex : t.activeIndex || 0, "bullets" === i.type && t.pagination.bullets && t.pagination.bullets.length > 0) {
                    const a = t.pagination.bullets;
                    let s, o, d;
                    if (i.dynamicBullets && (n = a.eq(0)[t.isHorizontal() ? "outerWidth" : "outerHeight"](!0), c.css(t.isHorizontal() ? "width" : "height", n * (i.dynamicMainBullets + 4) + "px"), i.dynamicMainBullets > 1 && void 0 !== t.previousIndex && (r += h - (t.previousIndex - t.loopedSlides || 0), r > i.dynamicMainBullets - 1 ? r = i.dynamicMainBullets - 1 : r < 0 && (r = 0)), s = Math.max(h - r, 0), o = s + (Math.min(a.length, i.dynamicMainBullets) - 1), d = (o + s) / 2), a.removeClass(["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map((t => `${i.bulletActiveClass}${t}`)).join(" ")), c.length > 1) a.each((t => {
                        const e = f(t),
                            a = e.index();
                        a === h && e.addClass(i.bulletActiveClass), i.dynamicBullets && (a >= s && a <= o && e.addClass(`${i.bulletActiveClass}-main`), a === s && l(e, "prev"), a === o && l(e, "next"))
                    }));
                    else {
                        const e = a.eq(h),
                            n = e.index();
                        if (e.addClass(i.bulletActiveClass), i.dynamicBullets) {
                            const e = a.eq(s),
                                r = a.eq(o);
                            for (let t = s; t <= o; t += 1) a.eq(t).addClass(`${i.bulletActiveClass}-main`);
                            if (t.params.loop)
                                if (n >= a.length) {
                                    for (let t = i.dynamicMainBullets; t >= 0; t -= 1) a.eq(a.length - t).addClass(`${i.bulletActiveClass}-main`);
                                    a.eq(a.length - i.dynamicMainBullets - 1).addClass(`${i.bulletActiveClass}-prev`)
                                } else l(e, "prev"), l(r, "next");
                            else l(e, "prev"), l(r, "next")
                        }
                    }
                    if (i.dynamicBullets) {
                        const s = Math.min(a.length, i.dynamicMainBullets + 4),
                            r = (n * s - n) / 2 - d * n,
                            o = e ? "right" : "left";
                        a.css(t.isHorizontal() ? o : "top", `${r}px`)
                    }
                }
                if ("fraction" === i.type && (c.find(it(i.currentClass)).text(i.formatFractionCurrent(h + 1)), c.find(it(i.totalClass)).text(i.formatFractionTotal(d))), "progressbar" === i.type) {
                    let e;
                    e = i.progressbarOpposite ? t.isHorizontal() ? "vertical" : "horizontal" : t.isHorizontal() ? "horizontal" : "vertical";
                    const a = (h + 1) / d;
                    let s = 1,
                        n = 1;
                    "horizontal" === e ? s = a : n = a, c.find(it(i.progressbarFillClass)).transform(`translate3d(0,0,0) scaleX(${s}) scaleY(${n})`).transition(t.params.speed)
                }
                "custom" === i.type && i.renderCustom ? (c.html(i.renderCustom(t, h + 1, d)), a("paginationRender", c[0])) : a("paginationUpdate", c[0]), t.params.watchOverflow && t.enabled && c[t.isLocked ? "addClass" : "removeClass"](i.lockClass)
            }

            function h() {
                const e = t.params.pagination;
                if (o()) return;
                const i = t.virtual && t.params.virtual.enabled ? t.virtual.slides.length : t.slides.length,
                    s = t.pagination.$el;
                let n = "";
                if ("bullets" === e.type) {
                    let a = t.params.loop ? Math.ceil((i - 2 * t.loopedSlides) / t.params.slidesPerGroup) : t.snapGrid.length;
                    t.params.freeMode && t.params.freeMode.enabled && !t.params.loop && a > i && (a = i);
                    for (let i = 0; i < a; i += 1) e.renderBullet ? n += e.renderBullet.call(t, i, e.bulletClass) : n += `<${e.bulletElement} class="${e.bulletClass}"></${e.bulletElement}>`;
                    s.html(n), t.pagination.bullets = s.find(it(e.bulletClass))
                }
                "fraction" === e.type && (n = e.renderFraction ? e.renderFraction.call(t, e.currentClass, e.totalClass) : `<span class="${e.currentClass}"></span> / <span class="${e.totalClass}"></span>`, s.html(n)), "progressbar" === e.type && (n = e.renderProgressbar ? e.renderProgressbar.call(t, e.progressbarFillClass) : `<span class="${e.progressbarFillClass}"></span>`, s.html(n)), "custom" !== e.type && a("paginationRender", t.pagination.$el[0])
            }

            function d() {
                t.params.pagination = et(t, t.originalParams.pagination, t.params.pagination, {
                    el: "swiper-pagination"
                });
                const e = t.params.pagination;
                if (!e.el) return;
                let i = f(e.el);
                0 !== i.length && (t.params.uniqueNavElements && "string" == typeof e.el && i.length > 1 && (i = t.$el.find(e.el), i.length > 1 && (i = i.filter((e => f(e).parents(".swiper")[0] === t.el)))), "bullets" === e.type && e.clickable && i.addClass(e.clickableClass), i.addClass(e.modifierClass + e.type), i.addClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), "bullets" === e.type && e.dynamicBullets && (i.addClass(`${e.modifierClass}${e.type}-dynamic`), r = 0, e.dynamicMainBullets < 1 && (e.dynamicMainBullets = 1)), "progressbar" === e.type && e.progressbarOpposite && i.addClass(e.progressbarOppositeClass), e.clickable && i.on("click", it(e.bulletClass), (function(e) {
                    e.preventDefault();
                    let i = f(this).index() * t.params.slidesPerGroup;
                    t.params.loop && (i += t.loopedSlides), t.slideTo(i)
                })), Object.assign(t.pagination, {
                    $el: i,
                    el: i[0]
                }), t.enabled || i.addClass(e.lockClass))
            }

            function u() {
                const e = t.params.pagination;
                if (o()) return;
                const i = t.pagination.$el;
                i.removeClass(e.hiddenClass), i.removeClass(e.modifierClass + e.type), i.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.pagination.bullets && t.pagination.bullets.removeClass && t.pagination.bullets.removeClass(e.bulletActiveClass), e.clickable && i.off("click", it(e.bulletClass))
            }
            i("init", (() => {
                !1 === t.params.pagination.enabled ? p() : (d(), h(), c())
            })), i("activeIndexChange", (() => {
                (t.params.loop || void 0 === t.snapIndex) && c()
            })), i("snapIndexChange", (() => {
                t.params.loop || c()
            })), i("slidesLengthChange", (() => {
                t.params.loop && (h(), c())
            })), i("snapGridLengthChange", (() => {
                t.params.loop || (h(), c())
            })), i("destroy", (() => {
                u()
            })), i("enable disable", (() => {
                const {
                    $el: e
                } = t.pagination;
                e && e[t.enabled ? "removeClass" : "addClass"](t.params.pagination.lockClass)
            })), i("lock unlock", (() => {
                c()
            })), i("click", ((e, i) => {
                const s = i.target,
                    {
                        $el: n
                    } = t.pagination;
                if (t.params.pagination.el && t.params.pagination.hideOnClick && n && n.length > 0 && !f(s).hasClass(t.params.pagination.bulletClass)) {
                    if (t.navigation && (t.navigation.nextEl && s === t.navigation.nextEl || t.navigation.prevEl && s === t.navigation.prevEl)) return;
                    const e = n.hasClass(t.params.pagination.hiddenClass);
                    a(!0 === e ? "paginationShow" : "paginationHide"), n.toggleClass(t.params.pagination.hiddenClass)
                }
            }));
            const p = () => {
                t.$el.addClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.addClass(t.params.pagination.paginationDisabledClass), u()
            };
            Object.assign(t.pagination, {
                enable: () => {
                    t.$el.removeClass(t.params.pagination.paginationDisabledClass), t.pagination.$el && t.pagination.$el.removeClass(t.params.pagination.paginationDisabledClass), d(), h(), c()
                },
                disable: p,
                render: h,
                update: c,
                init: d,
                destroy: u
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            const s = n();
            let r, o, l, c, h = !1,
                d = null,
                u = null;

            function p() {
                if (!t.params.scrollbar.el || !t.scrollbar.el) return;
                const {
                    scrollbar: e,
                    rtlTranslate: i,
                    progress: a
                } = t, {
                    $dragEl: s,
                    $el: n
                } = e, r = t.params.scrollbar;
                let c = o,
                    h = (l - o) * a;
                i ? (h = -h, h > 0 ? (c = o - h, h = 0) : -h + o > l && (c = l + h)) : h < 0 ? (c = o + h, h = 0) : h + o > l && (c = l - h), t.isHorizontal() ? (s.transform(`translate3d(${h}px, 0, 0)`), s[0].style.width = `${c}px`) : (s.transform(`translate3d(0px, ${h}px, 0)`), s[0].style.height = `${c}px`), r.hide && (clearTimeout(d), n[0].style.opacity = 1, d = setTimeout((() => {
                    n[0].style.opacity = 0, n.transition(400)
                }), 1e3))
            }

            function g() {
                if (!t.params.scrollbar.el || !t.scrollbar.el) return;
                const {
                    scrollbar: e
                } = t, {
                    $dragEl: i,
                    $el: a
                } = e;
                i[0].style.width = "", i[0].style.height = "", l = t.isHorizontal() ? a[0].offsetWidth : a[0].offsetHeight, c = t.size / (t.virtualSize + t.params.slidesOffsetBefore - (t.params.centeredSlides ? t.snapGrid[0] : 0)), o = "auto" === t.params.scrollbar.dragSize ? l * c : parseInt(t.params.scrollbar.dragSize, 10), t.isHorizontal() ? i[0].style.width = `${o}px` : i[0].style.height = `${o}px`, a[0].style.display = c >= 1 ? "none" : "", t.params.scrollbar.hide && (a[0].style.opacity = 0), t.params.watchOverflow && t.enabled && e.$el[t.isLocked ? "addClass" : "removeClass"](t.params.scrollbar.lockClass)
            }

            function x(e) {
                return t.isHorizontal() ? "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientX : e.clientX : "touchstart" === e.type || "touchmove" === e.type ? e.targetTouches[0].clientY : e.clientY
            }

            function v(e) {
                const {
                    scrollbar: i,
                    rtlTranslate: a
                } = t, {
                    $el: s
                } = i;
                let n;
                n = (x(e) - s.offset()[t.isHorizontal() ? "left" : "top"] - (null !== r ? r : o / 2)) / (l - o), n = Math.max(Math.min(n, 1), 0), a && (n = 1 - n);
                const c = t.minTranslate() + (t.maxTranslate() - t.minTranslate()) * n;
                t.updateProgress(c), t.setTranslate(c), t.updateActiveIndex(), t.updateSlidesClasses()
            }

            function b(e) {
                const i = t.params.scrollbar,
                    {
                        scrollbar: s,
                        $wrapperEl: n
                    } = t,
                    {
                        $el: o,
                        $dragEl: l
                    } = s;
                h = !0, r = e.target === l[0] || e.target === l ? x(e) - e.target.getBoundingClientRect()[t.isHorizontal() ? "left" : "top"] : null, e.preventDefault(), e.stopPropagation(), n.transition(100), l.transition(100), v(e), clearTimeout(u), o.transition(0), i.hide && o.css("opacity", 1), t.params.cssMode && t.$wrapperEl.css("scroll-snap-type", "none"), a("scrollbarDragStart", e)
            }

            function y(e) {
                const {
                    scrollbar: i,
                    $wrapperEl: s
                } = t, {
                    $el: n,
                    $dragEl: r
                } = i;
                h && (e.preventDefault ? e.preventDefault() : e.returnValue = !1, v(e), s.transition(0), n.transition(0), r.transition(0), a("scrollbarDragMove", e))
            }

            function w(e) {
                const i = t.params.scrollbar,
                    {
                        scrollbar: s,
                        $wrapperEl: n
                    } = t,
                    {
                        $el: r
                    } = s;
                h && (h = !1, t.params.cssMode && (t.$wrapperEl.css("scroll-snap-type", ""), n.transition("")), i.hide && (clearTimeout(u), u = m((() => {
                    r.css("opacity", 0), r.transition(400)
                }), 1e3)), a("scrollbarDragEnd", e), i.snapOnRelease && t.slideToClosest())
            }

            function S(e) {
                const {
                    scrollbar: i,
                    touchEventsTouch: a,
                    touchEventsDesktop: n,
                    params: r,
                    support: o
                } = t, l = i.$el;
                if (!l) return;
                const c = l[0],
                    h = !(!o.passiveListener || !r.passiveListeners) && {
                        passive: !1,
                        capture: !1
                    },
                    d = !(!o.passiveListener || !r.passiveListeners) && {
                        passive: !0,
                        capture: !1
                    };
                if (!c) return;
                const u = "on" === e ? "addEventListener" : "removeEventListener";
                o.touch ? (c[u](a.start, b, h), c[u](a.move, y, h), c[u](a.end, w, d)) : (c[u](n.start, b, h), s[u](n.move, y, h), s[u](n.end, w, d))
            }

            function C() {
                const {
                    scrollbar: e,
                    $el: i
                } = t;
                t.params.scrollbar = et(t, t.originalParams.scrollbar, t.params.scrollbar, {
                    el: "swiper-scrollbar"
                });
                const a = t.params.scrollbar;
                if (!a.el) return;
                let s = f(a.el);
                t.params.uniqueNavElements && "string" == typeof a.el && s.length > 1 && 1 === i.find(a.el).length && (s = i.find(a.el)), s.addClass(t.isHorizontal() ? a.horizontalClass : a.verticalClass);
                let n = s.find(`.${t.params.scrollbar.dragClass}`);
                0 === n.length && (n = f(`<div class="${t.params.scrollbar.dragClass}"></div>`), s.append(n)), Object.assign(e, {
                    $el: s,
                    el: s[0],
                    $dragEl: n,
                    dragEl: n[0]
                }), a.draggable && t.params.scrollbar.el && t.scrollbar.el && S("on"), s && s[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
            }

            function k() {
                const e = t.params.scrollbar,
                    i = t.scrollbar.$el;
                i && i.removeClass(t.isHorizontal() ? e.horizontalClass : e.verticalClass), t.params.scrollbar.el && t.scrollbar.el && S("off")
            }
            e({
                scrollbar: {
                    el: null,
                    dragSize: "auto",
                    hide: !1,
                    draggable: !1,
                    snapOnRelease: !0,
                    lockClass: "swiper-scrollbar-lock",
                    dragClass: "swiper-scrollbar-drag",
                    scrollbarDisabledClass: "swiper-scrollbar-disabled",
                    horizontalClass: "swiper-scrollbar-horizontal",
                    verticalClass: "swiper-scrollbar-vertical"
                }
            }), t.scrollbar = {
                el: null,
                dragEl: null,
                $el: null,
                $dragEl: null
            }, i("init", (() => {
                !1 === t.params.scrollbar.enabled ? A() : (C(), g(), p())
            })), i("update resize observerUpdate lock unlock", (() => {
                g()
            })), i("setTranslate", (() => {
                p()
            })), i("setTransition", ((e, i) => {
                ! function(e) {
                    t.params.scrollbar.el && t.scrollbar.el && t.scrollbar.$dragEl.transition(e)
                }(i)
            })), i("enable disable", (() => {
                const {
                    $el: e
                } = t.scrollbar;
                e && e[t.enabled ? "removeClass" : "addClass"](t.params.scrollbar.lockClass)
            })), i("destroy", (() => {
                k()
            }));
            const A = () => {
                t.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.addClass(t.params.scrollbar.scrollbarDisabledClass), k()
            };
            Object.assign(t.scrollbar, {
                enable: () => {
                    t.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), t.scrollbar.$el && t.scrollbar.$el.removeClass(t.params.scrollbar.scrollbarDisabledClass), C(), g(), p()
                },
                disable: A,
                updateSize: g,
                setTranslate: p,
                init: C,
                destroy: k
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                parallax: {
                    enabled: !1
                }
            });
            const a = (e, i) => {
                    const {
                        rtl: a
                    } = t, s = f(e), n = a ? -1 : 1, r = s.attr("data-swiper-parallax") || "0";
                    let o = s.attr("data-swiper-parallax-x"),
                        l = s.attr("data-swiper-parallax-y");
                    const c = s.attr("data-swiper-parallax-scale"),
                        h = s.attr("data-swiper-parallax-opacity");
                    if (o || l ? (o = o || "0", l = l || "0") : t.isHorizontal() ? (o = r, l = "0") : (l = r, o = "0"), o = o.indexOf("%") >= 0 ? parseInt(o, 10) * i * n + "%" : o * i * n + "px", l = l.indexOf("%") >= 0 ? parseInt(l, 10) * i + "%" : l * i + "px", null != h) {
                        const t = h - (h - 1) * (1 - Math.abs(i));
                        s[0].style.opacity = t
                    }
                    if (null == c) s.transform(`translate3d(${o}, ${l}, 0px)`);
                    else {
                        const t = c - (c - 1) * (1 - Math.abs(i));
                        s.transform(`translate3d(${o}, ${l}, 0px) scale(${t})`)
                    }
                },
                s = () => {
                    const {
                        $el: e,
                        slides: i,
                        progress: s,
                        snapGrid: n
                    } = t;
                    e.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => {
                        a(t, s)
                    })), i.each(((e, i) => {
                        let r = e.progress;
                        t.params.slidesPerGroup > 1 && "auto" !== t.params.slidesPerView && (r += Math.ceil(i / 2) - s * (n.length - 1)), r = Math.min(Math.max(r, -1), 1), f(e).find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => {
                            a(t, r)
                        }))
                    }))
                };
            i("beforeInit", (() => {
                t.params.parallax.enabled && (t.params.watchSlidesProgress = !0, t.originalParams.watchSlidesProgress = !0)
            })), i("init", (() => {
                t.params.parallax.enabled && s()
            })), i("setTranslate", (() => {
                t.params.parallax.enabled && s()
            })), i("setTransition", ((e, i) => {
                t.params.parallax.enabled && ((e = t.params.speed) => {
                    const {
                        $el: i
                    } = t;
                    i.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]").each((t => {
                        const i = f(t);
                        let a = parseInt(i.attr("data-swiper-parallax-duration"), 10) || e;
                        0 === e && (a = 0), i.transition(a)
                    }))
                })(i)
            }))
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            const s = o();
            e({
                zoom: {
                    enabled: !1,
                    maxRatio: 3,
                    minRatio: 1,
                    toggle: !0,
                    containerClass: "swiper-zoom-container",
                    zoomedSlideClass: "swiper-slide-zoomed"
                }
            }), t.zoom = {
                enabled: !1
            };
            let n, r, l, c = 1,
                h = !1;
            const d = {
                    $slideEl: void 0,
                    slideWidth: void 0,
                    slideHeight: void 0,
                    $imageEl: void 0,
                    $imageWrapEl: void 0,
                    maxRatio: 3
                },
                u = {
                    isTouched: void 0,
                    isMoved: void 0,
                    currentX: void 0,
                    currentY: void 0,
                    minX: void 0,
                    minY: void 0,
                    maxX: void 0,
                    maxY: void 0,
                    width: void 0,
                    height: void 0,
                    startX: void 0,
                    startY: void 0,
                    touchesStart: {},
                    touchesCurrent: {}
                },
                p = {
                    x: void 0,
                    y: void 0,
                    prevPositionX: void 0,
                    prevPositionY: void 0,
                    prevTime: void 0
                };
            let g = 1;

            function m(t) {
                if (t.targetTouches.length < 2) return 1;
                const e = t.targetTouches[0].pageX,
                    i = t.targetTouches[0].pageY,
                    a = t.targetTouches[1].pageX,
                    s = t.targetTouches[1].pageY;
                return Math.sqrt((a - e) ** 2 + (s - i) ** 2)
            }

            function x(e) {
                const i = t.support,
                    a = t.params.zoom;
                if (r = !1, l = !1, !i.gestures) {
                    if ("touchstart" !== e.type || "touchstart" === e.type && e.targetTouches.length < 2) return;
                    r = !0, d.scaleStart = m(e)
                }
                d.$slideEl && d.$slideEl.length || (d.$slideEl = f(e.target).closest(`.${t.params.slideClass}`), 0 === d.$slideEl.length && (d.$slideEl = t.slides.eq(t.activeIndex)), d.$imageEl = d.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), d.$imageWrapEl = d.$imageEl.parent(`.${a.containerClass}`), d.maxRatio = d.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, 0 !== d.$imageWrapEl.length) ? (d.$imageEl && d.$imageEl.transition(0), h = !0) : d.$imageEl = void 0
            }

            function b(e) {
                const i = t.support,
                    a = t.params.zoom,
                    s = t.zoom;
                if (!i.gestures) {
                    if ("touchmove" !== e.type || "touchmove" === e.type && e.targetTouches.length < 2) return;
                    l = !0, d.scaleMove = m(e)
                }
                d.$imageEl && 0 !== d.$imageEl.length ? (i.gestures ? s.scale = e.scale * c : s.scale = d.scaleMove / d.scaleStart * c, s.scale > d.maxRatio && (s.scale = d.maxRatio - 1 + (s.scale - d.maxRatio + 1) ** .5), s.scale < a.minRatio && (s.scale = a.minRatio + 1 - (a.minRatio - s.scale + 1) ** .5), d.$imageEl.transform(`translate3d(0,0,0) scale(${s.scale})`)) : "gesturechange" === e.type && x(e)
            }

            function y(e) {
                const i = t.device,
                    a = t.support,
                    s = t.params.zoom,
                    n = t.zoom;
                if (!a.gestures) {
                    if (!r || !l) return;
                    if ("touchend" !== e.type || "touchend" === e.type && e.changedTouches.length < 2 && !i.android) return;
                    r = !1, l = !1
                }
                d.$imageEl && 0 !== d.$imageEl.length && (n.scale = Math.max(Math.min(n.scale, d.maxRatio), s.minRatio), d.$imageEl.transition(t.params.speed).transform(`translate3d(0,0,0) scale(${n.scale})`), c = n.scale, h = !1, 1 === n.scale && (d.$slideEl = void 0))
            }

            function w(e) {
                const i = t.zoom;
                if (!d.$imageEl || 0 === d.$imageEl.length) return;
                if (t.allowClick = !1, !u.isTouched || !d.$slideEl) return;
                u.isMoved || (u.width = d.$imageEl[0].offsetWidth, u.height = d.$imageEl[0].offsetHeight, u.startX = v(d.$imageWrapEl[0], "x") || 0, u.startY = v(d.$imageWrapEl[0], "y") || 0, d.slideWidth = d.$slideEl[0].offsetWidth, d.slideHeight = d.$slideEl[0].offsetHeight, d.$imageWrapEl.transition(0));
                const a = u.width * i.scale,
                    s = u.height * i.scale;
                if (!(a < d.slideWidth && s < d.slideHeight)) {
                    if (u.minX = Math.min(d.slideWidth / 2 - a / 2, 0), u.maxX = -u.minX, u.minY = Math.min(d.slideHeight / 2 - s / 2, 0), u.maxY = -u.minY, u.touchesCurrent.x = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, u.touchesCurrent.y = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, !u.isMoved && !h) {
                        if (t.isHorizontal() && (Math.floor(u.minX) === Math.floor(u.startX) && u.touchesCurrent.x < u.touchesStart.x || Math.floor(u.maxX) === Math.floor(u.startX) && u.touchesCurrent.x > u.touchesStart.x)) return void(u.isTouched = !1);
                        if (!t.isHorizontal() && (Math.floor(u.minY) === Math.floor(u.startY) && u.touchesCurrent.y < u.touchesStart.y || Math.floor(u.maxY) === Math.floor(u.startY) && u.touchesCurrent.y > u.touchesStart.y)) return void(u.isTouched = !1)
                    }
                    e.cancelable && e.preventDefault(), e.stopPropagation(), u.isMoved = !0, u.currentX = u.touchesCurrent.x - u.touchesStart.x + u.startX, u.currentY = u.touchesCurrent.y - u.touchesStart.y + u.startY, u.currentX < u.minX && (u.currentX = u.minX + 1 - (u.minX - u.currentX + 1) ** .8), u.currentX > u.maxX && (u.currentX = u.maxX - 1 + (u.currentX - u.maxX + 1) ** .8), u.currentY < u.minY && (u.currentY = u.minY + 1 - (u.minY - u.currentY + 1) ** .8), u.currentY > u.maxY && (u.currentY = u.maxY - 1 + (u.currentY - u.maxY + 1) ** .8), p.prevPositionX || (p.prevPositionX = u.touchesCurrent.x), p.prevPositionY || (p.prevPositionY = u.touchesCurrent.y), p.prevTime || (p.prevTime = Date.now()), p.x = (u.touchesCurrent.x - p.prevPositionX) / (Date.now() - p.prevTime) / 2, p.y = (u.touchesCurrent.y - p.prevPositionY) / (Date.now() - p.prevTime) / 2, Math.abs(u.touchesCurrent.x - p.prevPositionX) < 2 && (p.x = 0), Math.abs(u.touchesCurrent.y - p.prevPositionY) < 2 && (p.y = 0), p.prevPositionX = u.touchesCurrent.x, p.prevPositionY = u.touchesCurrent.y, p.prevTime = Date.now(), d.$imageWrapEl.transform(`translate3d(${u.currentX}px, ${u.currentY}px,0)`)
                }
            }

            function S() {
                const e = t.zoom;
                d.$slideEl && t.previousIndex !== t.activeIndex && (d.$imageEl && d.$imageEl.transform("translate3d(0,0,0) scale(1)"), d.$imageWrapEl && d.$imageWrapEl.transform("translate3d(0,0,0)"), e.scale = 1, c = 1, d.$slideEl = void 0, d.$imageEl = void 0, d.$imageWrapEl = void 0)
            }

            function C(e) {
                const i = t.zoom,
                    a = t.params.zoom;
                if (d.$slideEl || (e && e.target && (d.$slideEl = f(e.target).closest(`.${t.params.slideClass}`)), d.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? d.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : d.$slideEl = t.slides.eq(t.activeIndex)), d.$imageEl = d.$slideEl.find(`.${a.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), d.$imageWrapEl = d.$imageEl.parent(`.${a.containerClass}`)), !d.$imageEl || 0 === d.$imageEl.length || !d.$imageWrapEl || 0 === d.$imageWrapEl.length) return;
                let n, r, o, l, h, p, g, m, x, v, b, y, w, S, C, k, A, E;
                t.params.cssMode && (t.wrapperEl.style.overflow = "hidden", t.wrapperEl.style.touchAction = "none"), d.$slideEl.addClass(`${a.zoomedSlideClass}`), void 0 === u.touchesStart.x && e ? (n = "touchend" === e.type ? e.changedTouches[0].pageX : e.pageX, r = "touchend" === e.type ? e.changedTouches[0].pageY : e.pageY) : (n = u.touchesStart.x, r = u.touchesStart.y), i.scale = d.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, c = d.$imageWrapEl.attr("data-swiper-zoom") || a.maxRatio, e ? (A = d.$slideEl[0].offsetWidth, E = d.$slideEl[0].offsetHeight, o = d.$slideEl.offset().left + s.scrollX, l = d.$slideEl.offset().top + s.scrollY, h = o + A / 2 - n, p = l + E / 2 - r, x = d.$imageEl[0].offsetWidth, v = d.$imageEl[0].offsetHeight, b = x * i.scale, y = v * i.scale, w = Math.min(A / 2 - b / 2, 0), S = Math.min(E / 2 - y / 2, 0), C = -w, k = -S, g = h * i.scale, m = p * i.scale, g < w && (g = w), g > C && (g = C), m < S && (m = S), m > k && (m = k)) : (g = 0, m = 0), d.$imageWrapEl.transition(300).transform(`translate3d(${g}px, ${m}px,0)`), d.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${i.scale})`)
            }

            function k() {
                const e = t.zoom,
                    i = t.params.zoom;
                d.$slideEl || (t.params.virtual && t.params.virtual.enabled && t.virtual ? d.$slideEl = t.$wrapperEl.children(`.${t.params.slideActiveClass}`) : d.$slideEl = t.slides.eq(t.activeIndex), d.$imageEl = d.$slideEl.find(`.${i.containerClass}`).eq(0).find("picture, img, svg, canvas, .swiper-zoom-target").eq(0), d.$imageWrapEl = d.$imageEl.parent(`.${i.containerClass}`)), d.$imageEl && 0 !== d.$imageEl.length && d.$imageWrapEl && 0 !== d.$imageWrapEl.length && (t.params.cssMode && (t.wrapperEl.style.overflow = "", t.wrapperEl.style.touchAction = ""), e.scale = 1, c = 1, d.$imageWrapEl.transition(300).transform("translate3d(0,0,0)"), d.$imageEl.transition(300).transform("translate3d(0,0,0) scale(1)"), d.$slideEl.removeClass(`${i.zoomedSlideClass}`), d.$slideEl = void 0)
            }

            function A(e) {
                const i = t.zoom;
                i.scale && 1 !== i.scale ? k() : C(e)
            }

            function E() {
                const e = t.support;
                return {
                    passiveListener: !("touchstart" !== t.touchEvents.start || !e.passiveListener || !t.params.passiveListeners) && {
                        passive: !0,
                        capture: !1
                    },
                    activeListenerWithCapture: !e.passiveListener || {
                        passive: !1,
                        capture: !0
                    }
                }
            }

            function T() {
                return `.${t.params.slideClass}`
            }

            function P(e) {
                const {
                    passiveListener: i
                } = E(), a = T();
                t.$wrapperEl[e]("gesturestart", a, x, i), t.$wrapperEl[e]("gesturechange", a, b, i), t.$wrapperEl[e]("gestureend", a, y, i)
            }

            function M() {
                n || (n = !0, P("on"))
            }

            function L() {
                n && (n = !1, P("off"))
            }

            function I() {
                const e = t.zoom;
                if (e.enabled) return;
                e.enabled = !0;
                const i = t.support,
                    {
                        passiveListener: a,
                        activeListenerWithCapture: s
                    } = E(),
                    n = T();
                i.gestures ? (t.$wrapperEl.on(t.touchEvents.start, M, a), t.$wrapperEl.on(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.on(t.touchEvents.start, n, x, a), t.$wrapperEl.on(t.touchEvents.move, n, b, s), t.$wrapperEl.on(t.touchEvents.end, n, y, a), t.touchEvents.cancel && t.$wrapperEl.on(t.touchEvents.cancel, n, y, a)), t.$wrapperEl.on(t.touchEvents.move, `.${t.params.zoom.containerClass}`, w, s)
            }

            function _() {
                const e = t.zoom;
                if (!e.enabled) return;
                const i = t.support;
                e.enabled = !1;
                const {
                    passiveListener: a,
                    activeListenerWithCapture: s
                } = E(), n = T();
                i.gestures ? (t.$wrapperEl.off(t.touchEvents.start, M, a), t.$wrapperEl.off(t.touchEvents.end, L, a)) : "touchstart" === t.touchEvents.start && (t.$wrapperEl.off(t.touchEvents.start, n, x, a), t.$wrapperEl.off(t.touchEvents.move, n, b, s), t.$wrapperEl.off(t.touchEvents.end, n, y, a), t.touchEvents.cancel && t.$wrapperEl.off(t.touchEvents.cancel, n, y, a)), t.$wrapperEl.off(t.touchEvents.move, `.${t.params.zoom.containerClass}`, w, s)
            }
            Object.defineProperty(t.zoom, "scale", {
                get: () => g,
                set(t) {
                    if (g !== t) {
                        const e = d.$imageEl ? d.$imageEl[0] : void 0,
                            i = d.$slideEl ? d.$slideEl[0] : void 0;
                        a("zoomChange", t, e, i)
                    }
                    g = t
                }
            }), i("init", (() => {
                t.params.zoom.enabled && I()
            })), i("destroy", (() => {
                _()
            })), i("touchStart", ((e, i) => {
                t.zoom.enabled && function(e) {
                    const i = t.device;
                    d.$imageEl && 0 !== d.$imageEl.length && (u.isTouched || (i.android && e.cancelable && e.preventDefault(), u.isTouched = !0, u.touchesStart.x = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, u.touchesStart.y = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY))
                }(i)
            })), i("touchEnd", ((e, i) => {
                t.zoom.enabled && function() {
                    const e = t.zoom;
                    if (!d.$imageEl || 0 === d.$imageEl.length) return;
                    if (!u.isTouched || !u.isMoved) return u.isTouched = !1, void(u.isMoved = !1);
                    u.isTouched = !1, u.isMoved = !1;
                    let i = 300,
                        a = 300;
                    const s = p.x * i,
                        n = u.currentX + s,
                        r = p.y * a,
                        o = u.currentY + r;
                    0 !== p.x && (i = Math.abs((n - u.currentX) / p.x)), 0 !== p.y && (a = Math.abs((o - u.currentY) / p.y));
                    const l = Math.max(i, a);
                    u.currentX = n, u.currentY = o;
                    const c = u.width * e.scale,
                        h = u.height * e.scale;
                    u.minX = Math.min(d.slideWidth / 2 - c / 2, 0), u.maxX = -u.minX, u.minY = Math.min(d.slideHeight / 2 - h / 2, 0), u.maxY = -u.minY, u.currentX = Math.max(Math.min(u.currentX, u.maxX), u.minX), u.currentY = Math.max(Math.min(u.currentY, u.maxY), u.minY), d.$imageWrapEl.transition(l).transform(`translate3d(${u.currentX}px, ${u.currentY}px,0)`)
                }()
            })), i("doubleTap", ((e, i) => {
                !t.animating && t.params.zoom.enabled && t.zoom.enabled && t.params.zoom.toggle && A(i)
            })), i("transitionEnd", (() => {
                t.zoom.enabled && t.params.zoom.enabled && S()
            })), i("slideChange", (() => {
                t.zoom.enabled && t.params.zoom.enabled && t.params.cssMode && S()
            })), Object.assign(t.zoom, {
                enable: I,
                disable: _,
                in: C,
                out: k,
                toggle: A
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            e({
                lazy: {
                    checkInView: !1,
                    enabled: !1,
                    loadPrevNext: !1,
                    loadPrevNextAmount: 1,
                    loadOnTransitionStart: !1,
                    scrollingElement: "",
                    elementClass: "swiper-lazy",
                    loadingClass: "swiper-lazy-loading",
                    loadedClass: "swiper-lazy-loaded",
                    preloaderClass: "swiper-lazy-preloader"
                }
            }), t.lazy = {};
            let s = !1,
                n = !1;

            function r(e, i = !0) {
                const s = t.params.lazy;
                if (void 0 === e) return;
                if (0 === t.slides.length) return;
                const n = t.virtual && t.params.virtual.enabled ? t.$wrapperEl.children(`.${t.params.slideClass}[data-swiper-slide-index="${e}"]`) : t.slides.eq(e),
                    o = n.find(`.${s.elementClass}:not(.${s.loadedClass}):not(.${s.loadingClass})`);
                !n.hasClass(s.elementClass) || n.hasClass(s.loadedClass) || n.hasClass(s.loadingClass) || o.push(n[0]), 0 !== o.length && o.each((e => {
                    const o = f(e);
                    o.addClass(s.loadingClass);
                    const l = o.attr("data-background"),
                        c = o.attr("data-src"),
                        h = o.attr("data-srcset"),
                        d = o.attr("data-sizes"),
                        u = o.parent("picture");
                    t.loadImage(o[0], c || l, h, d, !1, (() => {
                        if (null != t && t && (!t || t.params) && !t.destroyed) {
                            if (l ? (o.css("background-image", `url("${l}")`), o.removeAttr("data-background")) : (h && (o.attr("srcset", h), o.removeAttr("data-srcset")), d && (o.attr("sizes", d), o.removeAttr("data-sizes")), u.length && u.children("source").each((t => {
                                    const e = f(t);
                                    e.attr("data-srcset") && (e.attr("srcset", e.attr("data-srcset")), e.removeAttr("data-srcset"))
                                })), c && (o.attr("src", c), o.removeAttr("data-src"))), o.addClass(s.loadedClass).removeClass(s.loadingClass), n.find(`.${s.preloaderClass}`).remove(), t.params.loop && i) {
                                const e = n.attr("data-swiper-slide-index");
                                if (n.hasClass(t.params.slideDuplicateClass)) {
                                    r(t.$wrapperEl.children(`[data-swiper-slide-index="${e}"]:not(.${t.params.slideDuplicateClass})`).index(), !1)
                                } else {
                                    r(t.$wrapperEl.children(`.${t.params.slideDuplicateClass}[data-swiper-slide-index="${e}"]`).index(), !1)
                                }
                            }
                            a("lazyImageReady", n[0], o[0]), t.params.autoHeight && t.updateAutoHeight()
                        }
                    })), a("lazyImageLoad", n[0], o[0])
                }))
            }

            function l() {
                const {
                    $wrapperEl: e,
                    params: i,
                    slides: a,
                    activeIndex: s
                } = t, o = t.virtual && i.virtual.enabled, l = i.lazy;
                let c = i.slidesPerView;

                function h(t) {
                    if (o) {
                        if (e.children(`.${i.slideClass}[data-swiper-slide-index="${t}"]`).length) return !0
                    } else if (a[t]) return !0;
                    return !1
                }

                function d(t) {
                    return o ? f(t).attr("data-swiper-slide-index") : f(t).index()
                }
                if ("auto" === c && (c = 0), n || (n = !0), t.params.watchSlidesProgress) e.children(`.${i.slideVisibleClass}`).each((t => {
                    r(o ? f(t).attr("data-swiper-slide-index") : f(t).index())
                }));
                else if (c > 1)
                    for (let t = s; t < s + c; t += 1) h(t) && r(t);
                else r(s);
                if (l.loadPrevNext)
                    if (c > 1 || l.loadPrevNextAmount && l.loadPrevNextAmount > 1) {
                        const t = l.loadPrevNextAmount,
                            e = Math.ceil(c),
                            i = Math.min(s + e + Math.max(t, e), a.length),
                            n = Math.max(s - Math.max(e, t), 0);
                        for (let t = s + e; t < i; t += 1) h(t) && r(t);
                        for (let t = n; t < s; t += 1) h(t) && r(t)
                    } else {
                        const t = e.children(`.${i.slideNextClass}`);
                        t.length > 0 && r(d(t));
                        const a = e.children(`.${i.slidePrevClass}`);
                        a.length > 0 && r(d(a))
                    }
            }

            function c() {
                const e = o();
                if (!t || t.destroyed) return;
                const i = t.params.lazy.scrollingElement ? f(t.params.lazy.scrollingElement) : f(e),
                    a = i[0] === e,
                    n = a ? e.innerWidth : i[0].offsetWidth,
                    r = a ? e.innerHeight : i[0].offsetHeight,
                    h = t.$el.offset(),
                    {
                        rtlTranslate: d
                    } = t;
                let u = !1;
                d && (h.left -= t.$el[0].scrollLeft);
                const p = [
                    [h.left, h.top],
                    [h.left + t.width, h.top],
                    [h.left, h.top + t.height],
                    [h.left + t.width, h.top + t.height]
                ];
                for (let t = 0; t < p.length; t += 1) {
                    const e = p[t];
                    if (e[0] >= 0 && e[0] <= n && e[1] >= 0 && e[1] <= r) {
                        if (0 === e[0] && 0 === e[1]) continue;
                        u = !0
                    }
                }
                const g = !("touchstart" !== t.touchEvents.start || !t.support.passiveListener || !t.params.passiveListeners) && {
                    passive: !0,
                    capture: !1
                };
                u ? (l(), i.off("scroll", c, g)) : s || (s = !0, i.on("scroll", c, g))
            }
            i("beforeInit", (() => {
                t.params.lazy.enabled && t.params.preloadImages && (t.params.preloadImages = !1)
            })), i("init", (() => {
                t.params.lazy.enabled && (t.params.lazy.checkInView ? c() : l())
            })), i("scroll", (() => {
                t.params.freeMode && t.params.freeMode.enabled && !t.params.freeMode.sticky && l()
            })), i("scrollbarDragMove resize _freeModeNoMomentumRelease", (() => {
                t.params.lazy.enabled && (t.params.lazy.checkInView ? c() : l())
            })), i("transitionStart", (() => {
                t.params.lazy.enabled && (t.params.lazy.loadOnTransitionStart || !t.params.lazy.loadOnTransitionStart && !n) && (t.params.lazy.checkInView ? c() : l())
            })), i("transitionEnd", (() => {
                t.params.lazy.enabled && !t.params.lazy.loadOnTransitionStart && (t.params.lazy.checkInView ? c() : l())
            })), i("slideChange", (() => {
                const {
                    lazy: e,
                    cssMode: i,
                    watchSlidesProgress: a,
                    touchReleaseOnEdges: s,
                    resistanceRatio: n
                } = t.params;
                e.enabled && (i || a && (s || 0 === n)) && l()
            })), i("destroy", (() => {
                t.$el && t.$el.find(`.${t.params.lazy.loadingClass}`).removeClass(t.params.lazy.loadingClass)
            })), Object.assign(t.lazy, {
                load: l,
                loadInSlide: r
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            function a(t, e) {
                const i = function() {
                    let t, e, i;
                    return (a, s) => {
                        for (e = -1, t = a.length; t - e > 1;) i = t + e >> 1, a[i] <= s ? e = i : t = i;
                        return t
                    }
                }();
                let a, s;
                return this.x = t, this.y = e, this.lastIndex = t.length - 1, this.interpolate = function(t) {
                    return t ? (s = i(this.x, t), a = s - 1, (t - this.x[a]) * (this.y[s] - this.y[a]) / (this.x[s] - this.x[a]) + this.y[a]) : 0
                }, this
            }

            function s() {
                t.controller.control && t.controller.spline && (t.controller.spline = void 0, delete t.controller.spline)
            }
            e({
                controller: {
                    control: void 0,
                    inverse: !1,
                    by: "slide"
                }
            }), t.controller = {
                control: void 0
            }, i("beforeInit", (() => {
                t.controller.control = t.params.controller.control
            })), i("update", (() => {
                s()
            })), i("resize", (() => {
                s()
            })), i("observerUpdate", (() => {
                s()
            })), i("setTranslate", ((e, i, a) => {
                t.controller.control && t.controller.setTranslate(i, a)
            })), i("setTransition", ((e, i, a) => {
                t.controller.control && t.controller.setTransition(i, a)
            })), Object.assign(t.controller, {
                setTranslate: function(e, i) {
                    const s = t.controller.control;
                    let n, r;
                    const o = t.constructor;

                    function l(e) {
                        const i = t.rtlTranslate ? -t.translate : t.translate;
                        "slide" === t.params.controller.by && (! function(e) {
                            t.controller.spline || (t.controller.spline = t.params.loop ? new a(t.slidesGrid, e.slidesGrid) : new a(t.snapGrid, e.snapGrid))
                        }(e), r = -t.controller.spline.interpolate(-i)), r && "container" !== t.params.controller.by || (n = (e.maxTranslate() - e.minTranslate()) / (t.maxTranslate() - t.minTranslate()), r = (i - t.minTranslate()) * n + e.minTranslate()), t.params.controller.inverse && (r = e.maxTranslate() - r), e.updateProgress(r), e.setTranslate(r, t), e.updateActiveIndex(), e.updateSlidesClasses()
                    }
                    if (Array.isArray(s))
                        for (let t = 0; t < s.length; t += 1) s[t] !== i && s[t] instanceof o && l(s[t]);
                    else s instanceof o && i !== s && l(s)
                },
                setTransition: function(e, i) {
                    const a = t.constructor,
                        s = t.controller.control;
                    let n;

                    function r(i) {
                        i.setTransition(e, t), 0 !== e && (i.transitionStart(), i.params.autoHeight && m((() => {
                            i.updateAutoHeight()
                        })), i.$wrapperEl.transitionEnd((() => {
                            s && (i.params.loop && "slide" === t.params.controller.by && i.loopFix(), i.transitionEnd())
                        })))
                    }
                    if (Array.isArray(s))
                        for (n = 0; n < s.length; n += 1) s[n] !== i && s[n] instanceof a && r(s[n]);
                    else s instanceof a && i !== s && r(s)
                }
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                a11y: {
                    enabled: !0,
                    notificationClass: "swiper-notification",
                    prevSlideMessage: "Previous slide",
                    nextSlideMessage: "Next slide",
                    firstSlideMessage: "This is the first slide",
                    lastSlideMessage: "This is the last slide",
                    paginationBulletMessage: "Go to slide {{index}}",
                    slideLabelMessage: "{{index}} / {{slidesLength}}",
                    containerMessage: null,
                    containerRoleDescriptionMessage: null,
                    itemRoleDescriptionMessage: null,
                    slideRole: "group",
                    id: null
                }
            }), t.a11y = {
                clicked: !1
            };
            let a = null;

            function s(t) {
                const e = a;
                0 !== e.length && (e.html(""), e.html(t))
            }

            function n(t) {
                t.attr("tabIndex", "0")
            }

            function r(t) {
                t.attr("tabIndex", "-1")
            }

            function o(t, e) {
                t.attr("role", e)
            }

            function l(t, e) {
                t.attr("aria-roledescription", e)
            }

            function c(t, e) {
                t.attr("aria-label", e)
            }

            function h(t) {
                t.attr("aria-disabled", !0)
            }

            function d(t) {
                t.attr("aria-disabled", !1)
            }

            function u(e) {
                if (13 !== e.keyCode && 32 !== e.keyCode) return;
                const i = t.params.a11y,
                    a = f(e.target);
                t.navigation && t.navigation.$nextEl && a.is(t.navigation.$nextEl) && (t.isEnd && !t.params.loop || t.slideNext(), t.isEnd ? s(i.lastSlideMessage) : s(i.nextSlideMessage)), t.navigation && t.navigation.$prevEl && a.is(t.navigation.$prevEl) && (t.isBeginning && !t.params.loop || t.slidePrev(), t.isBeginning ? s(i.firstSlideMessage) : s(i.prevSlideMessage)), t.pagination && a.is(it(t.params.pagination.bulletClass)) && a[0].click()
            }

            function p() {
                return t.pagination && t.pagination.bullets && t.pagination.bullets.length
            }

            function g() {
                return p() && t.params.pagination.clickable
            }
            const m = (t, e, i) => {
                    n(t), "BUTTON" !== t[0].tagName && (o(t, "button"), t.on("keydown", u)), c(t, i),
                        function(t, e) {
                            t.attr("aria-controls", e)
                        }(t, e)
                },
                x = () => {
                    t.a11y.clicked = !0
                },
                v = () => {
                    t.a11y.clicked = !1
                },
                b = e => {
                    if (t.a11y.clicked) return;
                    const i = e.target.closest(`.${t.params.slideClass}`);
                    if (!i || !t.slides.includes(i)) return;
                    const a = t.slides.indexOf(i) === t.activeIndex,
                        s = t.params.watchSlidesProgress && t.visibleSlides && t.visibleSlides.includes(i);
                    a || s || (t.isHorizontal() ? t.el.scrollLeft = 0 : t.el.scrollTop = 0, t.slideTo(t.slides.indexOf(i), 0))
                },
                y = () => {
                    const e = t.params.a11y;
                    e.itemRoleDescriptionMessage && l(f(t.slides), e.itemRoleDescriptionMessage), e.slideRole && o(f(t.slides), e.slideRole);
                    const i = t.params.loop ? t.slides.filter((e => !e.classList.contains(t.params.slideDuplicateClass))).length : t.slides.length;
                    e.slideLabelMessage && t.slides.each(((a, s) => {
                        const n = f(a),
                            r = t.params.loop ? parseInt(n.attr("data-swiper-slide-index"), 10) : s;
                        c(n, e.slideLabelMessage.replace(/\{\{index\}\}/, r + 1).replace(/\{\{slidesLength\}\}/, i))
                    }))
                },
                w = () => {
                    const e = t.params.a11y;
                    t.$el.append(a);
                    const i = t.$el;
                    e.containerRoleDescriptionMessage && l(i, e.containerRoleDescriptionMessage), e.containerMessage && c(i, e.containerMessage);
                    const s = t.$wrapperEl,
                        n = e.id || s.attr("id") || `swiper-wrapper-${function(t=16){return"x".repeat(t).replace(/x/g,(()=>Math.round(16*Math.random()).toString(16)))}(16)}`,
                        r = t.params.autoplay && t.params.autoplay.enabled ? "off" : "polite";
                    var o;
                    let h, d;
                    o = n, s.attr("id", o),
                        function(t, e) {
                            t.attr("aria-live", e)
                        }(s, r), y(), t.navigation && t.navigation.$nextEl && (h = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (d = t.navigation.$prevEl), h && h.length && m(h, n, e.nextSlideMessage), d && d.length && m(d, n, e.prevSlideMessage), g() && t.pagination.$el.on("keydown", it(t.params.pagination.bulletClass), u), t.$el.on("focus", b, !0), t.$el.on("pointerdown", x, !0), t.$el.on("pointerup", v, !0)
                };
            i("beforeInit", (() => {
                a = f(`<span class="${t.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`)
            })), i("afterInit", (() => {
                t.params.a11y.enabled && w()
            })), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", (() => {
                t.params.a11y.enabled && y()
            })), i("fromEdge toEdge afterInit lock unlock", (() => {
                t.params.a11y.enabled && function() {
                    if (t.params.loop || t.params.rewind || !t.navigation) return;
                    const {
                        $nextEl: e,
                        $prevEl: i
                    } = t.navigation;
                    i && i.length > 0 && (t.isBeginning ? (h(i), r(i)) : (d(i), n(i))), e && e.length > 0 && (t.isEnd ? (h(e), r(e)) : (d(e), n(e)))
                }()
            })), i("paginationUpdate", (() => {
                t.params.a11y.enabled && function() {
                    const e = t.params.a11y;
                    p() && t.pagination.bullets.each((i => {
                        const a = f(i);
                        t.params.pagination.clickable && (n(a), t.params.pagination.renderBullet || (o(a, "button"), c(a, e.paginationBulletMessage.replace(/\{\{index\}\}/, a.index() + 1)))), a.is(`.${t.params.pagination.bulletActiveClass}`) ? a.attr("aria-current", "true") : a.removeAttr("aria-current")
                    }))
                }()
            })), i("destroy", (() => {
                t.params.a11y.enabled && function() {
                    let e, i;
                    a && a.length > 0 && a.remove(), t.navigation && t.navigation.$nextEl && (e = t.navigation.$nextEl), t.navigation && t.navigation.$prevEl && (i = t.navigation.$prevEl), e && e.off("keydown", u), i && i.off("keydown", u), g() && t.pagination.$el.off("keydown", it(t.params.pagination.bulletClass), u), t.$el.off("focus", b, !0), t.$el.off("pointerdown", x, !0), t.$el.off("pointerup", v, !0)
                }()
            }))
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                history: {
                    enabled: !1,
                    root: "",
                    replaceState: !1,
                    key: "slides",
                    keepQuery: !1
                }
            });
            let a = !1,
                s = {};
            const n = t => t.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""),
                r = t => {
                    const e = o();
                    let i;
                    i = t ? new URL(t) : e.location;
                    const a = i.pathname.slice(1).split("/").filter((t => "" !== t)),
                        s = a.length;
                    return {
                        key: a[s - 2],
                        value: a[s - 1]
                    }
                },
                l = (e, i) => {
                    const s = o();
                    if (!a || !t.params.history.enabled) return;
                    let r;
                    r = t.params.url ? new URL(t.params.url) : s.location;
                    const l = t.slides.eq(i);
                    let c = n(l.attr("data-history"));
                    if (t.params.history.root.length > 0) {
                        let i = t.params.history.root;
                        "/" === i[i.length - 1] && (i = i.slice(0, i.length - 1)), c = `${i}/${e}/${c}`
                    } else r.pathname.includes(e) || (c = `${e}/${c}`);
                    t.params.history.keepQuery && (c += r.search);
                    const h = s.history.state;
                    h && h.value === c || (t.params.history.replaceState ? s.history.replaceState({
                        value: c
                    }, null, c) : s.history.pushState({
                        value: c
                    }, null, c))
                },
                c = (e, i, a) => {
                    if (i)
                        for (let s = 0, r = t.slides.length; s < r; s += 1) {
                            const r = t.slides.eq(s);
                            if (n(r.attr("data-history")) === i && !r.hasClass(t.params.slideDuplicateClass)) {
                                const i = r.index();
                                t.slideTo(i, e, a)
                            }
                        } else t.slideTo(0, e, a)
                },
                h = () => {
                    s = r(t.params.url), c(t.params.speed, s.value, !1)
                };
            i("init", (() => {
                t.params.history.enabled && (() => {
                    const e = o();
                    if (t.params.history) {
                        if (!e.history || !e.history.pushState) return t.params.history.enabled = !1, void(t.params.hashNavigation.enabled = !0);
                        a = !0, s = r(t.params.url), (s.key || s.value) && (c(0, s.value, t.params.runCallbacksOnInit), t.params.history.replaceState || e.addEventListener("popstate", h))
                    }
                })()
            })), i("destroy", (() => {
                t.params.history.enabled && (() => {
                    const e = o();
                    t.params.history.replaceState || e.removeEventListener("popstate", h)
                })()
            })), i("transitionEnd _freeModeNoMomentumRelease", (() => {
                a && l(t.params.history.key, t.activeIndex)
            })), i("slideChange", (() => {
                a && t.params.cssMode && l(t.params.history.key, t.activeIndex)
            }))
        }, function({
            swiper: t,
            extendParams: e,
            emit: i,
            on: a
        }) {
            let s = !1;
            const r = n(),
                l = o();
            e({
                hashNavigation: {
                    enabled: !1,
                    replaceState: !1,
                    watchState: !1
                }
            });
            const c = () => {
                    i("hashChange");
                    const e = r.location.hash.replace("#", "");
                    if (e !== t.slides.eq(t.activeIndex).attr("data-hash")) {
                        const i = t.$wrapperEl.children(`.${t.params.slideClass}[data-hash="${e}"]`).index();
                        if (void 0 === i) return;
                        t.slideTo(i)
                    }
                },
                h = () => {
                    if (s && t.params.hashNavigation.enabled)
                        if (t.params.hashNavigation.replaceState && l.history && l.history.replaceState) l.history.replaceState(null, null, `#${t.slides.eq(t.activeIndex).attr("data-hash")}` || ""), i("hashSet");
                        else {
                            const e = t.slides.eq(t.activeIndex),
                                a = e.attr("data-hash") || e.attr("data-history");
                            r.location.hash = a || "", i("hashSet")
                        }
                };
            a("init", (() => {
                t.params.hashNavigation.enabled && (() => {
                    if (!t.params.hashNavigation.enabled || t.params.history && t.params.history.enabled) return;
                    s = !0;
                    const e = r.location.hash.replace("#", "");
                    if (e) {
                        const i = 0;
                        for (let a = 0, s = t.slides.length; a < s; a += 1) {
                            const s = t.slides.eq(a);
                            if ((s.attr("data-hash") || s.attr("data-history")) === e && !s.hasClass(t.params.slideDuplicateClass)) {
                                const e = s.index();
                                t.slideTo(e, i, t.params.runCallbacksOnInit, !0)
                            }
                        }
                    }
                    t.params.hashNavigation.watchState && f(l).on("hashchange", c)
                })()
            })), a("destroy", (() => {
                t.params.hashNavigation.enabled && t.params.hashNavigation.watchState && f(l).off("hashchange", c)
            })), a("transitionEnd _freeModeNoMomentumRelease", (() => {
                s && h()
            })), a("slideChange", (() => {
                s && t.params.cssMode && h()
            }))
        }, function({
            swiper: t,
            extendParams: e,
            on: i,
            emit: a
        }) {
            let s;

            function r() {
                if (!t.size) return t.autoplay.running = !1, void(t.autoplay.paused = !1);
                const e = t.slides.eq(t.activeIndex);
                let i = t.params.autoplay.delay;
                e.attr("data-swiper-autoplay") && (i = e.attr("data-swiper-autoplay") || t.params.autoplay.delay), clearTimeout(s), s = m((() => {
                    let e;
                    t.params.autoplay.reverseDirection ? t.params.loop ? (t.loopFix(), e = t.slidePrev(t.params.speed, !0, !0), a("autoplay")) : t.isBeginning ? t.params.autoplay.stopOnLastSlide ? l() : (e = t.slideTo(t.slides.length - 1, t.params.speed, !0, !0), a("autoplay")) : (e = t.slidePrev(t.params.speed, !0, !0), a("autoplay")) : t.params.loop ? (t.loopFix(), e = t.slideNext(t.params.speed, !0, !0), a("autoplay")) : t.isEnd ? t.params.autoplay.stopOnLastSlide ? l() : (e = t.slideTo(0, t.params.speed, !0, !0), a("autoplay")) : (e = t.slideNext(t.params.speed, !0, !0), a("autoplay")), (t.params.cssMode && t.autoplay.running || !1 === e) && r()
                }), i)
            }

            function o() {
                return void 0 === s && (!t.autoplay.running && (t.autoplay.running = !0, a("autoplayStart"), r(), !0))
            }

            function l() {
                return !!t.autoplay.running && (void 0 !== s && (s && (clearTimeout(s), s = void 0), t.autoplay.running = !1, a("autoplayStop"), !0))
            }

            function c(e) {
                t.autoplay.running && (t.autoplay.paused || (s && clearTimeout(s), t.autoplay.paused = !0, 0 !== e && t.params.autoplay.waitForTransition ? ["transitionend", "webkitTransitionEnd"].forEach((e => {
                    t.$wrapperEl[0].addEventListener(e, d)
                })) : (t.autoplay.paused = !1, r())))
            }

            function h() {
                const e = n();
                "hidden" === e.visibilityState && t.autoplay.running && c(), "visible" === e.visibilityState && t.autoplay.paused && (r(), t.autoplay.paused = !1)
            }

            function d(e) {
                t && !t.destroyed && t.$wrapperEl && e.target === t.$wrapperEl[0] && (["transitionend", "webkitTransitionEnd"].forEach((e => {
                    t.$wrapperEl[0].removeEventListener(e, d)
                })), t.autoplay.paused = !1, t.autoplay.running ? r() : l())
            }

            function u() {
                t.params.autoplay.disableOnInteraction ? l() : (a("autoplayPause"), c()), ["transitionend", "webkitTransitionEnd"].forEach((e => {
                    t.$wrapperEl[0].removeEventListener(e, d)
                }))
            }

            function p() {
                t.params.autoplay.disableOnInteraction || (t.autoplay.paused = !1, a("autoplayResume"), r())
            }
            t.autoplay = {
                running: !1,
                paused: !1
            }, e({
                autoplay: {
                    enabled: !1,
                    delay: 3e3,
                    waitForTransition: !0,
                    disableOnInteraction: !0,
                    stopOnLastSlide: !1,
                    reverseDirection: !1,
                    pauseOnMouseEnter: !1
                }
            }), i("init", (() => {
                if (t.params.autoplay.enabled) {
                    o();
                    n().addEventListener("visibilitychange", h), t.params.autoplay.pauseOnMouseEnter && (t.$el.on("mouseenter", u), t.$el.on("mouseleave", p))
                }
            })), i("beforeTransitionStart", ((e, i, a) => {
                t.autoplay.running && (a || !t.params.autoplay.disableOnInteraction ? t.autoplay.pause(i) : l())
            })), i("sliderFirstMove", (() => {
                t.autoplay.running && (t.params.autoplay.disableOnInteraction ? l() : c())
            })), i("touchEnd", (() => {
                t.params.cssMode && t.autoplay.paused && !t.params.autoplay.disableOnInteraction && r()
            })), i("destroy", (() => {
                t.$el.off("mouseenter", u), t.$el.off("mouseleave", p), t.autoplay.running && l();
                n().removeEventListener("visibilitychange", h)
            })), Object.assign(t.autoplay, {
                pause: c,
                run: r,
                start: o,
                stop: l
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                thumbs: {
                    swiper: null,
                    multipleActiveThumbs: !0,
                    autoScrollOffset: 0,
                    slideThumbActiveClass: "swiper-slide-thumb-active",
                    thumbsContainerClass: "swiper-thumbs"
                }
            });
            let a = !1,
                s = !1;

            function n() {
                const e = t.thumbs.swiper;
                if (!e || e.destroyed) return;
                const i = e.clickedIndex,
                    a = e.clickedSlide;
                if (a && f(a).hasClass(t.params.thumbs.slideThumbActiveClass)) return;
                if (null == i) return;
                let s;
                if (s = e.params.loop ? parseInt(f(e.clickedSlide).attr("data-swiper-slide-index"), 10) : i, t.params.loop) {
                    let e = t.activeIndex;
                    t.slides.eq(e).hasClass(t.params.slideDuplicateClass) && (t.loopFix(), t._clientLeft = t.$wrapperEl[0].clientLeft, e = t.activeIndex);
                    const i = t.slides.eq(e).prevAll(`[data-swiper-slide-index="${s}"]`).eq(0).index(),
                        a = t.slides.eq(e).nextAll(`[data-swiper-slide-index="${s}"]`).eq(0).index();
                    s = void 0 === i ? a : void 0 === a ? i : a - e < e - i ? a : i
                }
                t.slideTo(s)
            }

            function r() {
                const {
                    thumbs: e
                } = t.params;
                if (a) return !1;
                a = !0;
                const i = t.constructor;
                if (e.swiper instanceof i) t.thumbs.swiper = e.swiper, Object.assign(t.thumbs.swiper.originalParams, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                }), Object.assign(t.thumbs.swiper.params, {
                    watchSlidesProgress: !0,
                    slideToClickedSlide: !1
                });
                else if (b(e.swiper)) {
                    const a = Object.assign({}, e.swiper);
                    Object.assign(a, {
                        watchSlidesProgress: !0,
                        slideToClickedSlide: !1
                    }), t.thumbs.swiper = new i(a), s = !0
                }
                return t.thumbs.swiper.$el.addClass(t.params.thumbs.thumbsContainerClass), t.thumbs.swiper.on("tap", n), !0
            }

            function o(e) {
                const i = t.thumbs.swiper;
                if (!i || i.destroyed) return;
                const a = "auto" === i.params.slidesPerView ? i.slidesPerViewDynamic() : i.params.slidesPerView;
                let s = 1;
                const n = t.params.thumbs.slideThumbActiveClass;
                if (t.params.slidesPerView > 1 && !t.params.centeredSlides && (s = t.params.slidesPerView), t.params.thumbs.multipleActiveThumbs || (s = 1), s = Math.floor(s), i.slides.removeClass(n), i.params.loop || i.params.virtual && i.params.virtual.enabled)
                    for (let e = 0; e < s; e += 1) i.$wrapperEl.children(`[data-swiper-slide-index="${t.realIndex+e}"]`).addClass(n);
                else
                    for (let e = 0; e < s; e += 1) i.slides.eq(t.realIndex + e).addClass(n);
                const r = t.params.thumbs.autoScrollOffset,
                    o = r && !i.params.loop;
                if (t.realIndex !== i.realIndex || o) {
                    let s, n, l = i.activeIndex;
                    if (i.params.loop) {
                        i.slides.eq(l).hasClass(i.params.slideDuplicateClass) && (i.loopFix(), i._clientLeft = i.$wrapperEl[0].clientLeft, l = i.activeIndex);
                        const e = i.slides.eq(l).prevAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index(),
                            a = i.slides.eq(l).nextAll(`[data-swiper-slide-index="${t.realIndex}"]`).eq(0).index();
                        s = void 0 === e ? a : void 0 === a ? e : a - l == l - e ? i.params.slidesPerGroup > 1 ? a : l : a - l < l - e ? a : e, n = t.activeIndex > t.previousIndex ? "next" : "prev"
                    } else s = t.realIndex, n = s > t.previousIndex ? "next" : "prev";
                    o && (s += "next" === n ? r : -1 * r), i.visibleSlidesIndexes && i.visibleSlidesIndexes.indexOf(s) < 0 && (i.params.centeredSlides ? s = s > l ? s - Math.floor(a / 2) + 1 : s + Math.floor(a / 2) - 1 : s > l && i.params.slidesPerGroup, i.slideTo(s, e ? 0 : void 0))
                }
            }
            t.thumbs = {
                swiper: null
            }, i("beforeInit", (() => {
                const {
                    thumbs: e
                } = t.params;
                e && e.swiper && (r(), o(!0))
            })), i("slideChange update resize observerUpdate", (() => {
                o()
            })), i("setTransition", ((e, i) => {
                const a = t.thumbs.swiper;
                a && !a.destroyed && a.setTransition(i)
            })), i("beforeDestroy", (() => {
                const e = t.thumbs.swiper;
                e && !e.destroyed && s && e.destroy()
            })), Object.assign(t.thumbs, {
                init: r,
                update: o
            })
        }, function({
            swiper: t,
            extendParams: e,
            emit: i,
            once: a
        }) {
            e({
                freeMode: {
                    enabled: !1,
                    momentum: !0,
                    momentumRatio: 1,
                    momentumBounce: !0,
                    momentumBounceRatio: 1,
                    momentumVelocityRatio: 1,
                    sticky: !1,
                    minimumVelocity: .02
                }
            }), Object.assign(t, {
                freeMode: {
                    onTouchStart: function() {
                        const e = t.getTranslate();
                        t.setTranslate(e), t.setTransition(0), t.touchEventsData.velocities.length = 0, t.freeMode.onTouchEnd({
                            currentPos: t.rtl ? t.translate : -t.translate
                        })
                    },
                    onTouchMove: function() {
                        const {
                            touchEventsData: e,
                            touches: i
                        } = t;
                        0 === e.velocities.length && e.velocities.push({
                            position: i[t.isHorizontal() ? "startX" : "startY"],
                            time: e.touchStartTime
                        }), e.velocities.push({
                            position: i[t.isHorizontal() ? "currentX" : "currentY"],
                            time: x()
                        })
                    },
                    onTouchEnd: function({
                        currentPos: e
                    }) {
                        const {
                            params: s,
                            $wrapperEl: n,
                            rtlTranslate: r,
                            snapGrid: o,
                            touchEventsData: l
                        } = t, c = x() - l.touchStartTime;
                        if (e < -t.minTranslate()) t.slideTo(t.activeIndex);
                        else if (e > -t.maxTranslate()) t.slides.length < o.length ? t.slideTo(o.length - 1) : t.slideTo(t.slides.length - 1);
                        else {
                            if (s.freeMode.momentum) {
                                if (l.velocities.length > 1) {
                                    const e = l.velocities.pop(),
                                        i = l.velocities.pop(),
                                        a = e.position - i.position,
                                        n = e.time - i.time;
                                    t.velocity = a / n, t.velocity /= 2, Math.abs(t.velocity) < s.freeMode.minimumVelocity && (t.velocity = 0), (n > 150 || x() - e.time > 300) && (t.velocity = 0)
                                } else t.velocity = 0;
                                t.velocity *= s.freeMode.momentumVelocityRatio, l.velocities.length = 0;
                                let e = 1e3 * s.freeMode.momentumRatio;
                                const c = t.velocity * e;
                                let h = t.translate + c;
                                r && (h = -h);
                                let d, u = !1;
                                const p = 20 * Math.abs(t.velocity) * s.freeMode.momentumBounceRatio;
                                let g;
                                if (h < t.maxTranslate()) s.freeMode.momentumBounce ? (h + t.maxTranslate() < -p && (h = t.maxTranslate() - p), d = t.maxTranslate(), u = !0, l.allowMomentumBounce = !0) : h = t.maxTranslate(), s.loop && s.centeredSlides && (g = !0);
                                else if (h > t.minTranslate()) s.freeMode.momentumBounce ? (h - t.minTranslate() > p && (h = t.minTranslate() + p), d = t.minTranslate(), u = !0, l.allowMomentumBounce = !0) : h = t.minTranslate(), s.loop && s.centeredSlides && (g = !0);
                                else if (s.freeMode.sticky) {
                                    let e;
                                    for (let t = 0; t < o.length; t += 1)
                                        if (o[t] > -h) {
                                            e = t;
                                            break
                                        }
                                    h = Math.abs(o[e] - h) < Math.abs(o[e - 1] - h) || "next" === t.swipeDirection ? o[e] : o[e - 1], h = -h
                                }
                                if (g && a("transitionEnd", (() => {
                                        t.loopFix()
                                    })), 0 !== t.velocity) {
                                    if (e = r ? Math.abs((-h - t.translate) / t.velocity) : Math.abs((h - t.translate) / t.velocity), s.freeMode.sticky) {
                                        const i = Math.abs((r ? -h : h) - t.translate),
                                            a = t.slidesSizesGrid[t.activeIndex];
                                        e = i < a ? s.speed : i < 2 * a ? 1.5 * s.speed : 2.5 * s.speed
                                    }
                                } else if (s.freeMode.sticky) return void t.slideToClosest();
                                s.freeMode.momentumBounce && u ? (t.updateProgress(d), t.setTransition(e), t.setTranslate(h), t.transitionStart(!0, t.swipeDirection), t.animating = !0, n.transitionEnd((() => {
                                    t && !t.destroyed && l.allowMomentumBounce && (i("momentumBounce"), t.setTransition(s.speed), setTimeout((() => {
                                        t.setTranslate(d), n.transitionEnd((() => {
                                            t && !t.destroyed && t.transitionEnd()
                                        }))
                                    }), 0))
                                }))) : t.velocity ? (i("_freeModeNoMomentumRelease"), t.updateProgress(h), t.setTransition(e), t.setTranslate(h), t.transitionStart(!0, t.swipeDirection), t.animating || (t.animating = !0, n.transitionEnd((() => {
                                    t && !t.destroyed && t.transitionEnd()
                                })))) : t.updateProgress(h), t.updateActiveIndex(), t.updateSlidesClasses()
                            } else {
                                if (s.freeMode.sticky) return void t.slideToClosest();
                                s.freeMode && i("_freeModeNoMomentumRelease")
                            }(!s.freeMode.momentum || c >= s.longSwipesMs) && (t.updateProgress(), t.updateActiveIndex(), t.updateSlidesClasses())
                        }
                    }
                }
            })
        }, function({
            swiper: t,
            extendParams: e
        }) {
            let i, a, s;
            e({
                grid: {
                    rows: 1,
                    fill: "column"
                }
            }), t.grid = {
                initSlides: e => {
                    const {
                        slidesPerView: n
                    } = t.params, {
                        rows: r,
                        fill: o
                    } = t.params.grid;
                    a = i / r, s = Math.floor(e / r), i = Math.floor(e / r) === e / r ? e : Math.ceil(e / r) * r, "auto" !== n && "row" === o && (i = Math.max(i, n * r))
                },
                updateSlide: (e, n, r, o) => {
                    const {
                        slidesPerGroup: l,
                        spaceBetween: c
                    } = t.params, {
                        rows: h,
                        fill: d
                    } = t.params.grid;
                    let u, p, g;
                    if ("row" === d && l > 1) {
                        const t = Math.floor(e / (l * h)),
                            a = e - h * l * t,
                            s = 0 === t ? l : Math.min(Math.ceil((r - t * h * l) / h), l);
                        g = Math.floor(a / s), p = a - g * s + t * l, u = p + g * i / h, n.css({
                            "-webkit-order": u,
                            order: u
                        })
                    } else "column" === d ? (p = Math.floor(e / h), g = e - p * h, (p > s || p === s && g === h - 1) && (g += 1, g >= h && (g = 0, p += 1))) : (g = Math.floor(e / a), p = e - g * a);
                    n.css(o("margin-top"), 0 !== g ? c && `${c}px` : "")
                },
                updateWrapperSize: (e, a, s) => {
                    const {
                        spaceBetween: n,
                        centeredSlides: r,
                        roundLengths: o
                    } = t.params, {
                        rows: l
                    } = t.params.grid;
                    if (t.virtualSize = (e + n) * i, t.virtualSize = Math.ceil(t.virtualSize / l) - n, t.$wrapperEl.css({
                            [s("width")]: `${t.virtualSize+n}px`
                        }), r) {
                        a.splice(0, a.length);
                        const e = [];
                        for (let i = 0; i < a.length; i += 1) {
                            let s = a[i];
                            o && (s = Math.floor(s)), a[i] < t.virtualSize + a[0] && e.push(s)
                        }
                        a.push(...e)
                    }
                }
            }
        }, function({
            swiper: t
        }) {
            Object.assign(t, {
                appendSlide: at.bind(t),
                prependSlide: st.bind(t),
                addSlide: nt.bind(t),
                removeSlide: rt.bind(t),
                removeAllSlides: ot.bind(t)
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                fadeEffect: {
                    crossFade: !1,
                    transformEl: null
                }
            }), lt({
                effect: "fade",
                swiper: t,
                on: i,
                setTranslate: () => {
                    const {
                        slides: e
                    } = t, i = t.params.fadeEffect;
                    for (let a = 0; a < e.length; a += 1) {
                        const e = t.slides.eq(a);
                        let s = -e[0].swiperSlideOffset;
                        t.params.virtualTranslate || (s -= t.translate);
                        let n = 0;
                        t.isHorizontal() || (n = s, s = 0);
                        const r = t.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(e[0].progress), 0) : 1 + Math.min(Math.max(e[0].progress, -1), 0);
                        ct(i, e).css({
                            opacity: r
                        }).transform(`translate3d(${s}px, ${n}px, 0px)`)
                    }
                },
                setTransition: e => {
                    const {
                        transformEl: i
                    } = t.params.fadeEffect;
                    (i ? t.slides.find(i) : t.slides).transition(e), ht({
                        swiper: t,
                        duration: e,
                        transformEl: i,
                        allSlides: !0
                    })
                },
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    spaceBetween: 0,
                    virtualTranslate: !t.params.cssMode
                })
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                cubeEffect: {
                    slideShadows: !0,
                    shadow: !0,
                    shadowOffset: 20,
                    shadowScale: .94
                }
            });
            const a = (t, e, i) => {
                let a = i ? t.find(".swiper-slide-shadow-left") : t.find(".swiper-slide-shadow-top"),
                    s = i ? t.find(".swiper-slide-shadow-right") : t.find(".swiper-slide-shadow-bottom");
                0 === a.length && (a = f(`<div class="swiper-slide-shadow-${i?"left":"top"}"></div>`), t.append(a)), 0 === s.length && (s = f(`<div class="swiper-slide-shadow-${i?"right":"bottom"}"></div>`), t.append(s)), a.length && (a[0].style.opacity = Math.max(-e, 0)), s.length && (s[0].style.opacity = Math.max(e, 0))
            };
            lt({
                effect: "cube",
                swiper: t,
                on: i,
                setTranslate: () => {
                    const {
                        $el: e,
                        $wrapperEl: i,
                        slides: s,
                        width: n,
                        height: r,
                        rtlTranslate: o,
                        size: l,
                        browser: c
                    } = t, h = t.params.cubeEffect, d = t.isHorizontal(), u = t.virtual && t.params.virtual.enabled;
                    let p, g = 0;
                    h.shadow && (d ? (p = i.find(".swiper-cube-shadow"), 0 === p.length && (p = f('<div class="swiper-cube-shadow"></div>'), i.append(p)), p.css({
                        height: `${n}px`
                    })) : (p = e.find(".swiper-cube-shadow"), 0 === p.length && (p = f('<div class="swiper-cube-shadow"></div>'), e.append(p))));
                    for (let t = 0; t < s.length; t += 1) {
                        const e = s.eq(t);
                        let i = t;
                        u && (i = parseInt(e.attr("data-swiper-slide-index"), 10));
                        let n = 90 * i,
                            r = Math.floor(n / 360);
                        o && (n = -n, r = Math.floor(-n / 360));
                        const c = Math.max(Math.min(e[0].progress, 1), -1);
                        let p = 0,
                            f = 0,
                            m = 0;
                        i % 4 == 0 ? (p = 4 * -r * l, m = 0) : (i - 1) % 4 == 0 ? (p = 0, m = 4 * -r * l) : (i - 2) % 4 == 0 ? (p = l + 4 * r * l, m = l) : (i - 3) % 4 == 0 && (p = -l, m = 3 * l + 4 * l * r), o && (p = -p), d || (f = p, p = 0);
                        const x = `rotateX(${d?0:-n}deg) rotateY(${d?n:0}deg) translate3d(${p}px, ${f}px, ${m}px)`;
                        c <= 1 && c > -1 && (g = 90 * i + 90 * c, o && (g = 90 * -i - 90 * c)), e.transform(x), h.slideShadows && a(e, c, d)
                    }
                    if (i.css({
                            "-webkit-transform-origin": `50% 50% -${l/2}px`,
                            "transform-origin": `50% 50% -${l/2}px`
                        }), h.shadow)
                        if (d) p.transform(`translate3d(0px, ${n/2+h.shadowOffset}px, ${-n/2}px) rotateX(90deg) rotateZ(0deg) scale(${h.shadowScale})`);
                        else {
                            const t = Math.abs(g) - 90 * Math.floor(Math.abs(g) / 90),
                                e = 1.5 - (Math.sin(2 * t * Math.PI / 360) / 2 + Math.cos(2 * t * Math.PI / 360) / 2),
                                i = h.shadowScale,
                                a = h.shadowScale / e,
                                s = h.shadowOffset;
                            p.transform(`scale3d(${i}, 1, ${a}) translate3d(0px, ${r/2+s}px, ${-r/2/a}px) rotateX(-90deg)`)
                        }
                    const m = c.isSafari || c.isWebView ? -l / 2 : 0;
                    i.transform(`translate3d(0px,0,${m}px) rotateX(${t.isHorizontal()?0:g}deg) rotateY(${t.isHorizontal()?-g:0}deg)`), i[0].style.setProperty("--swiper-cube-translate-z", `${m}px`)
                },
                setTransition: e => {
                    const {
                        $el: i,
                        slides: a
                    } = t;
                    a.transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), t.params.cubeEffect.shadow && !t.isHorizontal() && i.find(".swiper-cube-shadow").transition(e)
                },
                recreateShadows: () => {
                    const e = t.isHorizontal();
                    t.slides.each((t => {
                        const i = Math.max(Math.min(t.progress, 1), -1);
                        a(f(t), i, e)
                    }))
                },
                getEffectParams: () => t.params.cubeEffect,
                perspective: () => !0,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    resistanceRatio: 0,
                    spaceBetween: 0,
                    centeredSlides: !1,
                    virtualTranslate: !0
                })
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                flipEffect: {
                    slideShadows: !0,
                    limitRotation: !0,
                    transformEl: null
                }
            });
            const a = (e, i, a) => {
                let s = t.isHorizontal() ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
                    n = t.isHorizontal() ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
                0 === s.length && (s = dt(a, e, t.isHorizontal() ? "left" : "top")), 0 === n.length && (n = dt(a, e, t.isHorizontal() ? "right" : "bottom")), s.length && (s[0].style.opacity = Math.max(-i, 0)), n.length && (n[0].style.opacity = Math.max(i, 0))
            };
            lt({
                effect: "flip",
                swiper: t,
                on: i,
                setTranslate: () => {
                    const {
                        slides: e,
                        rtlTranslate: i
                    } = t, s = t.params.flipEffect;
                    for (let n = 0; n < e.length; n += 1) {
                        const r = e.eq(n);
                        let o = r[0].progress;
                        t.params.flipEffect.limitRotation && (o = Math.max(Math.min(r[0].progress, 1), -1));
                        const l = r[0].swiperSlideOffset;
                        let c = -180 * o,
                            h = 0,
                            d = t.params.cssMode ? -l - t.translate : -l,
                            u = 0;
                        t.isHorizontal() ? i && (c = -c) : (u = d, d = 0, h = -c, c = 0), r[0].style.zIndex = -Math.abs(Math.round(o)) + e.length, s.slideShadows && a(r, o, s);
                        const p = `translate3d(${d}px, ${u}px, 0px) rotateX(${h}deg) rotateY(${c}deg)`;
                        ct(s, r).transform(p)
                    }
                },
                setTransition: e => {
                    const {
                        transformEl: i
                    } = t.params.flipEffect;
                    (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e), ht({
                        swiper: t,
                        duration: e,
                        transformEl: i
                    })
                },
                recreateShadows: () => {
                    const e = t.params.flipEffect;
                    t.slides.each((i => {
                        const s = f(i);
                        let n = s[0].progress;
                        t.params.flipEffect.limitRotation && (n = Math.max(Math.min(i.progress, 1), -1)), a(s, n, e)
                    }))
                },
                getEffectParams: () => t.params.flipEffect,
                perspective: () => !0,
                overwriteParams: () => ({
                    slidesPerView: 1,
                    slidesPerGroup: 1,
                    watchSlidesProgress: !0,
                    spaceBetween: 0,
                    virtualTranslate: !t.params.cssMode
                })
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                coverflowEffect: {
                    rotate: 50,
                    stretch: 0,
                    depth: 100,
                    scale: 1,
                    modifier: 1,
                    slideShadows: !0,
                    transformEl: null
                }
            }), lt({
                effect: "coverflow",
                swiper: t,
                on: i,
                setTranslate: () => {
                    const {
                        width: e,
                        height: i,
                        slides: a,
                        slidesSizesGrid: s
                    } = t, n = t.params.coverflowEffect, r = t.isHorizontal(), o = t.translate, l = r ? e / 2 - o : i / 2 - o, c = r ? n.rotate : -n.rotate, h = n.depth;
                    for (let t = 0, e = a.length; t < e; t += 1) {
                        const e = a.eq(t),
                            i = s[t],
                            o = (l - e[0].swiperSlideOffset - i / 2) / i,
                            d = "function" == typeof n.modifier ? n.modifier(o) : o * n.modifier;
                        let u = r ? c * d : 0,
                            p = r ? 0 : c * d,
                            g = -h * Math.abs(d),
                            f = n.stretch;
                        "string" == typeof f && -1 !== f.indexOf("%") && (f = parseFloat(n.stretch) / 100 * i);
                        let m = r ? 0 : f * d,
                            x = r ? f * d : 0,
                            v = 1 - (1 - n.scale) * Math.abs(d);
                        Math.abs(x) < .001 && (x = 0), Math.abs(m) < .001 && (m = 0), Math.abs(g) < .001 && (g = 0), Math.abs(u) < .001 && (u = 0), Math.abs(p) < .001 && (p = 0), Math.abs(v) < .001 && (v = 0);
                        const b = `translate3d(${x}px,${m}px,${g}px)  rotateX(${p}deg) rotateY(${u}deg) scale(${v})`;
                        if (ct(n, e).transform(b), e[0].style.zIndex = 1 - Math.abs(Math.round(d)), n.slideShadows) {
                            let t = r ? e.find(".swiper-slide-shadow-left") : e.find(".swiper-slide-shadow-top"),
                                i = r ? e.find(".swiper-slide-shadow-right") : e.find(".swiper-slide-shadow-bottom");
                            0 === t.length && (t = dt(n, e, r ? "left" : "top")), 0 === i.length && (i = dt(n, e, r ? "right" : "bottom")), t.length && (t[0].style.opacity = d > 0 ? d : 0), i.length && (i[0].style.opacity = -d > 0 ? -d : 0)
                        }
                    }
                },
                setTransition: e => {
                    const {
                        transformEl: i
                    } = t.params.coverflowEffect;
                    (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(e)
                },
                perspective: () => !0,
                overwriteParams: () => ({
                    watchSlidesProgress: !0
                })
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                creativeEffect: {
                    transformEl: null,
                    limitProgress: 1,
                    shadowPerProgress: !1,
                    progressMultiplier: 1,
                    perspective: !0,
                    prev: {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        opacity: 1,
                        scale: 1
                    },
                    next: {
                        translate: [0, 0, 0],
                        rotate: [0, 0, 0],
                        opacity: 1,
                        scale: 1
                    }
                }
            });
            const a = t => "string" == typeof t ? t : `${t}px`;
            lt({
                effect: "creative",
                swiper: t,
                on: i,
                setTranslate: () => {
                    const {
                        slides: e,
                        $wrapperEl: i,
                        slidesSizesGrid: s
                    } = t, n = t.params.creativeEffect, {
                        progressMultiplier: r
                    } = n, o = t.params.centeredSlides;
                    if (o) {
                        const e = s[0] / 2 - t.params.slidesOffsetBefore || 0;
                        i.transform(`translateX(calc(50% - ${e}px))`)
                    }
                    for (let i = 0; i < e.length; i += 1) {
                        const s = e.eq(i),
                            l = s[0].progress,
                            c = Math.min(Math.max(s[0].progress, -n.limitProgress), n.limitProgress);
                        let h = c;
                        o || (h = Math.min(Math.max(s[0].originalProgress, -n.limitProgress), n.limitProgress));
                        const d = s[0].swiperSlideOffset,
                            u = [t.params.cssMode ? -d - t.translate : -d, 0, 0],
                            p = [0, 0, 0];
                        let g = !1;
                        t.isHorizontal() || (u[1] = u[0], u[0] = 0);
                        let f = {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            scale: 1,
                            opacity: 1
                        };
                        c < 0 ? (f = n.next, g = !0) : c > 0 && (f = n.prev, g = !0), u.forEach(((t, e) => {
                            u[e] = `calc(${t}px + (${a(f.translate[e])} * ${Math.abs(c*r)}))`
                        })), p.forEach(((t, e) => {
                            p[e] = f.rotate[e] * Math.abs(c * r)
                        })), s[0].style.zIndex = -Math.abs(Math.round(l)) + e.length;
                        const m = u.join(", "),
                            x = `rotateX(${p[0]}deg) rotateY(${p[1]}deg) rotateZ(${p[2]}deg)`,
                            v = h < 0 ? `scale(${1+(1-f.scale)*h*r})` : `scale(${1-(1-f.scale)*h*r})`,
                            b = h < 0 ? 1 + (1 - f.opacity) * h * r : 1 - (1 - f.opacity) * h * r,
                            y = `translate3d(${m}) ${x} ${v}`;
                        if (g && f.shadow || !g) {
                            let t = s.children(".swiper-slide-shadow");
                            if (0 === t.length && f.shadow && (t = dt(n, s)), t.length) {
                                const e = n.shadowPerProgress ? c * (1 / n.limitProgress) : c;
                                t[0].style.opacity = Math.min(Math.max(Math.abs(e), 0), 1)
                            }
                        }
                        const w = ct(n, s);
                        w.transform(y).css({
                            opacity: b
                        }), f.origin && w.css("transform-origin", f.origin)
                    }
                },
                setTransition: e => {
                    const {
                        transformEl: i
                    } = t.params.creativeEffect;
                    (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ht({
                        swiper: t,
                        duration: e,
                        transformEl: i,
                        allSlides: !0
                    })
                },
                perspective: () => t.params.creativeEffect.perspective,
                overwriteParams: () => ({
                    watchSlidesProgress: !0,
                    virtualTranslate: !t.params.cssMode
                })
            })
        }, function({
            swiper: t,
            extendParams: e,
            on: i
        }) {
            e({
                cardsEffect: {
                    slideShadows: !0,
                    transformEl: null,
                    rotate: !0,
                    perSlideRotate: 2,
                    perSlideOffset: 8
                }
            }), lt({
                effect: "cards",
                swiper: t,
                on: i,
                setTranslate: () => {
                    const {
                        slides: e,
                        activeIndex: i
                    } = t, a = t.params.cardsEffect, {
                        startTranslate: s,
                        isTouched: n
                    } = t.touchEventsData, r = t.translate;
                    for (let o = 0; o < e.length; o += 1) {
                        const l = e.eq(o),
                            c = l[0].progress,
                            h = Math.min(Math.max(c, -4), 4);
                        let d = l[0].swiperSlideOffset;
                        t.params.centeredSlides && !t.params.cssMode && t.$wrapperEl.transform(`translateX(${t.minTranslate()}px)`), t.params.centeredSlides && t.params.cssMode && (d -= e[0].swiperSlideOffset);
                        let u = t.params.cssMode ? -d - t.translate : -d,
                            p = 0;
                        const g = -100 * Math.abs(h);
                        let f = 1,
                            m = -a.perSlideRotate * h,
                            x = a.perSlideOffset - .75 * Math.abs(h);
                        const v = t.virtual && t.params.virtual.enabled ? t.virtual.from + o : o,
                            b = (v === i || v === i - 1) && h > 0 && h < 1 && (n || t.params.cssMode) && r < s,
                            y = (v === i || v === i + 1) && h < 0 && h > -1 && (n || t.params.cssMode) && r > s;
                        if (b || y) {
                            const t = (1 - Math.abs((Math.abs(h) - .5) / .5)) ** .5;
                            m += -28 * h * t, f += -.5 * t, x += 96 * t, p = -25 * t * Math.abs(h) + "%"
                        }
                        if (u = h < 0 ? `calc(${u}px + (${x*Math.abs(h)}%))` : h > 0 ? `calc(${u}px + (-${x*Math.abs(h)}%))` : `${u}px`, !t.isHorizontal()) {
                            const t = p;
                            p = u, u = t
                        }
                        const w = h < 0 ? "" + (1 + (1 - f) * h) : "" + (1 - (1 - f) * h),
                            S = `\n        translate3d(${u}, ${p}, ${g}px)\n        rotateZ(${a.rotate?m:0}deg)\n        scale(${w})\n      `;
                        if (a.slideShadows) {
                            let t = l.find(".swiper-slide-shadow");
                            0 === t.length && (t = dt(a, l)), t.length && (t[0].style.opacity = Math.min(Math.max((Math.abs(h) - .5) / .5, 0), 1))
                        }
                        l[0].style.zIndex = -Math.abs(Math.round(c)) + e.length;
                        ct(a, l).transform(S)
                    }
                },
                setTransition: e => {
                    const {
                        transformEl: i
                    } = t.params.cardsEffect;
                    (i ? t.slides.find(i) : t.slides).transition(e).find(".swiper-slide-shadow").transition(e), ht({
                        swiper: t,
                        duration: e,
                        transformEl: i
                    })
                },
                perspective: () => !0,
                overwriteParams: () => ({
                    watchSlidesProgress: !0,
                    virtualTranslate: !t.params.cssMode
                })
            })
        }];

        function pt(t, e) {
            var i = Object.keys(t);
            if (Object.getOwnPropertySymbols) {
                var a = Object.getOwnPropertySymbols(t);
                e && (a = a.filter((function(e) {
                    return Object.getOwnPropertyDescriptor(t, e).enumerable
                }))), i.push.apply(i, a)
            }
            return i
        }

        function gt(t) {
            for (var e = 1; e < arguments.length; e++) {
                var i = null != arguments[e] ? arguments[e] : {};
                e % 2 ? pt(Object(i), !0).forEach((function(e) {
                    mt(t, e, i[e])
                })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(i)) : pt(Object(i)).forEach((function(e) {
                    Object.defineProperty(t, e, Object.getOwnPropertyDescriptor(i, e))
                }))
            }
            return t
        }

        function ft(t) {
            return ft = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t) {
                return typeof t
            } : function(t) {
                return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t
            }, ft(t)
        }

        function mt(t, e, i) {
            return e in t ? Object.defineProperty(t, e, {
                value: i,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }) : t[e] = i, t
        }

        function xt() {
            return xt = Object.assign || function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = arguments[e];
                    for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (t[a] = i[a])
                }
                return t
            }, xt.apply(this, arguments)
        }

        function vt(t, e) {
            if (null == t) return {};
            var i, a, s = function(t, e) {
                if (null == t) return {};
                var i, a, s = {},
                    n = Object.keys(t);
                for (a = 0; a < n.length; a++) i = n[a], e.indexOf(i) >= 0 || (s[i] = t[i]);
                return s
            }(t, e);
            if (Object.getOwnPropertySymbols) {
                var n = Object.getOwnPropertySymbols(t);
                for (a = 0; a < n.length; a++) i = n[a], e.indexOf(i) >= 0 || Object.prototype.propertyIsEnumerable.call(t, i) && (s[i] = t[i])
            }
            return s
        }
        tt.use(ut);

        function bt(t) {
            if ("undefined" != typeof window && window.navigator) return !!navigator.userAgent.match(t)
        }
        var yt = bt(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i),
            wt = bt(/Edge/i),
            St = bt(/firefox/i),
            Ct = bt(/safari/i) && !bt(/chrome/i) && !bt(/android/i),
            kt = bt(/iP(ad|od|hone)/i),
            At = bt(/chrome/i) && bt(/android/i),
            Et = {
                capture: !1,
                passive: !1
            };

        function Tt(t, e, i) {
            t.addEventListener(e, i, !yt && Et)
        }

        function Pt(t, e, i) {
            t.removeEventListener(e, i, !yt && Et)
        }

        function Mt(t, e) {
            if (e) {
                if (">" === e[0] && (e = e.substring(1)), t) try {
                    if (t.matches) return t.matches(e);
                    if (t.msMatchesSelector) return t.msMatchesSelector(e);
                    if (t.webkitMatchesSelector) return t.webkitMatchesSelector(e)
                } catch (t) {
                    return !1
                }
                return !1
            }
        }

        function Lt(t) {
            return t.host && t !== document && t.host.nodeType ? t.host : t.parentNode
        }

        function It(t, e, i, a) {
            if (t) {
                i = i || document;
                do {
                    if (null != e && (">" === e[0] ? t.parentNode === i && Mt(t, e) : Mt(t, e)) || a && t === i) return t;
                    if (t === i) break
                } while (t = Lt(t))
            }
            return null
        }
        var _t, zt = /\s+/g;

        function Dt(t, e, i) {
            if (t && e)
                if (t.classList) t.classList[i ? "add" : "remove"](e);
                else {
                    var a = (" " + t.className + " ").replace(zt, " ").replace(" " + e + " ", " ");
                    t.className = (a + (i ? " " + e : "")).replace(zt, " ")
                }
        }

        function Xt(t, e, i) {
            var a = t && t.style;
            if (a) {
                if (void 0 === i) return document.defaultView && document.defaultView.getComputedStyle ? i = document.defaultView.getComputedStyle(t, "") : t.currentStyle && (i = t.currentStyle), void 0 === e ? i : i[e];
                e in a || -1 !== e.indexOf("webkit") || (e = "-webkit-" + e), a[e] = i + ("string" == typeof i ? "" : "px")
            }
        }

        function Ot(t, e) {
            var i = "";
            if ("string" == typeof t) i = t;
            else
                do {
                    var a = Xt(t, "transform");
                    a && "none" !== a && (i = a + " " + i)
                } while (!e && (t = t.parentNode));
            var s = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
            return s && new s(i)
        }

        function Nt(t, e, i) {
            if (t) {
                var a = t.getElementsByTagName(e),
                    s = 0,
                    n = a.length;
                if (i)
                    for (; s < n; s++) i(a[s], s);
                return a
            }
            return []
        }

        function Yt() {
            var t = document.scrollingElement;
            return t || document.documentElement
        }

        function Ft(t, e, i, a, s) {
            if (t.getBoundingClientRect || t === window) {
                var n, r, o, l, c, h, d;
                if (t !== window && t.parentNode && t !== Yt() ? (r = (n = t.getBoundingClientRect()).top, o = n.left, l = n.bottom, c = n.right, h = n.height, d = n.width) : (r = 0, o = 0, l = window.innerHeight, c = window.innerWidth, h = window.innerHeight, d = window.innerWidth), (e || i) && t !== window && (s = s || t.parentNode, !yt))
                    do {
                        if (s && s.getBoundingClientRect && ("none" !== Xt(s, "transform") || i && "static" !== Xt(s, "position"))) {
                            var u = s.getBoundingClientRect();
                            r -= u.top + parseInt(Xt(s, "border-top-width")), o -= u.left + parseInt(Xt(s, "border-left-width")), l = r + n.height, c = o + n.width;
                            break
                        }
                    } while (s = s.parentNode);
                if (a && t !== window) {
                    var p = Ot(s || t),
                        g = p && p.a,
                        f = p && p.d;
                    p && (l = (r /= f) + (h /= f), c = (o /= g) + (d /= g))
                }
                return {
                    top: r,
                    left: o,
                    bottom: l,
                    right: c,
                    width: d,
                    height: h
                }
            }
        }

        function Rt(t, e, i) {
            for (var a = Gt(t, !0), s = Ft(t)[e]; a;) {
                var n = Ft(a)[i];
                if (!("top" === i || "left" === i ? s >= n : s <= n)) return a;
                if (a === Yt()) break;
                a = Gt(a, !1)
            }
            return !1
        }

        function Ht(t, e, i, a) {
            for (var s = 0, n = 0, r = t.children; n < r.length;) {
                if ("none" !== r[n].style.display && r[n] !== qe.ghost && (a || r[n] !== qe.dragged) && It(r[n], i.draggable, t, !1)) {
                    if (s === e) return r[n];
                    s++
                }
                n++
            }
            return null
        }

        function Wt(t, e) {
            for (var i = t.lastElementChild; i && (i === qe.ghost || "none" === Xt(i, "display") || e && !Mt(i, e));) i = i.previousElementSibling;
            return i || null
        }

        function Bt(t, e) {
            var i = 0;
            if (!t || !t.parentNode) return -1;
            for (; t = t.previousElementSibling;) "TEMPLATE" === t.nodeName.toUpperCase() || t === qe.clone || e && !Mt(t, e) || i++;
            return i
        }

        function $t(t) {
            var e = 0,
                i = 0,
                a = Yt();
            if (t)
                do {
                    var s = Ot(t),
                        n = s.a,
                        r = s.d;
                    e += t.scrollLeft * n, i += t.scrollTop * r
                } while (t !== a && (t = t.parentNode));
            return [e, i]
        }

        function Gt(t, e) {
            if (!t || !t.getBoundingClientRect) return Yt();
            var i = t,
                a = !1;
            do {
                if (i.clientWidth < i.scrollWidth || i.clientHeight < i.scrollHeight) {
                    var s = Xt(i);
                    if (i.clientWidth < i.scrollWidth && ("auto" == s.overflowX || "scroll" == s.overflowX) || i.clientHeight < i.scrollHeight && ("auto" == s.overflowY || "scroll" == s.overflowY)) {
                        if (!i.getBoundingClientRect || i === document.body) return Yt();
                        if (a || e) return i;
                        a = !0
                    }
                }
            } while (i = i.parentNode);
            return Yt()
        }

        function Vt(t, e) {
            return Math.round(t.top) === Math.round(e.top) && Math.round(t.left) === Math.round(e.left) && Math.round(t.height) === Math.round(e.height) && Math.round(t.width) === Math.round(e.width)
        }

        function jt(t, e) {
            return function() {
                if (!_t) {
                    var i = arguments,
                        a = this;
                    1 === i.length ? t.call(a, i[0]) : t.apply(a, i), _t = setTimeout((function() {
                        _t = void 0
                    }), e)
                }
            }
        }

        function Ut(t, e, i) {
            t.scrollLeft += e, t.scrollTop += i
        }

        function qt(t) {
            var e = window.Polymer,
                i = window.jQuery || window.Zepto;
            return e && e.dom ? e.dom(t).cloneNode(!0) : i ? i(t).clone(!0)[0] : t.cloneNode(!0)
        }
        var Zt = "Sortable" + (new Date).getTime();

        function Kt() {
            var t, e = [];
            return {
                captureAnimationState: function() {
                    (e = [], this.options.animation) && [].slice.call(this.el.children).forEach((function(t) {
                        if ("none" !== Xt(t, "display") && t !== qe.ghost) {
                            e.push({
                                target: t,
                                rect: Ft(t)
                            });
                            var i = gt({}, e[e.length - 1].rect);
                            if (t.thisAnimationDuration) {
                                var a = Ot(t, !0);
                                a && (i.top -= a.f, i.left -= a.e)
                            }
                            t.fromRect = i
                        }
                    }))
                },
                addAnimationState: function(t) {
                    e.push(t)
                },
                removeAnimationState: function(t) {
                    e.splice(function(t, e) {
                        for (var i in t)
                            if (t.hasOwnProperty(i))
                                for (var a in e)
                                    if (e.hasOwnProperty(a) && e[a] === t[i][a]) return Number(i);
                        return -1
                    }(e, {
                        target: t
                    }), 1)
                },
                animateAll: function(i) {
                    var a = this;
                    if (!this.options.animation) return clearTimeout(t), void("function" == typeof i && i());
                    var s = !1,
                        n = 0;
                    e.forEach((function(t) {
                        var e = 0,
                            i = t.target,
                            r = i.fromRect,
                            o = Ft(i),
                            l = i.prevFromRect,
                            c = i.prevToRect,
                            h = t.rect,
                            d = Ot(i, !0);
                        d && (o.top -= d.f, o.left -= d.e), i.toRect = o, i.thisAnimationDuration && Vt(l, o) && !Vt(r, o) && (h.top - o.top) / (h.left - o.left) == (r.top - o.top) / (r.left - o.left) && (e = function(t, e, i, a) {
                            return Math.sqrt(Math.pow(e.top - t.top, 2) + Math.pow(e.left - t.left, 2)) / Math.sqrt(Math.pow(e.top - i.top, 2) + Math.pow(e.left - i.left, 2)) * a.animation
                        }(h, l, c, a.options)), Vt(o, r) || (i.prevFromRect = r, i.prevToRect = o, e || (e = a.options.animation), a.animate(i, h, o, e)), e && (s = !0, n = Math.max(n, e), clearTimeout(i.animationResetTimer), i.animationResetTimer = setTimeout((function() {
                            i.animationTime = 0, i.prevFromRect = null, i.fromRect = null, i.prevToRect = null, i.thisAnimationDuration = null
                        }), e), i.thisAnimationDuration = e)
                    })), clearTimeout(t), s ? t = setTimeout((function() {
                        "function" == typeof i && i()
                    }), n) : "function" == typeof i && i(), e = []
                },
                animate: function(t, e, i, a) {
                    if (a) {
                        Xt(t, "transition", ""), Xt(t, "transform", "");
                        var s = Ot(this.el),
                            n = s && s.a,
                            r = s && s.d,
                            o = (e.left - i.left) / (n || 1),
                            l = (e.top - i.top) / (r || 1);
                        t.animatingX = !!o, t.animatingY = !!l, Xt(t, "transform", "translate3d(" + o + "px," + l + "px,0)"), this.forRepaintDummy = function(t) {
                            return t.offsetWidth
                        }(t), Xt(t, "transition", "transform " + a + "ms" + (this.options.easing ? " " + this.options.easing : "")), Xt(t, "transform", "translate3d(0,0,0)"), "number" == typeof t.animated && clearTimeout(t.animated), t.animated = setTimeout((function() {
                            Xt(t, "transition", ""), Xt(t, "transform", ""), t.animated = !1, t.animatingX = !1, t.animatingY = !1
                        }), a)
                    }
                }
            }
        }
        var Qt = [],
            Jt = {
                initializeByDefault: !0
            },
            te = {
                mount: function(t) {
                    for (var e in Jt) Jt.hasOwnProperty(e) && !(e in t) && (t[e] = Jt[e]);
                    Qt.forEach((function(e) {
                        if (e.pluginName === t.pluginName) throw "Sortable: Cannot mount plugin ".concat(t.pluginName, " more than once")
                    })), Qt.push(t)
                },
                pluginEvent: function(t, e, i) {
                    var a = this;
                    this.eventCanceled = !1, i.cancel = function() {
                        a.eventCanceled = !0
                    };
                    var s = t + "Global";
                    Qt.forEach((function(a) {
                        e[a.pluginName] && (e[a.pluginName][s] && e[a.pluginName][s](gt({
                            sortable: e
                        }, i)), e.options[a.pluginName] && e[a.pluginName][t] && e[a.pluginName][t](gt({
                            sortable: e
                        }, i)))
                    }))
                },
                initializePlugins: function(t, e, i, a) {
                    for (var s in Qt.forEach((function(a) {
                            var s = a.pluginName;
                            if (t.options[s] || a.initializeByDefault) {
                                var n = new a(t, e, t.options);
                                n.sortable = t, n.options = t.options, t[s] = n, xt(i, n.defaults)
                            }
                        })), t.options)
                        if (t.options.hasOwnProperty(s)) {
                            var n = this.modifyOption(t, s, t.options[s]);
                            void 0 !== n && (t.options[s] = n)
                        }
                },
                getEventProperties: function(t, e) {
                    var i = {};
                    return Qt.forEach((function(a) {
                        "function" == typeof a.eventProperties && xt(i, a.eventProperties.call(e[a.pluginName], t))
                    })), i
                },
                modifyOption: function(t, e, i) {
                    var a;
                    return Qt.forEach((function(s) {
                        t[s.pluginName] && s.optionListeners && "function" == typeof s.optionListeners[e] && (a = s.optionListeners[e].call(t[s.pluginName], i))
                    })), a
                }
            };

        function ee(t) {
            var e = t.sortable,
                i = t.rootEl,
                a = t.name,
                s = t.targetEl,
                n = t.cloneEl,
                r = t.toEl,
                o = t.fromEl,
                l = t.oldIndex,
                c = t.newIndex,
                h = t.oldDraggableIndex,
                d = t.newDraggableIndex,
                u = t.originalEvent,
                p = t.putSortable,
                g = t.extraEventProperties;
            if (e = e || i && i[Zt]) {
                var f, m = e.options,
                    x = "on" + a.charAt(0).toUpperCase() + a.substr(1);
                !window.CustomEvent || yt || wt ? (f = document.createEvent("Event")).initEvent(a, !0, !0) : f = new CustomEvent(a, {
                    bubbles: !0,
                    cancelable: !0
                }), f.to = r || i, f.from = o || i, f.item = s || i, f.clone = n, f.oldIndex = l, f.newIndex = c, f.oldDraggableIndex = h, f.newDraggableIndex = d, f.originalEvent = u, f.pullMode = p ? p.lastPutMode : void 0;
                var v = gt(gt({}, g), te.getEventProperties(a, e));
                for (var b in v) f[b] = v[b];
                i && i.dispatchEvent(f), m[x] && m[x].call(e, f)
            }
        }
        var ie = ["evt"],
            ae = function(t, e) {
                var i = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
                    a = i.evt,
                    s = vt(i, ie);
                te.pluginEvent.bind(qe)(t, e, gt({
                    dragEl: ne,
                    parentEl: re,
                    ghostEl: oe,
                    rootEl: le,
                    nextEl: ce,
                    lastDownEl: he,
                    cloneEl: de,
                    cloneHidden: ue,
                    dragStarted: Ae,
                    putSortable: ve,
                    activeSortable: qe.active,
                    originalEvent: a,
                    oldIndex: pe,
                    oldDraggableIndex: fe,
                    newIndex: ge,
                    newDraggableIndex: me,
                    hideGhostForTarget: Ge,
                    unhideGhostForTarget: Ve,
                    cloneNowHidden: function() {
                        ue = !0
                    },
                    cloneNowShown: function() {
                        ue = !1
                    },
                    dispatchSortableEvent: function(t) {
                        se({
                            sortable: e,
                            name: t,
                            originalEvent: a
                        })
                    }
                }, s))
            };

        function se(t) {
            ee(gt({
                putSortable: ve,
                cloneEl: de,
                targetEl: ne,
                rootEl: le,
                oldIndex: pe,
                oldDraggableIndex: fe,
                newIndex: ge,
                newDraggableIndex: me
            }, t))
        }
        var ne, re, oe, le, ce, he, de, ue, pe, ge, fe, me, xe, ve, be, ye, we, Se, Ce, ke, Ae, Ee, Te, Pe, Me, Le = !1,
            Ie = !1,
            _e = [],
            ze = !1,
            De = !1,
            Xe = [],
            Oe = !1,
            Ne = [],
            Ye = "undefined" != typeof document,
            Fe = kt,
            Re = wt || yt ? "cssFloat" : "float",
            He = Ye && !At && !kt && "draggable" in document.createElement("div"),
            We = function() {
                if (Ye) {
                    if (yt) return !1;
                    var t = document.createElement("x");
                    return t.style.cssText = "pointer-events:auto", "auto" === t.style.pointerEvents
                }
            }(),
            Be = function(t, e) {
                var i = Xt(t),
                    a = parseInt(i.width) - parseInt(i.paddingLeft) - parseInt(i.paddingRight) - parseInt(i.borderLeftWidth) - parseInt(i.borderRightWidth),
                    s = Ht(t, 0, e),
                    n = Ht(t, 1, e),
                    r = s && Xt(s),
                    o = n && Xt(n),
                    l = r && parseInt(r.marginLeft) + parseInt(r.marginRight) + Ft(s).width,
                    c = o && parseInt(o.marginLeft) + parseInt(o.marginRight) + Ft(n).width;
                if ("flex" === i.display) return "column" === i.flexDirection || "column-reverse" === i.flexDirection ? "vertical" : "horizontal";
                if ("grid" === i.display) return i.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
                if (s && r.float && "none" !== r.float) {
                    var h = "left" === r.float ? "left" : "right";
                    return !n || "both" !== o.clear && o.clear !== h ? "horizontal" : "vertical"
                }
                return s && ("block" === r.display || "flex" === r.display || "table" === r.display || "grid" === r.display || l >= a && "none" === i[Re] || n && "none" === i[Re] && l + c > a) ? "vertical" : "horizontal"
            },
            $e = function(t) {
                function e(t, i) {
                    return function(a, s, n, r) {
                        var o = a.options.group.name && s.options.group.name && a.options.group.name === s.options.group.name;
                        if (null == t && (i || o)) return !0;
                        if (null == t || !1 === t) return !1;
                        if (i && "clone" === t) return t;
                        if ("function" == typeof t) return e(t(a, s, n, r), i)(a, s, n, r);
                        var l = (i ? a : s).options.group.name;
                        return !0 === t || "string" == typeof t && t === l || t.join && t.indexOf(l) > -1
                    }
                }
                var i = {},
                    a = t.group;
                a && "object" == ft(a) || (a = {
                    name: a
                }), i.name = a.name, i.checkPull = e(a.pull, !0), i.checkPut = e(a.put), i.revertClone = a.revertClone, t.group = i
            },
            Ge = function() {
                !We && oe && Xt(oe, "display", "none")
            },
            Ve = function() {
                !We && oe && Xt(oe, "display", "")
            };
        Ye && !At && document.addEventListener("click", (function(t) {
            if (Ie) return t.preventDefault(), t.stopPropagation && t.stopPropagation(), t.stopImmediatePropagation && t.stopImmediatePropagation(), Ie = !1, !1
        }), !0);
        var je = function(t) {
                if (ne) {
                    var e = function(t, e) {
                        var i;
                        return _e.some((function(a) {
                            var s = a[Zt].options.emptyInsertThreshold;
                            if (s && !Wt(a)) {
                                var n = Ft(a),
                                    r = t >= n.left - s && t <= n.right + s,
                                    o = e >= n.top - s && e <= n.bottom + s;
                                return r && o ? i = a : void 0
                            }
                        })), i
                    }((t = t.touches ? t.touches[0] : t).clientX, t.clientY);
                    if (e) {
                        var i = {};
                        for (var a in t) t.hasOwnProperty(a) && (i[a] = t[a]);
                        i.target = i.rootEl = e, i.preventDefault = void 0, i.stopPropagation = void 0, e[Zt]._onDragOver(i)
                    }
                }
            },
            Ue = function(t) {
                ne && ne.parentNode[Zt]._isOutsideThisEl(t.target)
            };

        function qe(t, e) {
            if (!t || !t.nodeType || 1 !== t.nodeType) throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(t));
            this.el = t, this.options = e = xt({}, e), t[Zt] = this;
            var i = {
                group: null,
                sort: !0,
                disabled: !1,
                store: null,
                handle: null,
                draggable: /^[uo]l$/i.test(t.nodeName) ? ">li" : ">*",
                swapThreshold: 1,
                invertSwap: !1,
                invertedSwapThreshold: null,
                removeCloneOnHide: !0,
                direction: function() {
                    return Be(t, this.options)
                },
                ghostClass: "sortable-ghost",
                chosenClass: "sortable-chosen",
                dragClass: "sortable-drag",
                ignore: "a, img",
                filter: null,
                preventOnFilter: !0,
                animation: 0,
                easing: null,
                setData: function(t, e) {
                    t.setData("Text", e.textContent)
                },
                dropBubble: !1,
                dragoverBubble: !1,
                dataIdAttr: "data-id",
                delay: 0,
                delayOnTouchOnly: !1,
                touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
                forceFallback: !1,
                fallbackClass: "sortable-fallback",
                fallbackOnBody: !1,
                fallbackTolerance: 0,
                fallbackOffset: {
                    x: 0,
                    y: 0
                },
                supportPointer: !1 !== qe.supportPointer && "PointerEvent" in window && !Ct,
                emptyInsertThreshold: 5
            };
            for (var a in te.initializePlugins(this, t, i), i) !(a in e) && (e[a] = i[a]);
            for (var s in $e(e), this) "_" === s.charAt(0) && "function" == typeof this[s] && (this[s] = this[s].bind(this));
            this.nativeDraggable = !e.forceFallback && He, this.nativeDraggable && (this.options.touchStartThreshold = 1), e.supportPointer ? Tt(t, "pointerdown", this._onTapStart) : (Tt(t, "mousedown", this._onTapStart), Tt(t, "touchstart", this._onTapStart)), this.nativeDraggable && (Tt(t, "dragover", this), Tt(t, "dragenter", this)), _e.push(this.el), e.store && e.store.get && this.sort(e.store.get(this) || []), xt(this, Kt())
        }

        function Ze(t, e, i, a, s, n, r, o) {
            var l, c, h = t[Zt],
                d = h.options.onMove;
            return !window.CustomEvent || yt || wt ? (l = document.createEvent("Event")).initEvent("move", !0, !0) : l = new CustomEvent("move", {
                bubbles: !0,
                cancelable: !0
            }), l.to = e, l.from = t, l.dragged = i, l.draggedRect = a, l.related = s || e, l.relatedRect = n || Ft(e), l.willInsertAfter = o, l.originalEvent = r, t.dispatchEvent(l), d && (c = d.call(h, l, r)), c
        }

        function Ke(t) {
            t.draggable = !1
        }

        function Qe() {
            Oe = !1
        }

        function Je(t) {
            for (var e = t.tagName + t.className + t.src + t.href + t.textContent, i = e.length, a = 0; i--;) a += e.charCodeAt(i);
            return a.toString(36)
        }

        function ti(t) {
            return setTimeout(t, 0)
        }

        function ei(t) {
            return clearTimeout(t)
        }
        qe.prototype = {
            constructor: qe,
            _isOutsideThisEl: function(t) {
                this.el.contains(t) || t === this.el || (Ee = null)
            },
            _getDirection: function(t, e) {
                return "function" == typeof this.options.direction ? this.options.direction.call(this, t, e, ne) : this.options.direction
            },
            _onTapStart: function(t) {
                if (t.cancelable) {
                    var e = this,
                        i = this.el,
                        a = this.options,
                        s = a.preventOnFilter,
                        n = t.type,
                        r = t.touches && t.touches[0] || t.pointerType && "touch" === t.pointerType && t,
                        o = (r || t).target,
                        l = t.target.shadowRoot && (t.path && t.path[0] || t.composedPath && t.composedPath()[0]) || o,
                        c = a.filter;
                    if (function(t) {
                            Ne.length = 0;
                            var e = t.getElementsByTagName("input"),
                                i = e.length;
                            for (; i--;) {
                                var a = e[i];
                                a.checked && Ne.push(a)
                            }
                        }(i), !ne && !(/mousedown|pointerdown/.test(n) && 0 !== t.button || a.disabled) && !l.isContentEditable && (this.nativeDraggable || !Ct || !o || "SELECT" !== o.tagName.toUpperCase()) && !((o = It(o, a.draggable, i, !1)) && o.animated || he === o)) {
                        if (pe = Bt(o), fe = Bt(o, a.draggable), "function" == typeof c) {
                            if (c.call(this, t, o, this)) return se({
                                sortable: e,
                                rootEl: l,
                                name: "filter",
                                targetEl: o,
                                toEl: i,
                                fromEl: i
                            }), ae("filter", e, {
                                evt: t
                            }), void(s && t.cancelable && t.preventDefault())
                        } else if (c && (c = c.split(",").some((function(a) {
                                if (a = It(l, a.trim(), i, !1)) return se({
                                    sortable: e,
                                    rootEl: a,
                                    name: "filter",
                                    targetEl: o,
                                    fromEl: i,
                                    toEl: i
                                }), ae("filter", e, {
                                    evt: t
                                }), !0
                            })))) return void(s && t.cancelable && t.preventDefault());
                        a.handle && !It(l, a.handle, i, !1) || this._prepareDragStart(t, r, o)
                    }
                }
            },
            _prepareDragStart: function(t, e, i) {
                var a, s = this,
                    n = s.el,
                    r = s.options,
                    o = n.ownerDocument;
                if (i && !ne && i.parentNode === n) {
                    var l = Ft(i);
                    if (le = n, re = (ne = i).parentNode, ce = ne.nextSibling, he = i, xe = r.group, qe.dragged = ne, be = {
                            target: ne,
                            clientX: (e || t).clientX,
                            clientY: (e || t).clientY
                        }, Ce = be.clientX - l.left, ke = be.clientY - l.top, this._lastX = (e || t).clientX, this._lastY = (e || t).clientY, ne.style["will-change"] = "all", a = function() {
                            ae("delayEnded", s, {
                                evt: t
                            }), qe.eventCanceled ? s._onDrop() : (s._disableDelayedDragEvents(), !St && s.nativeDraggable && (ne.draggable = !0), s._triggerDragStart(t, e), se({
                                sortable: s,
                                name: "choose",
                                originalEvent: t
                            }), Dt(ne, r.chosenClass, !0))
                        }, r.ignore.split(",").forEach((function(t) {
                            Nt(ne, t.trim(), Ke)
                        })), Tt(o, "dragover", je), Tt(o, "mousemove", je), Tt(o, "touchmove", je), Tt(o, "mouseup", s._onDrop), Tt(o, "touchend", s._onDrop), Tt(o, "touchcancel", s._onDrop), St && this.nativeDraggable && (this.options.touchStartThreshold = 4, ne.draggable = !0), ae("delayStart", this, {
                            evt: t
                        }), !r.delay || r.delayOnTouchOnly && !e || this.nativeDraggable && (wt || yt)) a();
                    else {
                        if (qe.eventCanceled) return void this._onDrop();
                        Tt(o, "mouseup", s._disableDelayedDrag), Tt(o, "touchend", s._disableDelayedDrag), Tt(o, "touchcancel", s._disableDelayedDrag), Tt(o, "mousemove", s._delayedDragTouchMoveHandler), Tt(o, "touchmove", s._delayedDragTouchMoveHandler), r.supportPointer && Tt(o, "pointermove", s._delayedDragTouchMoveHandler), s._dragStartTimer = setTimeout(a, r.delay)
                    }
                }
            },
            _delayedDragTouchMoveHandler: function(t) {
                var e = t.touches ? t.touches[0] : t;
                Math.max(Math.abs(e.clientX - this._lastX), Math.abs(e.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1)) && this._disableDelayedDrag()
            },
            _disableDelayedDrag: function() {
                ne && Ke(ne), clearTimeout(this._dragStartTimer), this._disableDelayedDragEvents()
            },
            _disableDelayedDragEvents: function() {
                var t = this.el.ownerDocument;
                Pt(t, "mouseup", this._disableDelayedDrag), Pt(t, "touchend", this._disableDelayedDrag), Pt(t, "touchcancel", this._disableDelayedDrag), Pt(t, "mousemove", this._delayedDragTouchMoveHandler), Pt(t, "touchmove", this._delayedDragTouchMoveHandler), Pt(t, "pointermove", this._delayedDragTouchMoveHandler)
            },
            _triggerDragStart: function(t, e) {
                e = e || "touch" == t.pointerType && t, !this.nativeDraggable || e ? this.options.supportPointer ? Tt(document, "pointermove", this._onTouchMove) : Tt(document, e ? "touchmove" : "mousemove", this._onTouchMove) : (Tt(ne, "dragend", this), Tt(le, "dragstart", this._onDragStart));
                try {
                    document.selection ? ti((function() {
                        document.selection.empty()
                    })) : window.getSelection().removeAllRanges()
                } catch (t) {}
            },
            _dragStarted: function(t, e) {
                if (Le = !1, le && ne) {
                    ae("dragStarted", this, {
                        evt: e
                    }), this.nativeDraggable && Tt(document, "dragover", Ue);
                    var i = this.options;
                    !t && Dt(ne, i.dragClass, !1), Dt(ne, i.ghostClass, !0), qe.active = this, t && this._appendGhost(), se({
                        sortable: this,
                        name: "start",
                        originalEvent: e
                    })
                } else this._nulling()
            },
            _emulateDragOver: function() {
                if (ye) {
                    this._lastX = ye.clientX, this._lastY = ye.clientY, Ge();
                    for (var t = document.elementFromPoint(ye.clientX, ye.clientY), e = t; t && t.shadowRoot && (t = t.shadowRoot.elementFromPoint(ye.clientX, ye.clientY)) !== e;) e = t;
                    if (ne.parentNode[Zt]._isOutsideThisEl(t), e)
                        do {
                            if (e[Zt]) {
                                if (e[Zt]._onDragOver({
                                        clientX: ye.clientX,
                                        clientY: ye.clientY,
                                        target: t,
                                        rootEl: e
                                    }) && !this.options.dragoverBubble) break
                            }
                            t = e
                        } while (e = e.parentNode);
                    Ve()
                }
            },
            _onTouchMove: function(t) {
                if (be) {
                    var e = this.options,
                        i = e.fallbackTolerance,
                        a = e.fallbackOffset,
                        s = t.touches ? t.touches[0] : t,
                        n = oe && Ot(oe, !0),
                        r = oe && n && n.a,
                        o = oe && n && n.d,
                        l = Fe && Me && $t(Me),
                        c = (s.clientX - be.clientX + a.x) / (r || 1) + (l ? l[0] - Xe[0] : 0) / (r || 1),
                        h = (s.clientY - be.clientY + a.y) / (o || 1) + (l ? l[1] - Xe[1] : 0) / (o || 1);
                    if (!qe.active && !Le) {
                        if (i && Math.max(Math.abs(s.clientX - this._lastX), Math.abs(s.clientY - this._lastY)) < i) return;
                        this._onDragStart(t, !0)
                    }
                    if (oe) {
                        n ? (n.e += c - (we || 0), n.f += h - (Se || 0)) : n = {
                            a: 1,
                            b: 0,
                            c: 0,
                            d: 1,
                            e: c,
                            f: h
                        };
                        var d = "matrix(".concat(n.a, ",").concat(n.b, ",").concat(n.c, ",").concat(n.d, ",").concat(n.e, ",").concat(n.f, ")");
                        Xt(oe, "webkitTransform", d), Xt(oe, "mozTransform", d), Xt(oe, "msTransform", d), Xt(oe, "transform", d), we = c, Se = h, ye = s
                    }
                    t.cancelable && t.preventDefault()
                }
            },
            _appendGhost: function() {
                if (!oe) {
                    var t = this.options.fallbackOnBody ? document.body : le,
                        e = Ft(ne, !0, Fe, !0, t),
                        i = this.options;
                    if (Fe) {
                        for (Me = t;
                            "static" === Xt(Me, "position") && "none" === Xt(Me, "transform") && Me !== document;) Me = Me.parentNode;
                        Me !== document.body && Me !== document.documentElement ? (Me === document && (Me = Yt()), e.top += Me.scrollTop, e.left += Me.scrollLeft) : Me = Yt(), Xe = $t(Me)
                    }
                    Dt(oe = ne.cloneNode(!0), i.ghostClass, !1), Dt(oe, i.fallbackClass, !0), Dt(oe, i.dragClass, !0), Xt(oe, "transition", ""), Xt(oe, "transform", ""), Xt(oe, "box-sizing", "border-box"), Xt(oe, "margin", 0), Xt(oe, "top", e.top), Xt(oe, "left", e.left), Xt(oe, "width", e.width), Xt(oe, "height", e.height), Xt(oe, "opacity", "0.8"), Xt(oe, "position", Fe ? "absolute" : "fixed"), Xt(oe, "zIndex", "100000"), Xt(oe, "pointerEvents", "none"), qe.ghost = oe, t.appendChild(oe), Xt(oe, "transform-origin", Ce / parseInt(oe.style.width) * 100 + "% " + ke / parseInt(oe.style.height) * 100 + "%")
                }
            },
            _onDragStart: function(t, e) {
                var i = this,
                    a = t.dataTransfer,
                    s = i.options;
                ae("dragStart", this, {
                    evt: t
                }), qe.eventCanceled ? this._onDrop() : (ae("setupClone", this), qe.eventCanceled || ((de = qt(ne)).removeAttribute("id"), de.draggable = !1, de.style["will-change"] = "", this._hideClone(), Dt(de, this.options.chosenClass, !1), qe.clone = de), i.cloneId = ti((function() {
                    ae("clone", i), qe.eventCanceled || (i.options.removeCloneOnHide || le.insertBefore(de, ne), i._hideClone(), se({
                        sortable: i,
                        name: "clone"
                    }))
                })), !e && Dt(ne, s.dragClass, !0), e ? (Ie = !0, i._loopId = setInterval(i._emulateDragOver, 50)) : (Pt(document, "mouseup", i._onDrop), Pt(document, "touchend", i._onDrop), Pt(document, "touchcancel", i._onDrop), a && (a.effectAllowed = "move", s.setData && s.setData.call(i, a, ne)), Tt(document, "drop", i), Xt(ne, "transform", "translateZ(0)")), Le = !0, i._dragStartId = ti(i._dragStarted.bind(i, e, t)), Tt(document, "selectstart", i), Ae = !0, Ct && Xt(document.body, "user-select", "none"))
            },
            _onDragOver: function(t) {
                var e, i, a, s, n = this.el,
                    r = t.target,
                    o = this.options,
                    l = o.group,
                    c = qe.active,
                    h = xe === l,
                    d = o.sort,
                    u = ve || c,
                    p = this,
                    g = !1;
                if (!Oe) {
                    if (void 0 !== t.preventDefault && t.cancelable && t.preventDefault(), r = It(r, o.draggable, n, !0), M("dragOver"), qe.eventCanceled) return g;
                    if (ne.contains(t.target) || r.animated && r.animatingX && r.animatingY || p._ignoreWhileAnimating === r) return I(!1);
                    if (Ie = !1, c && !o.disabled && (h ? d || (a = re !== le) : ve === this || (this.lastPutMode = xe.checkPull(this, c, ne, t)) && l.checkPut(this, c, ne, t))) {
                        if (s = "vertical" === this._getDirection(t, r), e = Ft(ne), M("dragOverValid"), qe.eventCanceled) return g;
                        if (a) return re = le, L(), this._hideClone(), M("revert"), qe.eventCanceled || (ce ? le.insertBefore(ne, ce) : le.appendChild(ne)), I(!0);
                        var f = Wt(n, o.draggable);
                        if (!f || function(t, e, i) {
                                var a = Ft(Wt(i.el, i.options.draggable)),
                                    s = 10;
                                return e ? t.clientX > a.right + s || t.clientX <= a.right && t.clientY > a.bottom && t.clientX >= a.left : t.clientX > a.right && t.clientY > a.top || t.clientX <= a.right && t.clientY > a.bottom + s
                            }(t, s, this) && !f.animated) {
                            if (f === ne) return I(!1);
                            if (f && n === t.target && (r = f), r && (i = Ft(r)), !1 !== Ze(le, n, ne, e, r, i, t, !!r)) return L(), f && f.nextSibling ? n.insertBefore(ne, f.nextSibling) : n.appendChild(ne), re = n, _(), I(!0)
                        } else if (f && function(t, e, i) {
                                var a = Ft(Ht(i.el, 0, i.options, !0)),
                                    s = 10;
                                return e ? t.clientX < a.left - s || t.clientY < a.top && t.clientX < a.right : t.clientY < a.top - s || t.clientY < a.bottom && t.clientX < a.left
                            }(t, s, this)) {
                            var m = Ht(n, 0, o, !0);
                            if (m === ne) return I(!1);
                            if (i = Ft(r = m), !1 !== Ze(le, n, ne, e, r, i, t, !1)) return L(), n.insertBefore(ne, m), re = n, _(), I(!0)
                        } else if (r.parentNode === n) {
                            i = Ft(r);
                            var x, v, b, y = ne.parentNode !== n,
                                w = ! function(t, e, i) {
                                    var a = i ? t.left : t.top,
                                        s = i ? t.right : t.bottom,
                                        n = i ? t.width : t.height,
                                        r = i ? e.left : e.top,
                                        o = i ? e.right : e.bottom,
                                        l = i ? e.width : e.height;
                                    return a === r || s === o || a + n / 2 === r + l / 2
                                }(ne.animated && ne.toRect || e, r.animated && r.toRect || i, s),
                                S = s ? "top" : "left",
                                C = Rt(r, "top", "top") || Rt(ne, "top", "top"),
                                k = C ? C.scrollTop : void 0;
                            if (Ee !== r && (v = i[S], ze = !1, De = !w && o.invertSwap || y), x = function(t, e, i, a, s, n, r, o) {
                                    var l = a ? t.clientY : t.clientX,
                                        c = a ? i.height : i.width,
                                        h = a ? i.top : i.left,
                                        d = a ? i.bottom : i.right,
                                        u = !1;
                                    if (!r)
                                        if (o && Pe < c * s) {
                                            if (!ze && (1 === Te ? l > h + c * n / 2 : l < d - c * n / 2) && (ze = !0), ze) u = !0;
                                            else if (1 === Te ? l < h + Pe : l > d - Pe) return -Te
                                        } else if (l > h + c * (1 - s) / 2 && l < d - c * (1 - s) / 2) return function(t) {
                                        return Bt(ne) < Bt(t) ? 1 : -1
                                    }(e);
                                    if ((u = u || r) && (l < h + c * n / 2 || l > d - c * n / 2)) return l > h + c / 2 ? 1 : -1;
                                    return 0
                                }(t, r, i, s, w ? 1 : o.swapThreshold, null == o.invertedSwapThreshold ? o.swapThreshold : o.invertedSwapThreshold, De, Ee === r), 0 !== x) {
                                var A = Bt(ne);
                                do {
                                    A -= x, b = re.children[A]
                                } while (b && ("none" === Xt(b, "display") || b === oe))
                            }
                            if (0 === x || b === r) return I(!1);
                            Ee = r, Te = x;
                            var E = r.nextElementSibling,
                                T = !1,
                                P = Ze(le, n, ne, e, r, i, t, T = 1 === x);
                            if (!1 !== P) return 1 !== P && -1 !== P || (T = 1 === P), Oe = !0, setTimeout(Qe, 30), L(), T && !E ? n.appendChild(ne) : r.parentNode.insertBefore(ne, T ? E : r), C && Ut(C, 0, k - C.scrollTop), re = ne.parentNode, void 0 === v || De || (Pe = Math.abs(v - Ft(r)[S])), _(), I(!0)
                        }
                        if (n.contains(ne)) return I(!1)
                    }
                    return !1
                }

                function M(o, l) {
                    ae(o, p, gt({
                        evt: t,
                        isOwner: h,
                        axis: s ? "vertical" : "horizontal",
                        revert: a,
                        dragRect: e,
                        targetRect: i,
                        canSort: d,
                        fromSortable: u,
                        target: r,
                        completed: I,
                        onMove: function(i, a) {
                            return Ze(le, n, ne, e, i, Ft(i), t, a)
                        },
                        changed: _
                    }, l))
                }

                function L() {
                    M("dragOverAnimationCapture"), p.captureAnimationState(), p !== u && u.captureAnimationState()
                }

                function I(e) {
                    return M("dragOverCompleted", {
                        insertion: e
                    }), e && (h ? c._hideClone() : c._showClone(p), p !== u && (Dt(ne, ve ? ve.options.ghostClass : c.options.ghostClass, !1), Dt(ne, o.ghostClass, !0)), ve !== p && p !== qe.active ? ve = p : p === qe.active && ve && (ve = null), u === p && (p._ignoreWhileAnimating = r), p.animateAll((function() {
                        M("dragOverAnimationComplete"), p._ignoreWhileAnimating = null
                    })), p !== u && (u.animateAll(), u._ignoreWhileAnimating = null)), (r === ne && !ne.animated || r === n && !r.animated) && (Ee = null), o.dragoverBubble || t.rootEl || r === document || (ne.parentNode[Zt]._isOutsideThisEl(t.target), !e && je(t)), !o.dragoverBubble && t.stopPropagation && t.stopPropagation(), g = !0
                }

                function _() {
                    ge = Bt(ne), me = Bt(ne, o.draggable), se({
                        sortable: p,
                        name: "change",
                        toEl: n,
                        newIndex: ge,
                        newDraggableIndex: me,
                        originalEvent: t
                    })
                }
            },
            _ignoreWhileAnimating: null,
            _offMoveEvents: function() {
                Pt(document, "mousemove", this._onTouchMove), Pt(document, "touchmove", this._onTouchMove), Pt(document, "pointermove", this._onTouchMove), Pt(document, "dragover", je), Pt(document, "mousemove", je), Pt(document, "touchmove", je)
            },
            _offUpEvents: function() {
                var t = this.el.ownerDocument;
                Pt(t, "mouseup", this._onDrop), Pt(t, "touchend", this._onDrop), Pt(t, "pointerup", this._onDrop), Pt(t, "touchcancel", this._onDrop), Pt(document, "selectstart", this)
            },
            _onDrop: function(t) {
                var e = this.el,
                    i = this.options;
                ge = Bt(ne), me = Bt(ne, i.draggable), ae("drop", this, {
                    evt: t
                }), re = ne && ne.parentNode, ge = Bt(ne), me = Bt(ne, i.draggable), qe.eventCanceled || (Le = !1, De = !1, ze = !1, clearInterval(this._loopId), clearTimeout(this._dragStartTimer), ei(this.cloneId), ei(this._dragStartId), this.nativeDraggable && (Pt(document, "drop", this), Pt(e, "dragstart", this._onDragStart)), this._offMoveEvents(), this._offUpEvents(), Ct && Xt(document.body, "user-select", ""), Xt(ne, "transform", ""), t && (Ae && (t.cancelable && t.preventDefault(), !i.dropBubble && t.stopPropagation()), oe && oe.parentNode && oe.parentNode.removeChild(oe), (le === re || ve && "clone" !== ve.lastPutMode) && de && de.parentNode && de.parentNode.removeChild(de), ne && (this.nativeDraggable && Pt(ne, "dragend", this), Ke(ne), ne.style["will-change"] = "", Ae && !Le && Dt(ne, ve ? ve.options.ghostClass : this.options.ghostClass, !1), Dt(ne, this.options.chosenClass, !1), se({
                    sortable: this,
                    name: "unchoose",
                    toEl: re,
                    newIndex: null,
                    newDraggableIndex: null,
                    originalEvent: t
                }), le !== re ? (ge >= 0 && (se({
                    rootEl: re,
                    name: "add",
                    toEl: re,
                    fromEl: le,
                    originalEvent: t
                }), se({
                    sortable: this,
                    name: "remove",
                    toEl: re,
                    originalEvent: t
                }), se({
                    rootEl: re,
                    name: "sort",
                    toEl: re,
                    fromEl: le,
                    originalEvent: t
                }), se({
                    sortable: this,
                    name: "sort",
                    toEl: re,
                    originalEvent: t
                })), ve && ve.save()) : ge !== pe && ge >= 0 && (se({
                    sortable: this,
                    name: "update",
                    toEl: re,
                    originalEvent: t
                }), se({
                    sortable: this,
                    name: "sort",
                    toEl: re,
                    originalEvent: t
                })), qe.active && (null != ge && -1 !== ge || (ge = pe, me = fe), se({
                    sortable: this,
                    name: "end",
                    toEl: re,
                    originalEvent: t
                }), this.save())))), this._nulling()
            },
            _nulling: function() {
                ae("nulling", this), le = ne = re = oe = ce = de = he = ue = be = ye = Ae = ge = me = pe = fe = Ee = Te = ve = xe = qe.dragged = qe.ghost = qe.clone = qe.active = null, Ne.forEach((function(t) {
                    t.checked = !0
                })), Ne.length = we = Se = 0
            },
            handleEvent: function(t) {
                switch (t.type) {
                    case "drop":
                    case "dragend":
                        this._onDrop(t);
                        break;
                    case "dragenter":
                    case "dragover":
                        ne && (this._onDragOver(t), function(t) {
                            t.dataTransfer && (t.dataTransfer.dropEffect = "move");
                            t.cancelable && t.preventDefault()
                        }(t));
                        break;
                    case "selectstart":
                        t.preventDefault()
                }
            },
            toArray: function() {
                for (var t, e = [], i = this.el.children, a = 0, s = i.length, n = this.options; a < s; a++) It(t = i[a], n.draggable, this.el, !1) && e.push(t.getAttribute(n.dataIdAttr) || Je(t));
                return e
            },
            sort: function(t, e) {
                var i = {},
                    a = this.el;
                this.toArray().forEach((function(t, e) {
                    var s = a.children[e];
                    It(s, this.options.draggable, a, !1) && (i[t] = s)
                }), this), e && this.captureAnimationState(), t.forEach((function(t) {
                    i[t] && (a.removeChild(i[t]), a.appendChild(i[t]))
                })), e && this.animateAll()
            },
            save: function() {
                var t = this.options.store;
                t && t.set && t.set(this)
            },
            closest: function(t, e) {
                return It(t, e || this.options.draggable, this.el, !1)
            },
            option: function(t, e) {
                var i = this.options;
                if (void 0 === e) return i[t];
                var a = te.modifyOption(this, t, e);
                i[t] = void 0 !== a ? a : e, "group" === t && $e(i)
            },
            destroy: function() {
                ae("destroy", this);
                var t = this.el;
                t[Zt] = null, Pt(t, "mousedown", this._onTapStart), Pt(t, "touchstart", this._onTapStart), Pt(t, "pointerdown", this._onTapStart), this.nativeDraggable && (Pt(t, "dragover", this), Pt(t, "dragenter", this)), Array.prototype.forEach.call(t.querySelectorAll("[draggable]"), (function(t) {
                    t.removeAttribute("draggable")
                })), this._onDrop(), this._disableDelayedDragEvents(), _e.splice(_e.indexOf(this.el), 1), this.el = t = null
            },
            _hideClone: function() {
                if (!ue) {
                    if (ae("hideClone", this), qe.eventCanceled) return;
                    Xt(de, "display", "none"), this.options.removeCloneOnHide && de.parentNode && de.parentNode.removeChild(de), ue = !0
                }
            },
            _showClone: function(t) {
                if ("clone" === t.lastPutMode) {
                    if (ue) {
                        if (ae("showClone", this), qe.eventCanceled) return;
                        ne.parentNode != le || this.options.group.revertClone ? ce ? le.insertBefore(de, ce) : le.appendChild(de) : le.insertBefore(de, ne), this.options.group.revertClone && this.animate(ne, de), Xt(de, "display", ""), ue = !1
                    }
                } else this._hideClone()
            }
        }, Ye && Tt(document, "touchmove", (function(t) {
            (qe.active || Le) && t.cancelable && t.preventDefault()
        })), qe.utils = {
            on: Tt,
            off: Pt,
            css: Xt,
            find: Nt,
            is: function(t, e) {
                return !!It(t, e, t, !1)
            },
            extend: function(t, e) {
                if (t && e)
                    for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
                return t
            },
            throttle: jt,
            closest: It,
            toggleClass: Dt,
            clone: qt,
            index: Bt,
            nextTick: ti,
            cancelNextTick: ei,
            detectDirection: Be,
            getChild: Ht
        }, qe.get = function(t) {
            return t[Zt]
        }, qe.mount = function() {
            for (var t = arguments.length, e = new Array(t), i = 0; i < t; i++) e[i] = arguments[i];
            e[0].constructor === Array && (e = e[0]), e.forEach((function(t) {
                if (!t.prototype || !t.prototype.constructor) throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(t));
                t.utils && (qe.utils = gt(gt({}, qe.utils), t.utils)), te.mount(t)
            }))
        }, qe.create = function(t, e) {
            return new qe(t, e)
        }, qe.version = "1.15.0";
        var ii, ai, si, ni, ri, oi, li = [],
            ci = !1;

        function hi() {
            li.forEach((function(t) {
                clearInterval(t.pid)
            })), li = []
        }

        function di() {
            clearInterval(oi)
        }
        var ui = jt((function(t, e, i, a) {
                if (e.scroll) {
                    var s, n = (t.touches ? t.touches[0] : t).clientX,
                        r = (t.touches ? t.touches[0] : t).clientY,
                        o = e.scrollSensitivity,
                        l = e.scrollSpeed,
                        c = Yt(),
                        h = !1;
                    ai !== i && (ai = i, hi(), ii = e.scroll, s = e.scrollFn, !0 === ii && (ii = Gt(i, !0)));
                    var d = 0,
                        u = ii;
                    do {
                        var p = u,
                            g = Ft(p),
                            f = g.top,
                            m = g.bottom,
                            x = g.left,
                            v = g.right,
                            b = g.width,
                            y = g.height,
                            w = void 0,
                            S = void 0,
                            C = p.scrollWidth,
                            k = p.scrollHeight,
                            A = Xt(p),
                            E = p.scrollLeft,
                            T = p.scrollTop;
                        p === c ? (w = b < C && ("auto" === A.overflowX || "scroll" === A.overflowX || "visible" === A.overflowX), S = y < k && ("auto" === A.overflowY || "scroll" === A.overflowY || "visible" === A.overflowY)) : (w = b < C && ("auto" === A.overflowX || "scroll" === A.overflowX), S = y < k && ("auto" === A.overflowY || "scroll" === A.overflowY));
                        var P = w && (Math.abs(v - n) <= o && E + b < C) - (Math.abs(x - n) <= o && !!E),
                            M = S && (Math.abs(m - r) <= o && T + y < k) - (Math.abs(f - r) <= o && !!T);
                        if (!li[d])
                            for (var L = 0; L <= d; L++) li[L] || (li[L] = {});
                        li[d].vx == P && li[d].vy == M && li[d].el === p || (li[d].el = p, li[d].vx = P, li[d].vy = M, clearInterval(li[d].pid), 0 == P && 0 == M || (h = !0, li[d].pid = setInterval(function() {
                            a && 0 === this.layer && qe.active._onTouchMove(ri);
                            var e = li[this.layer].vy ? li[this.layer].vy * l : 0,
                                i = li[this.layer].vx ? li[this.layer].vx * l : 0;
                            "function" == typeof s && "continue" !== s.call(qe.dragged.parentNode[Zt], i, e, t, ri, li[this.layer].el) || Ut(li[this.layer].el, i, e)
                        }.bind({
                            layer: d
                        }), 24))), d++
                    } while (e.bubbleScroll && u !== c && (u = Gt(u, !1)));
                    ci = h
                }
            }), 30),
            pi = function(t) {
                var e = t.originalEvent,
                    i = t.putSortable,
                    a = t.dragEl,
                    s = t.activeSortable,
                    n = t.dispatchSortableEvent,
                    r = t.hideGhostForTarget,
                    o = t.unhideGhostForTarget;
                if (e) {
                    var l = i || s;
                    r();
                    var c = e.changedTouches && e.changedTouches.length ? e.changedTouches[0] : e,
                        h = document.elementFromPoint(c.clientX, c.clientY);
                    o(), l && !l.el.contains(h) && (n("spill"), this.onSpill({
                        dragEl: a,
                        putSortable: i
                    }))
                }
            };

        function gi() {}

        function fi() {}
        gi.prototype = {
            startIndex: null,
            dragStart: function(t) {
                var e = t.oldDraggableIndex;
                this.startIndex = e
            },
            onSpill: function(t) {
                var e = t.dragEl,
                    i = t.putSortable;
                this.sortable.captureAnimationState(), i && i.captureAnimationState();
                var a = Ht(this.sortable.el, this.startIndex, this.options);
                a ? this.sortable.el.insertBefore(e, a) : this.sortable.el.appendChild(e), this.sortable.animateAll(), i && i.animateAll()
            },
            drop: pi
        }, xt(gi, {
            pluginName: "revertOnSpill"
        }), fi.prototype = {
            onSpill: function(t) {
                var e = t.dragEl,
                    i = t.putSortable || this.sortable;
                i.captureAnimationState(), e.parentNode && e.parentNode.removeChild(e), i.animateAll()
            },
            drop: pi
        }, xt(fi, {
            pluginName: "removeOnSpill"
        });
        qe.mount(new function() {
            function t() {
                for (var t in this.defaults = {
                        scroll: !0,
                        forceAutoScrollFallback: !1,
                        scrollSensitivity: 30,
                        scrollSpeed: 10,
                        bubbleScroll: !0
                    }, this) "_" === t.charAt(0) && "function" == typeof this[t] && (this[t] = this[t].bind(this))
            }
            return t.prototype = {
                dragStarted: function(t) {
                    var e = t.originalEvent;
                    this.sortable.nativeDraggable ? Tt(document, "dragover", this._handleAutoScroll) : this.options.supportPointer ? Tt(document, "pointermove", this._handleFallbackAutoScroll) : e.touches ? Tt(document, "touchmove", this._handleFallbackAutoScroll) : Tt(document, "mousemove", this._handleFallbackAutoScroll)
                },
                dragOverCompleted: function(t) {
                    var e = t.originalEvent;
                    this.options.dragOverBubble || e.rootEl || this._handleAutoScroll(e)
                },
                drop: function() {
                    this.sortable.nativeDraggable ? Pt(document, "dragover", this._handleAutoScroll) : (Pt(document, "pointermove", this._handleFallbackAutoScroll), Pt(document, "touchmove", this._handleFallbackAutoScroll), Pt(document, "mousemove", this._handleFallbackAutoScroll)), di(), hi(), clearTimeout(_t), _t = void 0
                },
                nulling: function() {
                    ri = ai = ii = ci = oi = si = ni = null, li.length = 0
                },
                _handleFallbackAutoScroll: function(t) {
                    this._handleAutoScroll(t, !0)
                },
                _handleAutoScroll: function(t, e) {
                    var i = this,
                        a = (t.touches ? t.touches[0] : t).clientX,
                        s = (t.touches ? t.touches[0] : t).clientY,
                        n = document.elementFromPoint(a, s);
                    if (ri = t, e || this.options.forceAutoScrollFallback || wt || yt || Ct) {
                        ui(t, this.options, n, e);
                        var r = Gt(n, !0);
                        !ci || oi && a === si && s === ni || (oi && di(), oi = setInterval((function() {
                            var n = Gt(document.elementFromPoint(a, s), !0);
                            n !== r && (r = n, hi()), ui(t, i.options, n, e)
                        }), 10), si = a, ni = s)
                    } else {
                        if (!this.options.bubbleScroll || Gt(n, !0) === Yt()) return void hi();
                        ui(t, this.options, Gt(n, !1), !1)
                    }
                }
            }, xt(t, {
                pluginName: "scroll",
                initializeByDefault: !0
            })
        }), qe.mount(fi, gi);
        const mi = qe;
        var xi = i(8369),
            vi = i.n(xi);

        function bi(t, e) {
            for (var i = 0; i < e.length; i++) {
                var a = e[i];
                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(t, a.key, a)
            }
        }

        function yi(t, e, i) {
            return e && bi(t.prototype, e), i && bi(t, i), t
        }

        function wi() {
            return wi = Object.assign || function(t) {
                for (var e = 1; e < arguments.length; e++) {
                    var i = arguments[e];
                    for (var a in i) Object.prototype.hasOwnProperty.call(i, a) && (t[a] = i[a])
                }
                return t
            }, wi.apply(this, arguments)
        }

        function Si(t, e) {
            t.prototype = Object.create(e.prototype), t.prototype.constructor = t, Ci(t, e)
        }

        function Ci(t, e) {
            return Ci = Object.setPrototypeOf || function(t, e) {
                return t.__proto__ = e, t
            }, Ci(t, e)
        }

        function ki(t) {
            if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return t
        }

        function Ai(t, e) {
            (null == e || e > t.length) && (e = t.length);
            for (var i = 0, a = new Array(e); i < e; i++) a[i] = t[i];
            return a
        }

        function Ei(t, e) {
            var i = "undefined" != typeof Symbol && t[Symbol.iterator] || t["@@iterator"];
            if (i) return (i = i.call(t)).next.bind(i);
            if (Array.isArray(t) || (i = function(t, e) {
                    if (t) {
                        if ("string" == typeof t) return Ai(t, e);
                        var i = Object.prototype.toString.call(t).slice(8, -1);
                        return "Object" === i && t.constructor && (i = t.constructor.name), "Map" === i || "Set" === i ? Array.from(t) : "Arguments" === i || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? Ai(t, e) : void 0
                    }
                }(t)) || e && t && "number" == typeof t.length) {
                i && (t = i);
                var a = 0;
                return function() {
                    return a >= t.length ? {
                        done: !0
                    } : {
                        done: !1,
                        value: t[a++]
                    }
                }
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")
        }
        var Ti, Pi, Mi, Li, Ii, _i, zi, Di = {},
            Xi = [],
            Oi = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;

        function Ni(t, e) {
            for (var i in e) t[i] = e[i];
            return t
        }

        function Yi(t) {
            var e = t.parentNode;
            e && e.removeChild(t)
        }

        function Fi(t, e, i) {
            var a, s, n, r = {};
            for (n in e) "key" == n ? a = e[n] : "ref" == n ? s = e[n] : r[n] = e[n];
            if (arguments.length > 2 && (r.children = arguments.length > 3 ? Ti.call(arguments, 2) : i), "function" == typeof t && null != t.defaultProps)
                for (n in t.defaultProps) void 0 === r[n] && (r[n] = t.defaultProps[n]);
            return Ri(t, r, a, s, null)
        }

        function Ri(t, e, i, a, s) {
            var n = {
                type: t,
                props: e,
                key: i,
                ref: a,
                __k: null,
                __: null,
                __b: 0,
                __e: null,
                __d: void 0,
                __c: null,
                __h: null,
                constructor: void 0,
                __v: null == s ? ++Mi : s
            };
            return null == s && null != Pi.vnode && Pi.vnode(n), n
        }

        function Hi() {
            return {
                current: null
            }
        }

        function Wi(t) {
            return t.children
        }

        function Bi(t, e) {
            this.props = t, this.context = e
        }

        function $i(t, e) {
            if (null == e) return t.__ ? $i(t.__, t.__.__k.indexOf(t) + 1) : null;
            for (var i; e < t.__k.length; e++)
                if (null != (i = t.__k[e]) && null != i.__e) return i.__e;
            return "function" == typeof t.type ? $i(t) : null
        }

        function Gi(t) {
            var e, i;
            if (null != (t = t.__) && null != t.__c) {
                for (t.__e = t.__c.base = null, e = 0; e < t.__k.length; e++)
                    if (null != (i = t.__k[e]) && null != i.__e) {
                        t.__e = t.__c.base = i.__e;
                        break
                    }
                return Gi(t)
            }
        }

        function Vi(t) {
            (!t.__d && (t.__d = !0) && Ii.push(t) && !ji.__r++ || _i !== Pi.debounceRendering) && ((_i = Pi.debounceRendering) || setTimeout)(ji)
        }

        function ji() {
            for (var t; ji.__r = Ii.length;) t = Ii.sort((function(t, e) {
                return t.__v.__b - e.__v.__b
            })), Ii = [], t.some((function(t) {
                var e, i, a, s, n, r;
                t.__d && (n = (s = (e = t).__v).__e, (r = e.__P) && (i = [], (a = Ni({}, s)).__v = s.__v + 1, ea(r, s, a, e.__n, void 0 !== r.ownerSVGElement, null != s.__h ? [n] : null, i, null == n ? $i(s) : n, s.__h), ia(i, s), s.__e != n && Gi(s)))
            }))
        }

        function Ui(t, e, i, a, s, n, r, o, l, c) {
            var h, d, u, p, g, f, m, x = a && a.__k || Xi,
                v = x.length;
            for (i.__k = [], h = 0; h < e.length; h++)
                if (null != (p = i.__k[h] = null == (p = e[h]) || "boolean" == typeof p ? null : "string" == typeof p || "number" == typeof p || "bigint" == typeof p ? Ri(null, p, null, null, p) : Array.isArray(p) ? Ri(Wi, {
                        children: p
                    }, null, null, null) : p.__b > 0 ? Ri(p.type, p.props, p.key, null, p.__v) : p)) {
                    if (p.__ = i, p.__b = i.__b + 1, null === (u = x[h]) || u && p.key == u.key && p.type === u.type) x[h] = void 0;
                    else
                        for (d = 0; d < v; d++) {
                            if ((u = x[d]) && p.key == u.key && p.type === u.type) {
                                x[d] = void 0;
                                break
                            }
                            u = null
                        }
                    ea(t, p, u = u || Di, s, n, r, o, l, c), g = p.__e, (d = p.ref) && u.ref != d && (m || (m = []), u.ref && m.push(u.ref, null, p), m.push(d, p.__c || g, p)), null != g ? (null == f && (f = g), "function" == typeof p.type && p.__k === u.__k ? p.__d = l = qi(p, l, t) : l = Zi(t, p, u, x, g, l), "function" == typeof i.type && (i.__d = l)) : l && u.__e == l && l.parentNode != t && (l = $i(u))
                }
            for (i.__e = f, h = v; h--;) null != x[h] && ("function" == typeof i.type && null != x[h].__e && x[h].__e == i.__d && (i.__d = $i(a, h + 1)), na(x[h], x[h]));
            if (m)
                for (h = 0; h < m.length; h++) sa(m[h], m[++h], m[++h])
        }

        function qi(t, e, i) {
            for (var a, s = t.__k, n = 0; s && n < s.length; n++)(a = s[n]) && (a.__ = t, e = "function" == typeof a.type ? qi(a, e, i) : Zi(i, a, a, s, a.__e, e));
            return e
        }

        function Zi(t, e, i, a, s, n) {
            var r, o, l;
            if (void 0 !== e.__d) r = e.__d, e.__d = void 0;
            else if (null == i || s != n || null == s.parentNode) t: if (null == n || n.parentNode !== t) t.appendChild(s), r = null;
                else {
                    for (o = n, l = 0;
                        (o = o.nextSibling) && l < a.length; l += 2)
                        if (o == s) break t;
                    t.insertBefore(s, n), r = n
                }
            return void 0 !== r ? r : s.nextSibling
        }

        function Ki(t, e, i) {
            "-" === e[0] ? t.setProperty(e, i) : t[e] = null == i ? "" : "number" != typeof i || Oi.test(e) ? i : i + "px"
        }

        function Qi(t, e, i, a, s) {
            var n;
            t: if ("style" === e)
                if ("string" == typeof i) t.style.cssText = i;
                else {
                    if ("string" == typeof a && (t.style.cssText = a = ""), a)
                        for (e in a) i && e in i || Ki(t.style, e, "");
                    if (i)
                        for (e in i) a && i[e] === a[e] || Ki(t.style, e, i[e])
                }
            else if ("o" === e[0] && "n" === e[1]) n = e !== (e = e.replace(/Capture$/, "")), e = e.toLowerCase() in t ? e.toLowerCase().slice(2) : e.slice(2), t.l || (t.l = {}), t.l[e + n] = i, i ? a || t.addEventListener(e, n ? ta : Ji, n) : t.removeEventListener(e, n ? ta : Ji, n);
            else if ("dangerouslySetInnerHTML" !== e) {
                if (s) e = e.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
                else if ("href" !== e && "list" !== e && "form" !== e && "tabIndex" !== e && "download" !== e && e in t) try {
                    t[e] = null == i ? "" : i;
                    break t
                } catch (t) {}
                "function" == typeof i || (null != i && (!1 !== i || "a" === e[0] && "r" === e[1]) ? t.setAttribute(e, i) : t.removeAttribute(e))
            }
        }

        function Ji(t) {
            this.l[t.type + !1](Pi.event ? Pi.event(t) : t)
        }

        function ta(t) {
            this.l[t.type + !0](Pi.event ? Pi.event(t) : t)
        }

        function ea(t, e, i, a, s, n, r, o, l) {
            var c, h, d, u, p, g, f, m, x, v, b, y, w, S = e.type;
            if (void 0 !== e.constructor) return null;
            null != i.__h && (l = i.__h, o = e.__e = i.__e, e.__h = null, n = [o]), (c = Pi.__b) && c(e);
            try {
                t: if ("function" == typeof S) {
                    if (m = e.props, x = (c = S.contextType) && a[c.__c], v = c ? x ? x.props.value : c.__ : a, i.__c ? f = (h = e.__c = i.__c).__ = h.__E : ("prototype" in S && S.prototype.render ? e.__c = h = new S(m, v) : (e.__c = h = new Bi(m, v), h.constructor = S, h.render = ra), x && x.sub(h), h.props = m, h.state || (h.state = {}), h.context = v, h.__n = a, d = h.__d = !0, h.__h = []), null == h.__s && (h.__s = h.state), null != S.getDerivedStateFromProps && (h.__s == h.state && (h.__s = Ni({}, h.__s)), Ni(h.__s, S.getDerivedStateFromProps(m, h.__s))), u = h.props, p = h.state, d) null == S.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);
                    else {
                        if (null == S.getDerivedStateFromProps && m !== u && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, v), !h.__e && null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, v) || e.__v === i.__v) {
                            h.props = m, h.state = h.__s, e.__v !== i.__v && (h.__d = !1), h.__v = e, e.__e = i.__e, e.__k = i.__k, e.__k.forEach((function(t) {
                                t && (t.__ = e)
                            })), h.__h.length && r.push(h);
                            break t
                        }
                        null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, v), null != h.componentDidUpdate && h.__h.push((function() {
                            h.componentDidUpdate(u, p, g)
                        }))
                    }
                    if (h.context = v, h.props = m, h.__v = e, h.__P = t, b = Pi.__r, y = 0, "prototype" in S && S.prototype.render) h.state = h.__s, h.__d = !1, b && b(e), c = h.render(h.props, h.state, h.context);
                    else
                        do {
                            h.__d = !1, b && b(e), c = h.render(h.props, h.state, h.context), h.state = h.__s
                        } while (h.__d && ++y < 25);
                    h.state = h.__s, null != h.getChildContext && (a = Ni(Ni({}, a), h.getChildContext())), d || null == h.getSnapshotBeforeUpdate || (g = h.getSnapshotBeforeUpdate(u, p)), w = null != c && c.type === Wi && null == c.key ? c.props.children : c, Ui(t, Array.isArray(w) ? w : [w], e, i, a, s, n, r, o, l), h.base = e.__e, e.__h = null, h.__h.length && r.push(h), f && (h.__E = h.__ = null), h.__e = !1
                } else null == n && e.__v === i.__v ? (e.__k = i.__k, e.__e = i.__e) : e.__e = aa(i.__e, e, i, a, s, n, r, l);
                (c = Pi.diffed) && c(e)
            }
            catch (t) {
                e.__v = null, (l || null != n) && (e.__e = o, e.__h = !!l, n[n.indexOf(o)] = null), Pi.__e(t, e, i)
            }
        }

        function ia(t, e) {
            Pi.__c && Pi.__c(e, t), t.some((function(e) {
                try {
                    t = e.__h, e.__h = [], t.some((function(t) {
                        t.call(e)
                    }))
                } catch (t) {
                    Pi.__e(t, e.__v)
                }
            }))
        }

        function aa(t, e, i, a, s, n, r, o) {
            var l, c, h, d = i.props,
                u = e.props,
                p = e.type,
                g = 0;
            if ("svg" === p && (s = !0), null != n)
                for (; g < n.length; g++)
                    if ((l = n[g]) && "setAttribute" in l == !!p && (p ? l.localName === p : 3 === l.nodeType)) {
                        t = l, n[g] = null;
                        break
                    }
            if (null == t) {
                if (null === p) return document.createTextNode(u);
                t = s ? document.createElementNS("http://www.w3.org/2000/svg", p) : document.createElement(p, u.is && u), n = null, o = !1
            }
            if (null === p) d === u || o && t.data === u || (t.data = u);
            else {
                if (n = n && Ti.call(t.childNodes), c = (d = i.props || Di).dangerouslySetInnerHTML, h = u.dangerouslySetInnerHTML, !o) {
                    if (null != n)
                        for (d = {}, g = 0; g < t.attributes.length; g++) d[t.attributes[g].name] = t.attributes[g].value;
                    (h || c) && (h && (c && h.__html == c.__html || h.__html === t.innerHTML) || (t.innerHTML = h && h.__html || ""))
                }
                if (function(t, e, i, a, s) {
                        var n;
                        for (n in i) "children" === n || "key" === n || n in e || Qi(t, n, null, i[n], a);
                        for (n in e) s && "function" != typeof e[n] || "children" === n || "key" === n || "value" === n || "checked" === n || i[n] === e[n] || Qi(t, n, e[n], i[n], a)
                    }(t, u, d, s, o), h) e.__k = [];
                else if (g = e.props.children, Ui(t, Array.isArray(g) ? g : [g], e, i, a, s && "foreignObject" !== p, n, r, n ? n[0] : i.__k && $i(i, 0), o), null != n)
                    for (g = n.length; g--;) null != n[g] && Yi(n[g]);
                o || ("value" in u && void 0 !== (g = u.value) && (g !== t.value || "progress" === p && !g || "option" === p && g !== d.value) && Qi(t, "value", g, d.value, !1), "checked" in u && void 0 !== (g = u.checked) && g !== t.checked && Qi(t, "checked", g, d.checked, !1))
            }
            return t
        }

        function sa(t, e, i) {
            try {
                "function" == typeof t ? t(e) : t.current = e
            } catch (t) {
                Pi.__e(t, i)
            }
        }

        function na(t, e, i) {
            var a, s;
            if (Pi.unmount && Pi.unmount(t), (a = t.ref) && (a.current && a.current !== t.__e || sa(a, null, e)), null != (a = t.__c)) {
                if (a.componentWillUnmount) try {
                    a.componentWillUnmount()
                } catch (t) {
                    Pi.__e(t, e)
                }
                a.base = a.__P = null
            }
            if (a = t.__k)
                for (s = 0; s < a.length; s++) a[s] && na(a[s], e, "function" != typeof t.type);
            i || null == t.__e || Yi(t.__e), t.__e = t.__d = void 0
        }

        function ra(t, e, i) {
            return this.constructor(t, i)
        }

        function oa(t, e, i) {
            var a, s, n;
            Pi.__ && Pi.__(t, e), s = (a = "function" == typeof i) ? null : i && i.__k || e.__k, n = [], ea(e, t = (!a && i || e).__k = Fi(Wi, null, [t]), s || Di, Di, void 0 !== e.ownerSVGElement, !a && i ? [i] : s ? null : e.firstChild ? Ti.call(e.childNodes) : null, n, !a && i ? i : s ? s.__e : e.firstChild, a), ia(n, t)
        }

        function la() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (function(t) {
                var e = 16 * Math.random() | 0;
                return ("x" == t ? e : 3 & e | 8).toString(16)
            }))
        }
        Ti = Xi.slice, Pi = {
            __e: function(t, e, i, a) {
                for (var s, n, r; e = e.__;)
                    if ((s = e.__c) && !s.__) try {
                        if ((n = s.constructor) && null != n.getDerivedStateFromError && (s.setState(n.getDerivedStateFromError(t)), r = s.__d), null != s.componentDidCatch && (s.componentDidCatch(t, a || {}), r = s.__d), r) return s.__E = s
                    } catch (e) {
                        t = e
                    }
                throw t
            }
        }, Mi = 0, Li = function(t) {
            return null != t && void 0 === t.constructor
        }, Bi.prototype.setState = function(t, e) {
            var i;
            i = null != this.__s && this.__s !== this.state ? this.__s : this.__s = Ni({}, this.state), "function" == typeof t && (t = t(Ni({}, i), this.props)), t && Ni(i, t), null != t && this.__v && (e && this.__h.push(e), Vi(this))
        }, Bi.prototype.forceUpdate = function(t) {
            this.__v && (this.__e = !0, t && this.__h.push(t), Vi(this))
        }, Bi.prototype.render = Wi, Ii = [], ji.__r = 0, zi = 0;
        var ca = function() {
                function t(t) {
                    this._id = void 0, this._id = t || la()
                }
                return yi(t, [{
                    key: "id",
                    get: function() {
                        return this._id
                    }
                }]), t
            }(),
            ha = {
                search: {
                    placeholder: "Type a keyword..."
                },
                sort: {
                    sortAsc: "Sort column ascending",
                    sortDesc: "Sort column descending"
                },
                pagination: {
                    previous: "Previous",
                    next: "Next",
                    navigate: function(t, e) {
                        return "Page " + t + " of " + e
                    },
                    page: function(t) {
                        return "Page " + t
                    },
                    showing: "Showing",
                    of: "of",
                    to: "to",
                    results: "results"
                },
                loading: "Loading...",
                noRecordsFound: "No matching records found",
                error: "An error happened while fetching the data"
            },
            da = function() {
                function t(t) {
                    this._language = void 0, this._defaultLanguage = void 0, this._language = t, this._defaultLanguage = ha
                }
                var e = t.prototype;
                return e.getString = function(t, e) {
                    if (!e || !t) return null;
                    var i = t.split("."),
                        a = i[0];
                    if (e[a]) {
                        var s = e[a];
                        return "string" == typeof s ? function() {
                            return s
                        } : "function" == typeof s ? s : this.getString(i.slice(1).join("."), s)
                    }
                    return null
                }, e.translate = function(t) {
                    var e, i = this.getString(t, this._language);
                    return (e = i || this.getString(t, this._defaultLanguage)) ? e.apply(void 0, [].slice.call(arguments, 1)) : t
                }, t
            }(),
            ua = function(t) {
                function e(e, i) {
                    var a, s;
                    return (a = t.call(this, e, i) || this).config = void 0, a._ = void 0, a.config = function(t) {
                        if (!t) return null;
                        var e = Object.keys(t);
                        return e.length ? t[e[0]].props.value : null
                    }(i), a.config && (a._ = (s = a.config.translator, function(t) {
                        return s.translate.apply(s, [t].concat([].slice.call(arguments, 1)))
                    })), a
                }
                return Si(e, t), e
            }(Bi),
            pa = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype.render = function() {
                    return Fi(this.props.parentElement, {
                        dangerouslySetInnerHTML: {
                            __html: this.props.content
                        }
                    })
                }, e
            }(ua);

        function ga(t, e) {
            return Fi(pa, {
                content: t,
                parentElement: e
            })
        }
        pa.defaultProps = {
            parentElement: "span"
        };
        var fa, ma = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this).data = void 0, i.update(e), i
                }
                Si(e, t);
                var i = e.prototype;
                return i.cast = function(t) {
                    return t instanceof HTMLElement ? ga(t.outerHTML) : t
                }, i.update = function(t) {
                    return this.data = this.cast(t), this
                }, e
            }(ca),
            xa = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this)._cells = void 0, i.cells = e || [], i
                }
                Si(e, t);
                var i = e.prototype;
                return i.cell = function(t) {
                    return this._cells[t]
                }, i.toArray = function() {
                    return this.cells.map((function(t) {
                        return t.data
                    }))
                }, e.fromCells = function(t) {
                    return new e(t.map((function(t) {
                        return new ma(t.data)
                    })))
                }, yi(e, [{
                    key: "cells",
                    get: function() {
                        return this._cells
                    },
                    set: function(t) {
                        this._cells = t
                    }
                }, {
                    key: "length",
                    get: function() {
                        return this.cells.length
                    }
                }]), e
            }(ca),
            va = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this)._rows = void 0, i._length = void 0, i.rows = e instanceof Array ? e : e instanceof xa ? [e] : [], i
                }
                return Si(e, t), e.prototype.toArray = function() {
                    return this.rows.map((function(t) {
                        return t.toArray()
                    }))
                }, e.fromRows = function(t) {
                    return new e(t.map((function(t) {
                        return xa.fromCells(t.cells)
                    })))
                }, e.fromArray = function(t) {
                    return new e((t = function(t) {
                        return !t[0] || t[0] instanceof Array ? t : [t]
                    }(t)).map((function(t) {
                        return new xa(t.map((function(t) {
                            return new ma(t)
                        })))
                    })))
                }, yi(e, [{
                    key: "rows",
                    get: function() {
                        return this._rows
                    },
                    set: function(t) {
                        this._rows = t
                    }
                }, {
                    key: "length",
                    get: function() {
                        return this._length || this.rows.length
                    },
                    set: function(t) {
                        this._length = t
                    }
                }]), e
            }(ca),
            ba = function() {
                function t() {
                    this.callbacks = void 0
                }
                var e = t.prototype;
                return e.init = function(t) {
                    this.callbacks || (this.callbacks = {}), t && !this.callbacks[t] && (this.callbacks[t] = [])
                }, e.on = function(t, e) {
                    return this.init(t), this.callbacks[t].push(e), this
                }, e.off = function(t, e) {
                    var i = t;
                    return this.init(), this.callbacks[i] && 0 !== this.callbacks[i].length ? (this.callbacks[i] = this.callbacks[i].filter((function(t) {
                        return t != e
                    })), this) : this
                }, e.emit = function(t) {
                    var e = arguments,
                        i = t;
                    return this.init(i), this.callbacks[i].length > 0 && (this.callbacks[i].forEach((function(t) {
                        return t.apply(void 0, [].slice.call(e, 1))
                    })), !0)
                }, t
            }();
        ! function(t) {
            t[t.Initiator = 0] = "Initiator", t[t.ServerFilter = 1] = "ServerFilter", t[t.ServerSort = 2] = "ServerSort", t[t.ServerLimit = 3] = "ServerLimit", t[t.Extractor = 4] = "Extractor", t[t.Transformer = 5] = "Transformer", t[t.Filter = 6] = "Filter", t[t.Sort = 7] = "Sort", t[t.Limit = 8] = "Limit"
        }(fa || (fa = {}));
        var ya = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this).id = void 0, i._props = void 0, i._props = {}, i.id = la(), e && i.setProps(e), i
                }
                Si(e, t);
                var i = e.prototype;
                return i.process = function() {
                    var t = [].slice.call(arguments);
                    this.validateProps instanceof Function && this.validateProps.apply(this, t), this.emit.apply(this, ["beforeProcess"].concat(t));
                    var e = this._process.apply(this, t);
                    return this.emit.apply(this, ["afterProcess"].concat(t)), e
                }, i.setProps = function(t) {
                    return Object.assign(this._props, t), this.emit("propsUpdated", this), this
                }, yi(e, [{
                    key: "props",
                    get: function() {
                        return this._props
                    }
                }]), e
            }(ba),
            wa = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function(t) {
                    return this.props.keyword ? (e = String(this.props.keyword).trim(), i = this.props.columns, a = this.props.ignoreHiddenColumns, s = t, n = this.props.selector, e = e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&"), new va(s.rows.filter((function(t, s) {
                        return t.cells.some((function(t, r) {
                            if (!t) return !1;
                            if (a && i && i[r] && "object" == typeof i[r] && i[r].hidden) return !1;
                            var o = "";
                            if ("function" == typeof n) o = n(t.data, s, r);
                            else if ("object" == typeof t.data) {
                                var l = t.data;
                                l && l.props && l.props.content && (o = l.props.content)
                            } else o = String(t.data);
                            return new RegExp(e, "gi").test(o)
                        }))
                    })))) : t;
                    var e, i, a, s, n
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Filter
                    }
                }]), e
            }(ya);

        function Sa() {
            var t = "gridjs";
            return "" + t + [].slice.call(arguments).reduce((function(t, e) {
                return t + "-" + e
            }), "")
        }

        function Ca() {
            return [].slice.call(arguments).filter((function(t) {
                return t
            })).reduce((function(t, e) {
                return (t || "") + " " + e
            }), "").trim() || null
        }
        var ka, Aa = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this)._state = void 0, i.dispatcher = void 0, i.dispatcher = e, i._state = i.getInitialState(), e.register(i._handle.bind(ki(i))), i
                }
                Si(e, t);
                var i = e.prototype;
                return i._handle = function(t) {
                    this.handle(t.type, t.payload)
                }, i.setState = function(t) {
                    var e = this._state;
                    this._state = t, this.emit("updated", t, e)
                }, yi(e, [{
                    key: "state",
                    get: function() {
                        return this._state
                    }
                }]), e
            }(ba),
            Ea = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.getInitialState = function() {
                    return {
                        keyword: null
                    }
                }, i.handle = function(t, e) {
                    "SEARCH_KEYWORD" === t && this.search(e.keyword)
                }, i.search = function(t) {
                    this.setState({
                        keyword: t
                    })
                }, e
            }(Aa),
            Ta = function() {
                function t(t) {
                    this.dispatcher = void 0, this.dispatcher = t
                }
                return t.prototype.dispatch = function(t, e) {
                    this.dispatcher.dispatch({
                        type: t,
                        payload: e
                    })
                }, t
            }(),
            Pa = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype.search = function(t) {
                    this.dispatch("SEARCH_KEYWORD", {
                        keyword: t
                    })
                }, e
            }(Ta),
            Ma = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function(t) {
                    if (!this.props.keyword) return t;
                    var e = {};
                    return this.props.url && (e.url = this.props.url(t.url, this.props.keyword)), this.props.body && (e.body = this.props.body(t.body, this.props.keyword)), wi({}, t, e)
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.ServerFilter
                    }
                }]), e
            }(ya),
            La = new(function() {
                function t() {}
                var e = t.prototype;
                return e.format = function(t, e) {
                    return "[Grid.js] [" + e.toUpperCase() + "]: " + t
                }, e.error = function(t, e) {
                    void 0 === e && (e = !1);
                    var i = this.format(t, "error");
                    if (e) throw Error(i);
                    console.error(i)
                }, e.warn = function(t) {
                    console.warn(this.format(t, "warn"))
                }, e.info = function(t) {
                    console.info(this.format(t, "info"))
                }, t
            }()),
            Ia = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e
            }(ua);
        ! function(t) {
            t[t.Header = 0] = "Header", t[t.Footer = 1] = "Footer", t[t.Cell = 2] = "Cell"
        }(ka || (ka = {}));
        var _a = function() {
                function t() {
                    this.plugins = void 0, this.plugins = []
                }
                var e = t.prototype;
                return e.get = function(t) {
                    var e = this.plugins.filter((function(e) {
                        return e.id === t
                    }));
                    return e.length > 0 ? e[0] : null
                }, e.add = function(t) {
                    return t.id ? null !== this.get(t.id) ? (La.error("Duplicate plugin ID: " + t.id), this) : (this.plugins.push(t), this) : (La.error("Plugin ID cannot be empty"), this)
                }, e.remove = function(t) {
                    return this.plugins.splice(this.plugins.indexOf(this.get(t)), 1), this
                }, e.list = function(t) {
                    return (null != t || null != t ? this.plugins.filter((function(e) {
                        return e.position === t
                    })) : this.plugins).sort((function(t, e) {
                        return t.order - e.order
                    }))
                }, t
            }(),
            za = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype.render = function() {
                    var t = this;
                    if (this.props.pluginId) {
                        var e = this.config.plugin.get(this.props.pluginId);
                        return e ? Fi(Wi, {}, Fi(e.component, wi({
                            plugin: e
                        }, e.props, this.props.props))) : null
                    }
                    return void 0 !== this.props.position ? Fi(Wi, {}, this.config.plugin.list(this.props.position).map((function(e) {
                        return Fi(e.component, wi({
                            plugin: e
                        }, e.props, t.props.props))
                    }))) : null
                }, e
            }(ua),
            Da = function(t) {
                function e(e, i) {
                    var a;
                    (a = t.call(this, e, i) || this).searchProcessor = void 0, a.actions = void 0, a.store = void 0, a.storeUpdatedFn = void 0, a.actions = new Pa(a.config.dispatcher), a.store = new Ea(a.config.dispatcher);
                    var s, n = e.keyword;
                    return e.enabled && (n && a.actions.search(n), a.storeUpdatedFn = a.storeUpdated.bind(ki(a)), a.store.on("updated", a.storeUpdatedFn), s = e.server ? new Ma({
                        keyword: e.keyword,
                        url: e.server.url,
                        body: e.server.body
                    }) : new wa({
                        keyword: e.keyword,
                        columns: a.config.header && a.config.header.columns,
                        ignoreHiddenColumns: e.ignoreHiddenColumns || void 0 === e.ignoreHiddenColumns,
                        selector: e.selector
                    }), a.searchProcessor = s, a.config.pipeline.register(s)), a
                }
                Si(e, t);
                var i = e.prototype;
                return i.componentWillUnmount = function() {
                    this.config.pipeline.unregister(this.searchProcessor), this.store.off("updated", this.storeUpdatedFn)
                }, i.storeUpdated = function(t) {
                    this.searchProcessor.setProps({
                        keyword: t.keyword
                    })
                }, i.onChange = function(t) {
                    this.actions.search(t.target.value)
                }, i.render = function() {
                    if (!this.props.enabled) return null;
                    var t, e, i, a = this.onChange.bind(this);
                    return this.searchProcessor instanceof Ma && (t = a, e = this.props.debounceTimeout, a = function() {
                        var a = arguments;
                        return new Promise((function(s) {
                            i && clearTimeout(i), i = setTimeout((function() {
                                return s(t.apply(void 0, [].slice.call(a)))
                            }), e)
                        }))
                    }), Fi("div", {
                        className: Sa(Ca("search", this.config.className.search))
                    }, Fi("input", {
                        type: "search",
                        placeholder: this._("search.placeholder"),
                        "aria-label": this._("search.placeholder"),
                        onInput: a,
                        className: Ca(Sa("input"), Sa("search", "input")),
                        value: this.store.state.keyword
                    }))
                }, e
            }(Ia);
        Da.defaultProps = {
            debounceTimeout: 250
        };
        var Xa = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.validateProps = function() {
                    if (isNaN(Number(this.props.limit)) || isNaN(Number(this.props.page))) throw Error("Invalid parameters passed")
                }, i._process = function(t) {
                    var e = this.props.page;
                    return new va(t.rows.slice(e * this.props.limit, (e + 1) * this.props.limit))
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Limit
                    }
                }]), e
            }(ya),
            Oa = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function(t) {
                    var e = {};
                    return this.props.url && (e.url = this.props.url(t.url, this.props.page, this.props.limit)), this.props.body && (e.body = this.props.body(t.body, this.props.page, this.props.limit)), wi({}, t, e)
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.ServerLimit
                    }
                }]), e
            }(ya),
            Na = function(t) {
                function e(e, i) {
                    var a;
                    return (a = t.call(this, e, i) || this).processor = void 0, a.onUpdateFn = void 0, a.setTotalFromTabularFn = void 0, a.state = {
                        limit: e.limit,
                        page: e.page || 0,
                        total: 0
                    }, a
                }
                Si(e, t);
                var i = e.prototype;
                return i.componentWillMount = function() {
                    var t, e = this;
                    this.props.enabled && (this.setTotalFromTabularFn = this.setTotalFromTabular.bind(this), this.props.server ? (t = new Oa({
                        limit: this.state.limit,
                        page: this.state.page,
                        url: this.props.server.url,
                        body: this.props.server.body
                    }), this.config.pipeline.on("afterProcess", this.setTotalFromTabularFn)) : (t = new Xa({
                        limit: this.state.limit,
                        page: this.state.page
                    })).on("beforeProcess", this.setTotalFromTabularFn), this.processor = t, this.config.pipeline.register(t), this.config.pipeline.on("error", (function() {
                        e.setState({
                            total: 0,
                            page: 0
                        })
                    })))
                }, i.setTotalFromTabular = function(t) {
                    this.setTotal(t.length)
                }, i.onUpdate = function(t) {
                    this.props.resetPageOnUpdate && t !== this.processor && this.setPage(0)
                }, i.componentDidMount = function() {
                    this.onUpdateFn = this.onUpdate.bind(this), this.config.pipeline.on("updated", this.onUpdateFn)
                }, i.componentWillUnmount = function() {
                    this.config.pipeline.unregister(this.processor), this.config.pipeline.off("updated", this.onUpdateFn)
                }, i.setPage = function(t) {
                    if (t >= this.pages || t < 0 || t === this.state.page) return null;
                    this.setState({
                        page: t
                    }), this.processor.setProps({
                        page: t
                    })
                }, i.setTotal = function(t) {
                    this.setState({
                        total: t
                    })
                }, i.renderPages = function() {
                    var t = this;
                    if (this.props.buttonsCount <= 0) return null;
                    var e = Math.min(this.pages, this.props.buttonsCount),
                        i = Math.min(this.state.page, Math.floor(e / 2));
                    return this.state.page + Math.floor(e / 2) >= this.pages && (i = e - (this.pages - this.state.page)), Fi(Wi, null, this.pages > e && this.state.page - i > 0 && Fi(Wi, null, Fi("button", {
                        tabIndex: 0,
                        role: "button",
                        onClick: this.setPage.bind(this, 0),
                        title: this._("pagination.firstPage"),
                        "aria-label": this._("pagination.firstPage"),
                        className: this.config.className.paginationButton
                    }, this._("1")), Fi("button", {
                        tabIndex: -1,
                        className: Ca(Sa("spread"), this.config.className.paginationButton)
                    }, "...")), Array.from(Array(e).keys()).map((function(e) {
                        return t.state.page + (e - i)
                    })).map((function(e) {
                        return Fi("button", {
                            tabIndex: 0,
                            role: "button",
                            onClick: t.setPage.bind(t, e),
                            className: Ca(t.state.page === e ? Ca(Sa("currentPage"), t.config.className.paginationButtonCurrent) : null, t.config.className.paginationButton),
                            title: t._("pagination.page", e + 1),
                            "aria-label": t._("pagination.page", e + 1)
                        }, t._("" + (e + 1)))
                    })), this.pages > e && this.pages > this.state.page + i + 1 && Fi(Wi, null, Fi("button", {
                        tabIndex: -1,
                        className: Ca(Sa("spread"), this.config.className.paginationButton)
                    }, "..."), Fi("button", {
                        tabIndex: 0,
                        role: "button",
                        onClick: this.setPage.bind(this, this.pages - 1),
                        title: this._("pagination.page", this.pages),
                        "aria-label": this._("pagination.page", this.pages),
                        className: this.config.className.paginationButton
                    }, this._("" + this.pages))))
                }, i.renderSummary = function() {
                    return Fi(Wi, null, this.props.summary && this.state.total > 0 && Fi("div", {
                        role: "status",
                        "aria-live": "polite",
                        className: Ca(Sa("summary"), this.config.className.paginationSummary),
                        title: this._("pagination.navigate", this.state.page + 1, this.pages)
                    }, this._("pagination.showing"), " ", Fi("b", null, this._("" + (this.state.page * this.state.limit + 1))), " ", this._("pagination.to"), " ", Fi("b", null, this._("" + Math.min((this.state.page + 1) * this.state.limit, this.state.total))), " ", this._("pagination.of"), " ", Fi("b", null, this._("" + this.state.total)), " ", this._("pagination.results")))
                }, i.render = function() {
                    return this.props.enabled ? Fi("div", {
                        className: Ca(Sa("pagination"), this.config.className.pagination)
                    }, this.renderSummary(), Fi("div", {
                        className: Sa("pages")
                    }, this.props.prevButton && Fi("button", {
                        tabIndex: 0,
                        role: "button",
                        disabled: 0 === this.state.page,
                        onClick: this.setPage.bind(this, this.state.page - 1),
                        title: this._("pagination.previous"),
                        "aria-label": this._("pagination.previous"),
                        className: Ca(this.config.className.paginationButton, this.config.className.paginationButtonPrev)
                    }, this._("pagination.previous")), this.renderPages(), this.props.nextButton && Fi("button", {
                        tabIndex: 0,
                        role: "button",
                        disabled: this.pages === this.state.page + 1 || 0 === this.pages,
                        onClick: this.setPage.bind(this, this.state.page + 1),
                        title: this._("pagination.next"),
                        "aria-label": this._("pagination.next"),
                        className: Ca(this.config.className.paginationButton, this.config.className.paginationButtonNext)
                    }, this._("pagination.next")))) : null
                }, yi(e, [{
                    key: "pages",
                    get: function() {
                        return Math.ceil(this.state.total / this.state.limit)
                    }
                }]), e
            }(Ia);

        function Ya(t, e) {
            return "string" == typeof t ? t.indexOf("%") > -1 ? e / 100 * parseInt(t, 10) : parseInt(t, 10) : t
        }

        function Fa(t) {
            return t ? Math.floor(t) + "px" : ""
        }
        Na.defaultProps = {
            summary: !0,
            nextButton: !0,
            prevButton: !0,
            buttonsCount: 3,
            limit: 10,
            resetPageOnUpdate: !0
        };
        var Ra = function(t) {
            function e(e, i) {
                var a;
                return (a = t.call(this, e, i) || this).tableElement = void 0, a.tableClassName = void 0, a.tableStyle = void 0, a.tableElement = a.props.tableRef.current.base.cloneNode(!0), a.tableElement.style.position = "absolute", a.tableElement.style.width = "100%", a.tableElement.style.zIndex = "-2147483640", a.tableElement.style.visibility = "hidden", a.tableClassName = a.tableElement.className, a.tableStyle = a.tableElement.style.cssText, a
            }
            Si(e, t);
            var i = e.prototype;
            return i.widths = function() {
                this.tableElement.className = this.tableClassName + " " + Sa("shadowTable"), this.tableElement.style.tableLayout = "auto", this.tableElement.style.width = "auto", this.tableElement.style.padding = "0", this.tableElement.style.margin = "0", this.tableElement.style.border = "none", this.tableElement.style.outline = "none";
                var t = Array.from(this.base.parentNode.querySelectorAll("thead th")).reduce((function(t, e) {
                    var i;
                    return e.style.width = e.clientWidth + "px", wi(((i = {})[e.getAttribute("data-column-id")] = {
                        minWidth: e.clientWidth
                    }, i), t)
                }), {});
                return this.tableElement.className = this.tableClassName, this.tableElement.style.cssText = this.tableStyle, this.tableElement.style.tableLayout = "auto", Array.from(this.base.parentNode.querySelectorAll("thead th")).reduce((function(t, e) {
                    return t[e.getAttribute("data-column-id")].width = e.clientWidth, t
                }), t)
            }, i.render = function() {
                var t = this;
                return this.props.tableRef.current ? Fi("div", {
                    ref: function(e) {
                        e && e.appendChild(t.tableElement)
                    }
                }) : null
            }, e
        }(ua);

        function Ha(t) {
            if (!t) return "";
            var e = t.split(" ");
            return 1 === e.length && /([a-z][A-Z])+/g.test(t) ? t : e.map((function(t, e) {
                return 0 == e ? t.toLowerCase() : t.charAt(0).toUpperCase() + t.slice(1).toLowerCase()
            })).join("")
        }
        var Wa = function(t) {
                function e() {
                    var e;
                    return (e = t.call(this) || this)._columns = void 0, e._columns = [], e
                }
                Si(e, t);
                var i = e.prototype;
                return i.adjustWidth = function(t) {
                    var i = t.container,
                        a = t.tableRef,
                        s = t.tempRef,
                        n = t.tempRef || !0;
                    if (!i) return this;
                    var r = i.clientWidth,
                        o = {
                            current: null
                        },
                        l = {};
                    if (a.current && n) {
                        var c = Fi(Ra, {
                            tableRef: a
                        });
                        c.ref = o, oa(c, s.current), l = o.current.widths()
                    }
                    for (var h, d = Ei(e.tabularFormat(this.columns).reduce((function(t, e) {
                            return t.concat(e)
                        }), [])); !(h = d()).done;) {
                        var u = h.value;
                        u.columns && u.columns.length > 0 || (!u.width && n ? u.id in l && (u.width = Fa(l[u.id].width), u.minWidth = Fa(l[u.id].minWidth)) : u.width = Fa(Ya(u.width, r)))
                    }
                    return a.current && n && oa(null, s.current), this
                }, i.setSort = function(t, e) {
                    for (var i, a = Ei(e || this.columns || []); !(i = a()).done;) {
                        var s = i.value;
                        s.columns && s.columns.length > 0 && (s.sort = {
                            enabled: !1
                        }), void 0 === s.sort && t.sort && (s.sort = {
                            enabled: !0
                        }), s.sort ? "object" == typeof s.sort && (s.sort = wi({
                            enabled: !0
                        }, s.sort)) : s.sort = {
                            enabled: !1
                        }, s.columns && this.setSort(t, s.columns)
                    }
                }, i.setFixedHeader = function(t, e) {
                    for (var i, a = Ei(e || this.columns || []); !(i = a()).done;) {
                        var s = i.value;
                        void 0 === s.fixedHeader && (s.fixedHeader = t.fixedHeader), s.columns && this.setFixedHeader(t, s.columns)
                    }
                }, i.setResizable = function(t, e) {
                    for (var i, a = Ei(e || this.columns || []); !(i = a()).done;) {
                        var s = i.value;
                        void 0 === s.resizable && (s.resizable = t.resizable), s.columns && this.setResizable(t, s.columns)
                    }
                }, i.setID = function(t) {
                    for (var e, i = Ei(t || this.columns || []); !(e = i()).done;) {
                        var a = e.value;
                        a.id || "string" != typeof a.name || (a.id = Ha(a.name)), a.id || La.error('Could not find a valid ID for one of the columns. Make sure a valid "id" is set for all columns.'), a.columns && this.setID(a.columns)
                    }
                }, i.populatePlugins = function(t, e) {
                    for (var i, a = Ei(e); !(i = a()).done;) {
                        var s = i.value;
                        void 0 !== s.plugin && t.plugin.add(wi({
                            id: s.id,
                            props: {}
                        }, s.plugin, {
                            position: ka.Cell
                        }))
                    }
                }, e.fromColumns = function(t) {
                    for (var i, a = new e, s = Ei(t); !(i = s()).done;) {
                        var n = i.value;
                        if ("string" == typeof n || Li(n)) a.columns.push({
                            name: n
                        });
                        else if ("object" == typeof n) {
                            var r = n;
                            r.columns && (r.columns = e.fromColumns(r.columns).columns), "object" == typeof r.plugin && void 0 === r.data && (r.data = null), a.columns.push(n)
                        }
                    }
                    return a
                }, e.fromUserConfig = function(t) {
                    var i = new e;
                    return t.from ? i.columns = e.fromHTMLTable(t.from).columns : t.columns ? i.columns = e.fromColumns(t.columns).columns : !t.data || "object" != typeof t.data[0] || t.data[0] instanceof Array || (i.columns = Object.keys(t.data[0]).map((function(t) {
                        return {
                            name: t
                        }
                    }))), i.columns.length ? (i.setID(), i.setSort(t), i.setFixedHeader(t), i.setResizable(t), i.populatePlugins(t, i.columns), i) : null
                }, e.fromHTMLTable = function(t) {
                    for (var i, a = new e, s = Ei(t.querySelector("thead").querySelectorAll("th")); !(i = s()).done;) {
                        var n = i.value;
                        a.columns.push({
                            name: n.innerHTML,
                            width: n.width
                        })
                    }
                    return a
                }, e.tabularFormat = function(t) {
                    var e = [],
                        i = t || [],
                        a = [];
                    if (i && i.length) {
                        e.push(i);
                        for (var s, n = Ei(i); !(s = n()).done;) {
                            var r = s.value;
                            r.columns && r.columns.length && (a = a.concat(r.columns))
                        }
                        a.length && (e = e.concat(this.tabularFormat(a)))
                    }
                    return e
                }, e.leafColumns = function(t) {
                    var e = [],
                        i = t || [];
                    if (i && i.length)
                        for (var a, s = Ei(i); !(a = s()).done;) {
                            var n = a.value;
                            n.columns && 0 !== n.columns.length || e.push(n), n.columns && (e = e.concat(this.leafColumns(n.columns)))
                        }
                    return e
                }, e.maximumDepth = function(t) {
                    return this.tabularFormat([t]).length - 1
                }, yi(e, [{
                    key: "columns",
                    get: function() {
                        return this._columns
                    },
                    set: function(t) {
                        this._columns = t
                    }
                }, {
                    key: "visibleColumns",
                    get: function() {
                        return this._columns.filter((function(t) {
                            return !t.hidden
                        }))
                    }
                }]), e
            }(ca),
            Ba = function() {
                function t() {
                    this._callbacks = void 0, this._isDispatching = void 0, this._isHandled = void 0, this._isPending = void 0, this._lastID = void 0, this._pendingPayload = void 0, this._callbacks = {}, this._isDispatching = !1, this._isHandled = {}, this._isPending = {}, this._lastID = 1
                }
                var e = t.prototype;
                return e.register = function(t) {
                    var e = "ID_" + this._lastID++;
                    return this._callbacks[e] = t, e
                }, e.unregister = function(t) {
                    if (!this._callbacks[t]) throw Error("Dispatcher.unregister(...): " + t + " does not map to a registered callback.");
                    delete this._callbacks[t]
                }, e.waitFor = function(t) {
                    if (!this._isDispatching) throw Error("Dispatcher.waitFor(...): Must be invoked while dispatching.");
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e];
                        if (this._isPending[i]) {
                            if (!this._isHandled[i]) throw Error("Dispatcher.waitFor(...): Circular dependency detected while ' +\n            'waiting for " + i + ".")
                        } else {
                            if (!this._callbacks[i]) throw Error("Dispatcher.waitFor(...): " + i + " does not map to a registered callback.");
                            this._invokeCallback(i)
                        }
                    }
                }, e.dispatch = function(t) {
                    if (this._isDispatching) throw Error("Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.");
                    this._startDispatching(t);
                    try {
                        for (var e in this._callbacks) this._isPending[e] || this._invokeCallback(e)
                    } finally {
                        this._stopDispatching()
                    }
                }, e.isDispatching = function() {
                    return this._isDispatching
                }, e._invokeCallback = function(t) {
                    this._isPending[t] = !0, this._callbacks[t](this._pendingPayload), this._isHandled[t] = !0
                }, e._startDispatching = function(t) {
                    for (var e in this._callbacks) this._isPending[e] = !1, this._isHandled[e] = !1;
                    this._pendingPayload = t, this._isDispatching = !0
                }, e._stopDispatching = function() {
                    delete this._pendingPayload, this._isDispatching = !1
                }, t
            }(),
            $a = function() {},
            Ga = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this).data = void 0, i.set(e), i
                }
                Si(e, t);
                var i = e.prototype;
                return i.get = function() {
                    try {
                        return Promise.resolve(this.data()).then((function(t) {
                            return {
                                data: t,
                                total: t.length
                            }
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, i.set = function(t) {
                    return t instanceof Array ? this.data = function() {
                        return t
                    } : t instanceof Function && (this.data = t), this
                }, e
            }($a),
            Va = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this).options = void 0, i.options = e, i
                }
                Si(e, t);
                var i = e.prototype;
                return i.handler = function(t) {
                    return "function" == typeof this.options.handle ? this.options.handle(t) : t.ok ? t.json() : (La.error("Could not fetch data: " + t.status + " - " + t.statusText, !0), null)
                }, i.get = function(t) {
                    var e = wi({}, this.options, t);
                    return "function" == typeof e.data ? e.data(e) : fetch(e.url, e).then(this.handler.bind(this)).then((function(t) {
                        return {
                            data: e.then(t),
                            total: "function" == typeof e.total ? e.total(t) : void 0
                        }
                    }))
                }, e
            }($a),
            ja = function() {
                function t() {}
                return t.createFromUserConfig = function(t) {
                    var e = null;
                    return t.data && (e = new Ga(t.data)), t.from && (e = new Ga(this.tableElementToArray(t.from)), t.from.style.display = "none"), t.server && (e = new Va(t.server)), e || La.error("Could not determine the storage type", !0), e
                }, t.tableElementToArray = function(t) {
                    for (var e, i, a = [], s = Ei(t.querySelector("tbody").querySelectorAll("tr")); !(e = s()).done;) {
                        for (var n, r = [], o = Ei(e.value.querySelectorAll("td")); !(n = o()).done;) {
                            var l = n.value;
                            1 === l.childNodes.length && l.childNodes[0].nodeType === Node.TEXT_NODE ? r.push((i = l.innerHTML, (new DOMParser).parseFromString(i, "text/html").documentElement.textContent)) : r.push(ga(l.innerHTML))
                        }
                        a.push(r)
                    }
                    return a
                }, t
            }(),
            Ua = "undefined" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";

        function qa(t, e, i) {
            if (!t.s) {
                if (i instanceof Za) {
                    if (!i.s) return void(i.o = qa.bind(null, t, e));
                    1 & e && (e = i.s), i = i.v
                }
                if (i && i.then) return void i.then(qa.bind(null, t, e), qa.bind(null, t, 2));
                t.s = e, t.v = i;
                var a = t.o;
                a && a(t)
            }
        }
        var Za = function() {
            function t() {}
            return t.prototype.then = function(e, i) {
                var a = new t,
                    s = this.s;
                if (s) {
                    var n = 1 & s ? e : i;
                    if (n) {
                        try {
                            qa(a, 1, n(this.v))
                        } catch (t) {
                            qa(a, 2, t)
                        }
                        return a
                    }
                    return this
                }
                return this.o = function(t) {
                    try {
                        var s = t.v;
                        1 & t.s ? qa(a, 1, e ? e(s) : s) : i ? qa(a, 1, i(s)) : qa(a, 2, s)
                    } catch (t) {
                        qa(a, 2, t)
                    }
                }, a
            }, t
        }();

        function Ka(t) {
            return t instanceof Za && 1 & t.s
        }
        var Qa, Ja = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this)._steps = new Map, i.cache = new Map, i.lastProcessorIndexUpdated = -1, e && e.forEach((function(t) {
                        return i.register(t)
                    })), i
                }
                Si(e, t);
                var i = e.prototype;
                return i.clearCache = function() {
                    this.cache = new Map, this.lastProcessorIndexUpdated = -1
                }, i.register = function(t, e) {
                    if (void 0 === e && (e = null), null === t.type) throw Error("Processor type is not defined");
                    t.on("propsUpdated", this.processorPropsUpdated.bind(this)), this.addProcessorByPriority(t, e), this.afterRegistered(t)
                }, i.unregister = function(t) {
                    if (t) {
                        var e = this._steps.get(t.type);
                        e && e.length && (this._steps.set(t.type, e.filter((function(e) {
                            return e != t
                        }))), this.emit("updated", t))
                    }
                }, i.addProcessorByPriority = function(t, e) {
                    var i = this._steps.get(t.type);
                    if (!i) {
                        var a = [];
                        this._steps.set(t.type, a), i = a
                    }
                    if (null === e || e < 0) i.push(t);
                    else if (i[e]) {
                        var s = i.slice(0, e - 1),
                            n = i.slice(e + 1);
                        this._steps.set(t.type, s.concat(t).concat(n))
                    } else i[e] = t
                }, i.getStepsByType = function(t) {
                    return this.steps.filter((function(e) {
                        return e.type === t
                    }))
                }, i.getSortedProcessorTypes = function() {
                    return Object.keys(fa).filter((function(t) {
                        return !isNaN(Number(t))
                    })).map((function(t) {
                        return Number(t)
                    }))
                }, i.process = function(t) {
                    try {
                        var e = this,
                            i = function(t) {
                                return e.lastProcessorIndexUpdated = s.length, e.emit("afterProcess", n), n
                            },
                            a = e.lastProcessorIndexUpdated,
                            s = e.steps,
                            n = t,
                            r = function(t, i) {
                                try {
                                    var r = function(t, e, i) {
                                        if ("function" == typeof t[Ua]) {
                                            var a, s, n, r = t[Ua]();
                                            if (function t(i) {
                                                    try {
                                                        for (; !(a = r.next()).done;)
                                                            if ((i = e(a.value)) && i.then) {
                                                                if (!Ka(i)) return void i.then(t, n || (n = qa.bind(null, s = new Za, 2)));
                                                                i = i.v
                                                            }
                                                        s ? qa(s, 1, i) : s = i
                                                    } catch (t) {
                                                        qa(s || (s = new Za), 2, t)
                                                    }
                                                }(), r.return) {
                                                var o = function(t) {
                                                    try {
                                                        a.done || r.return()
                                                    } catch (t) {}
                                                    return t
                                                };
                                                if (s && s.then) return s.then(o, (function(t) {
                                                    throw o(t)
                                                }));
                                                o()
                                            }
                                            return s
                                        }
                                        if (!("length" in t)) throw new TypeError("Object is not iterable");
                                        for (var l = [], c = 0; c < t.length; c++) l.push(t[c]);
                                        return function(t, e, i) {
                                            var a, s, n = -1;
                                            return function i(r) {
                                                try {
                                                    for (; ++n < t.length;)
                                                        if ((r = e(n)) && r.then) {
                                                            if (!Ka(r)) return void r.then(i, s || (s = qa.bind(null, a = new Za, 2)));
                                                            r = r.v
                                                        }
                                                    a ? qa(a, 1, r) : a = r
                                                } catch (t) {
                                                    qa(a || (a = new Za), 2, t)
                                                }
                                            }(), a
                                        }(l, (function(t) {
                                            return e(l[t])
                                        }))
                                    }(s, (function(t) {
                                        var i = e.findProcessorIndexByID(t.id),
                                            s = function() {
                                                if (i >= a) return Promise.resolve(t.process(n)).then((function(i) {
                                                    e.cache.set(t.id, n = i)
                                                }));
                                                n = e.cache.get(t.id)
                                            }();
                                        if (s && s.then) return s.then((function() {}))
                                    }))
                                } catch (t) {
                                    return i(t)
                                }
                                return r && r.then ? r.then(void 0, i) : r
                            }(0, (function(t) {
                                throw La.error(t), e.emit("error", n), t
                            }));
                        return Promise.resolve(r && r.then ? r.then(i) : i())
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, i.findProcessorIndexByID = function(t) {
                    return this.steps.findIndex((function(e) {
                        return e.id == t
                    }))
                }, i.setLastProcessorIndex = function(t) {
                    var e = this.findProcessorIndexByID(t.id);
                    this.lastProcessorIndexUpdated > e && (this.lastProcessorIndexUpdated = e)
                }, i.processorPropsUpdated = function(t) {
                    this.setLastProcessorIndex(t), this.emit("propsUpdated"), this.emit("updated", t)
                }, i.afterRegistered = function(t) {
                    this.setLastProcessorIndex(t), this.emit("afterRegister"), this.emit("updated", t)
                }, yi(e, [{
                    key: "steps",
                    get: function() {
                        for (var t, e = [], i = Ei(this.getSortedProcessorTypes()); !(t = i()).done;) {
                            var a = this._steps.get(t.value);
                            a && a.length && (e = e.concat(a))
                        }
                        return e.filter((function(t) {
                            return t
                        }))
                    }
                }]), e
            }(ba),
            ts = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function(t) {
                    try {
                        return Promise.resolve(this.props.storage.get(t))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Extractor
                    }
                }]), e
            }(ya),
            es = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function(t) {
                    var e = va.fromArray(t.data);
                    return e.length = t.total, e
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Transformer
                    }
                }]), e
            }(ya),
            is = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function() {
                    return Object.entries(this.props.serverStorageOptions).filter((function(t) {
                        return "function" != typeof t[1]
                    })).reduce((function(t, e) {
                        var i;
                        return wi({}, t, ((i = {})[e[0]] = e[1], i))
                    }), {})
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Initiator
                    }
                }]), e
            }(ya),
            as = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.castData = function(t) {
                    if (!t || !t.length) return [];
                    if (!this.props.header || !this.props.header.columns) return t;
                    var e = Wa.leafColumns(this.props.header.columns);
                    return t[0] instanceof Array ? t.map((function(t) {
                        var i = 0;
                        return e.map((function(e, a) {
                            return void 0 !== e.data ? (i++, "function" == typeof e.data ? e.data(t) : e.data) : t[a - i]
                        }))
                    })) : "object" != typeof t[0] || t[0] instanceof Array ? [] : t.map((function(t) {
                        return e.map((function(e, i) {
                            return void 0 !== e.data ? "function" == typeof e.data ? e.data(t) : e.data : e.id ? t[e.id] : (La.error("Could not find the correct cell for column at position " + i + ".\n                          Make sure either 'id' or 'selector' is defined for all columns."), null)
                        }))
                    }))
                }, i._process = function(t) {
                    return {
                        data: this.castData(t.data),
                        total: t.total
                    }
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Transformer
                    }
                }]), e
            }(ya),
            ss = function() {
                function t() {}
                return t.createFromConfig = function(t) {
                    var e = new Ja;
                    return t.storage instanceof Va && e.register(new is({
                        serverStorageOptions: t.server
                    })), e.register(new ts({
                        storage: t.storage
                    })), e.register(new as({
                        header: t.header
                    })), e.register(new es), e
                }, t
            }(),
            ns = function() {
                function t(e) {
                    this._userConfig = void 0, Object.assign(this, wi({}, t.defaultConfig(), e)), this._userConfig = {}
                }
                var e = t.prototype;
                return e.assign = function(t) {
                    for (var e = 0, i = Object.keys(t); e < i.length; e++) {
                        var a = i[e];
                        "_userConfig" !== a && (this[a] = t[a])
                    }
                    return this
                }, e.update = function(e) {
                    return e ? (this._userConfig = wi({}, this._userConfig, e), this.assign(t.fromUserConfig(this._userConfig)), this) : this
                }, t.defaultConfig = function() {
                    return {
                        plugin: new _a,
                        dispatcher: new Ba,
                        tableRef: {
                            current: null
                        },
                        tempRef: {
                            current: null
                        },
                        width: "100%",
                        height: "auto",
                        autoWidth: !0,
                        style: {},
                        className: {}
                    }
                }, t.fromUserConfig = function(e) {
                    var i = new t(e);
                    return i._userConfig = e, "boolean" == typeof e.sort && e.sort && i.assign({
                        sort: {
                            multiColumn: !0
                        }
                    }), i.assign({
                        header: Wa.fromUserConfig(i)
                    }), i.assign({
                        storage: ja.createFromUserConfig(e)
                    }), i.assign({
                        pipeline: ss.createFromConfig(i)
                    }), i.assign({
                        translator: new da(e.language)
                    }), i.plugin.add({
                        id: "search",
                        position: ka.Header,
                        component: Da,
                        props: wi({
                            enabled: !0 === e.search || e.search instanceof Object
                        }, e.search)
                    }), i.plugin.add({
                        id: "pagination",
                        position: ka.Footer,
                        component: Na,
                        props: wi({
                            enabled: !0 === e.pagination || e.pagination instanceof Object
                        }, e.pagination)
                    }), e.plugins && e.plugins.forEach((function(t) {
                        return i.plugin.add(t)
                    })), i
                }, t
            }();
        ! function(t) {
            t[t.Init = 0] = "Init", t[t.Loading = 1] = "Loading", t[t.Loaded = 2] = "Loaded", t[t.Rendered = 3] = "Rendered", t[t.Error = 4] = "Error"
        }(Qa || (Qa = {}));
        var rs, os, ls, cs, hs = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.content = function() {
                    return this.props.column && "function" == typeof this.props.column.formatter ? this.props.column.formatter(this.props.cell.data, this.props.row, this.props.column) : this.props.column && this.props.column.plugin ? Fi(za, {
                        pluginId: this.props.column.id,
                        props: {
                            column: this.props.column,
                            cell: this.props.cell,
                            row: this.props.row
                        }
                    }) : this.props.cell.data
                }, i.handleClick = function(t) {
                    this.props.messageCell || this.config.eventEmitter.emit("cellClick", t, this.props.cell, this.props.column, this.props.row)
                }, i.getCustomAttributes = function(t) {
                    return t ? "function" == typeof t.attributes ? t.attributes(this.props.cell.data, this.props.row, this.props.column) : t.attributes : {}
                }, i.render = function() {
                    return Fi("td", wi({
                        role: this.props.role,
                        colSpan: this.props.colSpan,
                        "data-column-id": this.props.column && this.props.column.id,
                        className: Ca(Sa("td"), this.props.className, this.config.className.td),
                        style: wi({}, this.props.style, this.config.style.td),
                        onClick: this.handleClick.bind(this)
                    }, this.getCustomAttributes(this.props.column)), this.content())
                }, e
            }(ua),
            ds = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.getColumn = function(t) {
                    if (this.props.header) {
                        var e = Wa.leafColumns(this.props.header.columns);
                        if (e) return e[t]
                    }
                    return null
                }, i.handleClick = function(t) {
                    this.props.messageRow || this.config.eventEmitter.emit("rowClick", t, this.props.row)
                }, i.getChildren = function() {
                    var t = this;
                    return this.props.children ? this.props.children : Fi(Wi, null, this.props.row.cells.map((function(e, i) {
                        var a = t.getColumn(i);
                        return a && a.hidden ? null : Fi(hs, {
                            key: e.id,
                            cell: e,
                            row: t.props.row,
                            column: a
                        })
                    })))
                }, i.render = function() {
                    return Fi("tr", {
                        className: Ca(Sa("tr"), this.config.className.tr),
                        onClick: this.handleClick.bind(this)
                    }, this.getChildren())
                }, e
            }(ua),
            us = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype.render = function() {
                    return Fi(ds, {
                        messageRow: !0
                    }, Fi(hs, {
                        role: "alert",
                        colSpan: this.props.colSpan,
                        messageCell: !0,
                        cell: new ma(this.props.message),
                        className: Ca(Sa("message"), this.props.className ? this.props.className : null)
                    }))
                }, e
            }(ua),
            ps = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.headerLength = function() {
                    return this.props.header ? this.props.header.visibleColumns.length : 0
                }, i.render = function() {
                    var t = this;
                    return Fi("tbody", {
                        className: Ca(Sa("tbody"), this.config.className.tbody)
                    }, this.props.data && this.props.data.rows.map((function(e) {
                        return Fi(ds, {
                            key: e.id,
                            row: e,
                            header: t.props.header
                        })
                    })), this.props.status === Qa.Loading && (!this.props.data || 0 === this.props.data.length) && Fi(us, {
                        message: this._("loading"),
                        colSpan: this.headerLength(),
                        className: Ca(Sa("loading"), this.config.className.loading)
                    }), this.props.status === Qa.Rendered && this.props.data && 0 === this.props.data.length && Fi(us, {
                        message: this._("noRecordsFound"),
                        colSpan: this.headerLength(),
                        className: Ca(Sa("notfound"), this.config.className.notfound)
                    }), this.props.status === Qa.Error && Fi(us, {
                        message: this._("error"),
                        colSpan: this.headerLength(),
                        className: Ca(Sa("error"), this.config.className.error)
                    }))
                }, e
            }(ua),
            gs = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.validateProps = function() {
                    for (var t, e = Ei(this.props.columns); !(t = e()).done;) {
                        var i = t.value;
                        void 0 === i.direction && (i.direction = 1), 1 !== i.direction && -1 !== i.direction && La.error("Invalid sort direction " + i.direction)
                    }
                }, i.compare = function(t, e) {
                    return t > e ? 1 : t < e ? -1 : 0
                }, i.compareWrapper = function(t, e) {
                    for (var i, a = 0, s = Ei(this.props.columns); !(i = s()).done;) {
                        var n = i.value;
                        if (0 !== a) break;
                        var r = t.cells[n.index].data,
                            o = e.cells[n.index].data;
                        a |= "function" == typeof n.compare ? n.compare(r, o) * n.direction : this.compare(r, o) * n.direction
                    }
                    return a
                }, i._process = function(t) {
                    var e = [].concat(t.rows);
                    e.sort(this.compareWrapper.bind(this));
                    var i = new va(e);
                    return i.length = t.length, i
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.Sort
                    }
                }]), e
            }(ya),
            fs = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.getInitialState = function() {
                    return []
                }, i.handle = function(t, e) {
                    "SORT_COLUMN" === t ? this.sortColumn(e.index, e.direction, e.multi, e.compare) : "SORT_COLUMN_TOGGLE" === t && this.sortToggle(e.index, e.multi, e.compare)
                }, i.sortToggle = function(t, e, i) {
                    var a = [].concat(this.state).find((function(e) {
                        return e.index === t
                    }));
                    this.sortColumn(t, a && 1 === a.direction ? -1 : 1, e, i)
                }, i.sortColumn = function(t, e, i, a) {
                    var s = [].concat(this.state),
                        n = s.length,
                        r = s.find((function(e) {
                            return e.index === t
                        })),
                        o = !1,
                        l = !1,
                        c = !1,
                        h = !1;
                    if (void 0 !== r ? i ? -1 === r.direction ? c = !0 : h = !0 : 1 === n ? h = !0 : n > 1 && (l = !0, o = !0) : 0 === n ? o = !0 : n > 0 && !i ? (o = !0, l = !0) : n > 0 && i && (o = !0), l && (s = []), o) s.push({
                        index: t,
                        direction: e,
                        compare: a
                    });
                    else if (h) {
                        var d = s.indexOf(r);
                        s[d].direction = e
                    } else if (c) {
                        var u = s.indexOf(r);
                        s.splice(u, 1)
                    }
                    this.setState(s)
                }, e
            }(Aa),
            ms = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.sortColumn = function(t, e, i, a) {
                    this.dispatch("SORT_COLUMN", {
                        index: t,
                        direction: e,
                        multi: i,
                        compare: a
                    })
                }, i.sortToggle = function(t, e, i) {
                    this.dispatch("SORT_COLUMN_TOGGLE", {
                        index: t,
                        multi: e,
                        compare: i
                    })
                }, e
            }(Ta),
            xs = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype._process = function(t) {
                    var e = {};
                    return this.props.url && (e.url = this.props.url(t.url, this.props.columns)), this.props.body && (e.body = this.props.body(t.body, this.props.columns)), wi({}, t, e)
                }, yi(e, [{
                    key: "type",
                    get: function() {
                        return fa.ServerSort
                    }
                }]), e
            }(ya),
            vs = function(t) {
                function e(e, i) {
                    var a;
                    return (a = t.call(this, e, i) || this).sortProcessor = void 0, a.actions = void 0, a.store = void 0, a.updateStateFn = void 0, a.updateSortProcessorFn = void 0, a.actions = new ms(a.config.dispatcher), a.store = new fs(a.config.dispatcher), e.enabled && (a.sortProcessor = a.getOrCreateSortProcessor(), a.updateStateFn = a.updateState.bind(ki(a)), a.store.on("updated", a.updateStateFn), a.state = {
                        direction: 0
                    }), a
                }
                Si(e, t);
                var i = e.prototype;
                return i.componentWillUnmount = function() {
                    this.config.pipeline.unregister(this.sortProcessor), this.store.off("updated", this.updateStateFn), this.updateSortProcessorFn && this.store.off("updated", this.updateSortProcessorFn)
                }, i.updateState = function() {
                    var t = this,
                        e = this.store.state.find((function(e) {
                            return e.index === t.props.index
                        }));
                    this.setState(e ? {
                        direction: e.direction
                    } : {
                        direction: 0
                    })
                }, i.updateSortProcessor = function(t) {
                    this.sortProcessor.setProps({
                        columns: t
                    })
                }, i.getOrCreateSortProcessor = function() {
                    var t = fa.Sort;
                    this.config.sort && "object" == typeof this.config.sort.server && (t = fa.ServerSort);
                    var e, i = this.config.pipeline.getStepsByType(t);
                    return i.length > 0 ? e = i[0] : (this.updateSortProcessorFn = this.updateSortProcessor.bind(this), this.store.on("updated", this.updateSortProcessorFn), e = t === fa.ServerSort ? new xs(wi({
                        columns: this.store.state
                    }, this.config.sort.server)) : new gs({
                        columns: this.store.state
                    }), this.config.pipeline.register(e)), e
                }, i.changeDirection = function(t) {
                    t.preventDefault(), t.stopPropagation(), this.actions.sortToggle(this.props.index, !0 === t.shiftKey && this.config.sort.multiColumn, this.props.compare)
                }, i.render = function() {
                    if (!this.props.enabled) return null;
                    var t = this.state.direction,
                        e = "neutral";
                    return 1 === t ? e = "asc" : -1 === t && (e = "desc"), Fi("button", {
                        tabIndex: -1,
                        "aria-label": this._("sort.sort" + (1 === t ? "Desc" : "Asc")),
                        title: this._("sort.sort" + (1 === t ? "Desc" : "Asc")),
                        className: Ca(Sa("sort"), Sa("sort", e), this.config.className.sort),
                        onClick: this.changeDirection.bind(this)
                    })
                }, e
            }(ua),
            bs = function(t) {
                function e() {
                    for (var e, i = arguments.length, a = new Array(i), s = 0; s < i; s++) a[s] = arguments[s];
                    return (e = t.call.apply(t, [this].concat(a)) || this).moveFn = void 0, e.upFn = void 0, e
                }
                Si(e, t);
                var i = e.prototype;
                return i.getPageX = function(t) {
                    return t instanceof MouseEvent ? Math.floor(t.pageX) : Math.floor(t.changedTouches[0].pageX)
                }, i.start = function(t) {
                    var e, i, a, s, n;
                    t.stopPropagation(), this.setState({
                        offsetStart: parseInt(this.props.thRef.current.style.width, 10) - this.getPageX(t)
                    }), this.upFn = this.end.bind(this), this.moveFn = (e = this.move.bind(this), void 0 === (i = 10) && (i = 100), function() {
                        var t = [].slice.call(arguments);
                        a ? (clearTimeout(s), s = setTimeout((function() {
                            Date.now() - n >= i && (e.apply(void 0, t), n = Date.now())
                        }), Math.max(i - (Date.now() - n), 0))) : (e.apply(void 0, t), n = Date.now(), a = !0)
                    }), document.addEventListener("mouseup", this.upFn), document.addEventListener("touchend", this.upFn), document.addEventListener("mousemove", this.moveFn), document.addEventListener("touchmove", this.moveFn)
                }, i.move = function(t) {
                    t.stopPropagation();
                    var e = this.props.thRef.current;
                    this.state.offsetStart + this.getPageX(t) >= parseInt(e.style.minWidth, 10) && (e.style.width = this.state.offsetStart + this.getPageX(t) + "px")
                }, i.end = function(t) {
                    t.stopPropagation(), document.removeEventListener("mouseup", this.upFn), document.removeEventListener("mousemove", this.moveFn), document.removeEventListener("touchmove", this.moveFn), document.removeEventListener("touchend", this.upFn)
                }, i.render = function() {
                    return Fi("div", {
                        className: Ca(Sa("th"), Sa("resizable")),
                        onMouseDown: this.start.bind(this),
                        onTouchStart: this.start.bind(this),
                        onClick: function(t) {
                            return t.stopPropagation()
                        }
                    })
                }, e
            }(ua),
            ys = function(t) {
                function e(e, i) {
                    var a;
                    return (a = t.call(this, e, i) || this).sortRef = {
                        current: null
                    }, a.thRef = {
                        current: null
                    }, a.state = {
                        style: {}
                    }, a
                }
                Si(e, t);
                var i = e.prototype;
                return i.isSortable = function() {
                    return this.props.column.sort.enabled
                }, i.isResizable = function() {
                    return this.props.column.resizable
                }, i.onClick = function(t) {
                    t.stopPropagation(), this.isSortable() && this.sortRef.current.changeDirection(t)
                }, i.keyDown = function(t) {
                    this.isSortable() && 13 === t.which && this.onClick(t)
                }, i.componentDidMount = function() {
                    var t = this;
                    setTimeout((function() {
                        if (t.props.column.fixedHeader && t.thRef.current) {
                            var e = t.thRef.current.offsetTop;
                            "number" == typeof e && t.setState({
                                style: {
                                    top: e
                                }
                            })
                        }
                    }), 0)
                }, i.content = function() {
                    return void 0 !== this.props.column.name ? this.props.column.name : void 0 !== this.props.column.plugin ? Fi(za, {
                        pluginId: this.props.column.plugin.id,
                        props: {
                            column: this.props.column
                        }
                    }) : null
                }, i.getCustomAttributes = function() {
                    var t = this.props.column;
                    return t ? "function" == typeof t.attributes ? t.attributes(null, null, this.props.column) : t.attributes : {}
                }, i.render = function() {
                    var t = {};
                    return this.isSortable() && (t.tabIndex = 0), Fi("th", wi({
                        ref: this.thRef,
                        "data-column-id": this.props.column && this.props.column.id,
                        className: Ca(Sa("th"), this.isSortable() ? Sa("th", "sort") : null, this.props.column.fixedHeader ? Sa("th", "fixed") : null, this.config.className.th),
                        onClick: this.onClick.bind(this),
                        style: wi({}, this.config.style.th, {
                            minWidth: this.props.column.minWidth,
                            width: this.props.column.width
                        }, this.state.style, this.props.style),
                        onKeyDown: this.keyDown.bind(this),
                        rowSpan: this.props.rowSpan > 1 ? this.props.rowSpan : void 0,
                        colSpan: this.props.colSpan > 1 ? this.props.colSpan : void 0
                    }, this.getCustomAttributes(), t), Fi("div", {
                        className: Sa("th", "content")
                    }, this.content()), this.isSortable() && Fi(vs, wi({
                        ref: this.sortRef,
                        index: this.props.index
                    }, this.props.column.sort)), this.isResizable() && this.props.index < this.config.header.visibleColumns.length - 1 && Fi(bs, {
                        column: this.props.column,
                        thRef: this.thRef
                    }))
                }, e
            }(ua),
            ws = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                Si(e, t);
                var i = e.prototype;
                return i.renderColumn = function(t, e, i, a) {
                    var s = function(t, e, i) {
                        var a = Wa.maximumDepth(t),
                            s = i - e;
                        return {
                            rowSpan: Math.floor(s - a - a / s),
                            colSpan: t.columns && t.columns.length || 1
                        }
                    }(t, e, a);
                    return Fi(ys, {
                        column: t,
                        index: i,
                        colSpan: s.colSpan,
                        rowSpan: s.rowSpan
                    })
                }, i.renderRow = function(t, e, i) {
                    var a = this,
                        s = Wa.leafColumns(this.props.header.columns);
                    return Fi(ds, null, t.map((function(t) {
                        return t.hidden ? null : a.renderColumn(t, e, s.indexOf(t), i)
                    })))
                }, i.renderRows = function() {
                    var t = this,
                        e = Wa.tabularFormat(this.props.header.columns);
                    return e.map((function(i, a) {
                        return t.renderRow(i, a, e.length)
                    }))
                }, i.render = function() {
                    return this.props.header ? Fi("thead", {
                        key: this.props.header.id,
                        className: Ca(Sa("thead"), this.config.className.thead)
                    }, this.renderRows()) : null
                }, e
            }(ua),
            Ss = function(t) {
                function e() {
                    return t.apply(this, arguments) || this
                }
                return Si(e, t), e.prototype.render = function() {
                    return Fi("table", {
                        role: "grid",
                        className: Ca(Sa("table"), this.config.className.table),
                        style: wi({}, this.config.style.table, {
                            height: this.props.height
                        })
                    }, Fi(ws, {
                        header: this.props.header
                    }), Fi(ps, {
                        data: this.props.data,
                        status: this.props.status,
                        header: this.props.header
                    }))
                }, e
            }(ua),
            Cs = function(t) {
                function e(e, i) {
                    var a;
                    return (a = t.call(this, e, i) || this).headerRef = {
                        current: null
                    }, a.state = {
                        isActive: !0
                    }, a
                }
                Si(e, t);
                var i = e.prototype;
                return i.componentDidMount = function() {
                    0 === this.headerRef.current.children.length && this.setState({
                        isActive: !1
                    })
                }, i.render = function() {
                    return this.state.isActive ? Fi("div", {
                        ref: this.headerRef,
                        className: Ca(Sa("head"), this.config.className.header),
                        style: wi({}, this.config.style.header)
                    }, Fi(za, {
                        position: ka.Header
                    })) : null
                }, e
            }(ua),
            ks = function(t) {
                function e(e, i) {
                    var a;
                    return (a = t.call(this, e, i) || this).footerRef = {
                        current: null
                    }, a.state = {
                        isActive: !0
                    }, a
                }
                Si(e, t);
                var i = e.prototype;
                return i.componentDidMount = function() {
                    0 === this.footerRef.current.children.length && this.setState({
                        isActive: !1
                    })
                }, i.render = function() {
                    return this.state.isActive ? Fi("div", {
                        ref: this.footerRef,
                        className: Ca(Sa("footer"), this.config.className.footer),
                        style: wi({}, this.config.style.footer)
                    }, Fi(za, {
                        position: ka.Footer
                    })) : null
                }, e
            }(ua),
            As = function(t) {
                function e(e, i) {
                    var a;
                    return (a = t.call(this, e, i) || this).configContext = void 0, a.processPipelineFn = void 0, a.configContext = function(t, e) {
                        var i = {
                            __c: e = "__cC" + zi++,
                            __: null,
                            Consumer: function(t, e) {
                                return t.children(e)
                            },
                            Provider: function(t) {
                                var i, a;
                                return this.getChildContext || (i = [], (a = {})[e] = this, this.getChildContext = function() {
                                    return a
                                }, this.shouldComponentUpdate = function(t) {
                                    this.props.value !== t.value && i.some(Vi)
                                }, this.sub = function(t) {
                                    i.push(t);
                                    var e = t.componentWillUnmount;
                                    t.componentWillUnmount = function() {
                                        i.splice(i.indexOf(t), 1), e && e.call(t)
                                    }
                                }), t.children
                            }
                        };
                        return i.Provider.__ = i.Consumer.contextType = i
                    }(), a.state = {
                        status: Qa.Loading,
                        header: e.header,
                        data: null
                    }, a
                }
                Si(e, t);
                var i = e.prototype;
                return i.processPipeline = function() {
                    try {
                        var t = this;
                        t.props.config.eventEmitter.emit("beforeLoad"), t.setState({
                            status: Qa.Loading
                        });
                        var e = function(e, i) {
                            try {
                                var a = Promise.resolve(t.props.pipeline.process()).then((function(e) {
                                    t.setState({
                                        data: e,
                                        status: Qa.Loaded
                                    }), t.props.config.eventEmitter.emit("load", e)
                                }))
                            } catch (t) {
                                return i(t)
                            }
                            return a && a.then ? a.then(void 0, i) : a
                        }(0, (function(e) {
                            La.error(e), t.setState({
                                status: Qa.Error,
                                data: null
                            })
                        }));
                        return Promise.resolve(e && e.then ? e.then((function() {})) : void 0)
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, i.componentDidMount = function() {
                    try {
                        var t = this,
                            e = t.props.config;
                        return Promise.resolve(t.processPipeline()).then((function() {
                            e.header && t.state.data && t.state.data.length && t.setState({
                                header: e.header.adjustWidth(e)
                            }), t.processPipelineFn = t.processPipeline.bind(t), t.props.pipeline.on("updated", t.processPipelineFn)
                        }))
                    } catch (t) {
                        return Promise.reject(t)
                    }
                }, i.componentWillUnmount = function() {
                    this.props.pipeline.off("updated", this.processPipelineFn)
                }, i.componentDidUpdate = function(t, e) {
                    e.status != Qa.Rendered && this.state.status == Qa.Loaded && (this.setState({
                        status: Qa.Rendered
                    }), this.props.config.eventEmitter.emit("ready"))
                }, i.render = function() {
                    return Fi(this.configContext.Provider, {
                        value: this.props.config
                    }, Fi("div", {
                        role: "complementary",
                        className: Ca("gridjs", Sa("container"), this.state.status === Qa.Loading ? Sa("loading") : null, this.props.config.className.container),
                        style: wi({}, this.props.config.style.container, {
                            width: this.props.width
                        })
                    }, this.state.status === Qa.Loading && Fi("div", {
                        className: Sa("loading-bar")
                    }), Fi(Cs, null), Fi("div", {
                        className: Sa("wrapper"),
                        style: {
                            height: this.props.height
                        }
                    }, Fi(Ss, {
                        ref: this.props.config.tableRef,
                        data: this.state.data,
                        header: this.state.header,
                        width: this.props.width,
                        height: this.props.height,
                        status: this.state.status
                    })), Fi(ks, null), Fi("div", {
                        ref: this.props.config.tempRef,
                        id: "gridjs-temp",
                        className: Sa("temp")
                    })))
                }, e
            }(ua),
            Es = function(t) {
                function e(e) {
                    var i;
                    return (i = t.call(this) || this).config = void 0, i.plugin = void 0, i.config = new ns({
                        instance: ki(i),
                        eventEmitter: ki(i)
                    }).update(e), i.plugin = i.config.plugin, i
                }
                Si(e, t);
                var i = e.prototype;
                return i.updateConfig = function(t) {
                    return this.config.update(t), this
                }, i.createElement = function() {
                    return Fi(As, {
                        config: this.config,
                        pipeline: this.config.pipeline,
                        header: this.config.header,
                        width: this.config.width,
                        height: this.config.height
                    })
                }, i.forceRender = function() {
                    return this.config && this.config.container || La.error("Container is empty. Make sure you call render() before forceRender()", !0), this.config.pipeline.clearCache(), oa(null, this.config.container), oa(this.createElement(), this.config.container), this
                }, i.render = function(t) {
                    return t || La.error("Container element cannot be null", !0), t.childNodes.length > 0 ? (La.error("The container element " + t + " is not empty. Make sure the container is empty and call render() again"), this) : (this.config.container = t, oa(this.createElement(), t), this)
                }, e
            }(ba),
            Ts = 0,
            Ps = [],
            Ms = [],
            Ls = Pi.__b,
            Is = Pi.__r,
            _s = Pi.diffed,
            zs = Pi.__c,
            Ds = Pi.unmount;

        function Xs(t, e) {
            Pi.__h && Pi.__h(os, t, Ts || e), Ts = 0;
            var i = os.__H || (os.__H = {
                __: [],
                __h: []
            });
            return t >= i.__.length && i.__.push({
                __V: Ms
            }), i.__[t]
        }

        function Os(t, e) {
            var i = Xs(rs++, 3);
            !Pi.__s && Ws(i.__H, e) && (i.__ = t, i.i = e, os.__H.__h.push(i))
        }

        function Ns(t) {
            return Ts = 5,
                function(t, e) {
                    var i = Xs(rs++, 7);
                    return Ws(i.__H, e) ? (i.__V = t(), i.i = e, i.__h = t, i.__V) : i.__
                }((function() {
                    return {
                        current: t
                    }
                }), [])
        }

        function Ys() {
            for (var t; t = Ps.shift();)
                if (t.__P && t.__H) try {
                    t.__H.__h.forEach(Rs), t.__H.__h.forEach(Hs), t.__H.__h = []
                } catch (e) {
                    t.__H.__h = [], Pi.__e(e, t.__v)
                }
        }
        Pi.__b = function(t) {
            os = null, Ls && Ls(t)
        }, Pi.__r = function(t) {
            Is && Is(t), rs = 0;
            var e = (os = t.__c).__H;
            e && (ls === os ? (e.__h = [], os.__h = [], e.__.forEach((function(t) {
                t.__N && (t.__ = t.__N), t.__V = Ms, t.__N = t.i = void 0
            }))) : (e.__h.forEach(Rs), e.__h.forEach(Hs), e.__h = [])), ls = os
        }, Pi.diffed = function(t) {
            _s && _s(t);
            var e = t.__c;
            e && e.__H && (e.__H.__h.length && (1 !== Ps.push(e) && cs === Pi.requestAnimationFrame || ((cs = Pi.requestAnimationFrame) || function(t) {
                var e, i = function() {
                        clearTimeout(a), Fs && cancelAnimationFrame(e), setTimeout(t)
                    },
                    a = setTimeout(i, 100);
                Fs && (e = requestAnimationFrame(i))
            })(Ys)), e.__H.__.forEach((function(t) {
                t.i && (t.__H = t.i), t.__V !== Ms && (t.__ = t.__V), t.i = void 0, t.__V = Ms
            }))), ls = os = null
        }, Pi.__c = function(t, e) {
            e.some((function(t) {
                try {
                    t.__h.forEach(Rs), t.__h = t.__h.filter((function(t) {
                        return !t.__ || Hs(t)
                    }))
                } catch (i) {
                    e.some((function(t) {
                        t.__h && (t.__h = [])
                    })), e = [], Pi.__e(i, t.__v)
                }
            })), zs && zs(t, e)
        }, Pi.unmount = function(t) {
            Ds && Ds(t);
            var e, i = t.__c;
            i && i.__H && (i.__H.__.forEach((function(t) {
                try {
                    Rs(t)
                } catch (t) {
                    e = t
                }
            })), e && Pi.__e(e, i.__v))
        };
        var Fs = "function" == typeof requestAnimationFrame;

        function Rs(t) {
            var e = os,
                i = t.__c;
            "function" == typeof i && (t.__c = void 0, i()), os = e
        }

        function Hs(t) {
            var e = os;
            t.__c = t.__(), os = e
        }

        function Ws(t, e) {
            return !t || t.length !== e.length || e.some((function(e, i) {
                return e !== t[i]
            }))
        }
        window.Swiper = tt, window.Sortable = mi, window.ApexCharts = vi(), window.Gridjs = t
    })()
})();